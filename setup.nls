; the setup procedures for
; 1. the hidden variables (not set in the interface)
; 2. building the argumentative landscape with
;    attacks and discovery relations
; 3. populate the landscape with agents


; the core-setup procedure:
; the hidden variables (not set in the interface)
; it creates a landscape of arguments and a discovery relation
; on this landscape; attacks are defined;
; the agents are distributed over the theories
to setupcore [clearing numberoftheories theorydepth scientistsno]
  run clearing
  initialize-hidden-variables
  create-discovery-landscape runresult numberoftheories runresult theorydepth
  define-attack-relation
  distribute-agents runresult scientistsno
  reset-ticks
end

; the setup for a normal run
to setup
	setupcore task [clear-all] task [number-of-theories] task [theory-depth] task [scientists]
end

; the setup for a run-many
to setup-many
  ; instead of clear-all, the globals should not be cleared
	setupcore task [ clear-turtles clear-patches clear-drawing clear-all-plots clear-output ] task [number-of-theories-many] task [theory-depth-many] task [scientists-many]
end

; procedure in which the variables that are not mentioned 
; in the interface can be set
to initialize-hidden-variables
  ; the number of arguments that an agent can learn
  ; each tick
  set max-learn 10
 
  ; the probability that agents move every round is
  ; only small-movement * move-probability
  set small-movement 0.2
 
  ; influence color on move probability
  set color-move 200
end





; a landscape of arguments and a discovery relation
; on these arguments is defined
to create-discovery-landscape [numberoftheories theorydepth]
  ; at the start arguments and starts are a circle
  set-default-shape arguments "circle"
  set-default-shape starts "circle"
  
  repeat numberoftheories [ ; trees are created theory for theory
    create-starts 1 [
      ; variables for color, the theory it belongs to
      ; and whether it just turned red are initialized
      set color lime
      set current-start true
      set mytheory self
      set full-research false
    ]
    let i 0
    while [i < theorydepth] [
      create-arguments ( 4 ^ (theorydepth - i))[
        ; variables for color, the theory it belongs to
        ; and whether it just turned red are initialized
        set color gray
        set current-argument true
        set mytheory one-of starts with [current-start]
        set full-research false
      ]
      set i i + 1
    ]
    
    ; with the created turtles (arguments and roots)
    ; trees are build, one for each start/root
    create-discovery-trees
    
    ask starts [ ; to make sure that all theories are visible
      create-starters-with other starts [set color black]
      set current-start false
    ]
    ask arguments [set current-argument false]
  ]
  ; set the shape of the arguments of the best theory different from a circle
  ask turtles with [(breed = starts or breed = arguments) and
    mytheory = start 0 ][
    set shape "triangle"
  ]
end





; create the theory discovery trees
; each node has 0 or 4 child-arguments
; starting from the starts as root
to create-discovery-trees
  ; first level with starts as roots
  ask starts with [count out-discovery-neighbors = 0 and current-start][
    repeat 4 [
      if any? arguments with [count in-discovery-neighbors = 0 and
        current-argument] [
        create-discovery-to one-of arguments with [
          count in-discovery-neighbors = 0 and current-argument]
      ]
    ]
  ]
  ; then adding all the normal arguments
  while [any? arguments with [count in-discovery-neighbors = 0 and
    current-argument]][
    ask arguments with [count in-discovery-neighbors = 1 and
      count out-discovery-neighbors < 4 and current-argument][
      let curarg self
      repeat (4 - count out-discovery-neighbors) [
        if any? other arguments with [count in-discovery-neighbors = 0 and
          current-argument and not out-discovery-neighbor? curarg][
          create-discovery-to one-of other arguments with
	        [count in-discovery-neighbors = 0 and current-argument]
          ]
      ]
    ]
  ]
end





; on the created landscape an attack relation is defined
; attacks occur only between theories
; the probability that an argument is attacked by another argument
; depends on the attack-probability for the theory the attacked
; argument belongs to, as can be set in the interface
; one theory, the objective best, defends all its arguments
to define-attack-relation
  ; first the random attacks are defined
  define-attack-relation-create-attacks
  
  ; then the best theory defends itself
  define-attack-relation-defend-best
  
  ; the arguments and relations are spread over the patches
  define-attack-relation-visualize
end





; this procedure creates the random attacks from one theory to another
to define-attack-relation-create-attacks
  ask turtles with [breed = starts or breed = arguments][
    ; variables for the current argument, the theory it belongs to,
    ; a random number between 0.00 and 1.00 and a list of theories
    let askargu self
    let curtheory mytheory
    let attack-random random-float 1.00
    let starts-list []
    ask starts [
      set starts-list lput who starts-list
    ]
    set starts-list sort starts-list
    
    ; with attack-probability-2nd from the interface an attack towards
    ; the current argument is created
    ifelse number-of-theories = 2[
      if attack-random < attack-probability-2nd and curtheory != start 0 [
        create-attack-from one-of other turtles with [(breed = starts or
	      breed = arguments)and mytheory != curtheory and not
	      (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
	      out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        set color gray
            ]
      ]
    ][
    
    ; when there are three theories both attack-probability-2nd and -3rd are
    ; considered to create attacks, depending on the theory the current argument
    ; belongs to first for the third theory
    ifelse [who] of curtheory = max starts-list and attack-random <
      attack-probability-3rd [
      create-attack-to one-of other turtles with [(breed = starts or
        breed = arguments) and mytheory != curtheory and not
	      (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
	      out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        set color gray
          ]
    ][
    ; then attacks towards arguments of the 2nd theory are created
    if [who] of curtheory != max starts-list and curtheory != start 0 and
      attack-random < attack-probability-2nd [
      create-attack-from one-of other turtles with [(breed = starts or
      breed = arguments) and mytheory != curtheory and not
      (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
	    out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        set color gray
          ]
    ]
    ]
    ]
    
    ; if the current argument belongs to the objective best theory
    ; an attack towards this argument is created with attack-probability-best
    if attack-random < attack-probability-best and curtheory = start 0 [
      create-attack-from one-of other turtles with [(breed = starts or
      breed = arguments) and mytheory != curtheory and not
	    (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
	    out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        set color gray
          ]
    ]
  ]
end





; after the random attacks are created, attacks coming from the best theory
; are added such that it defends itself completely
to define-attack-relation-defend-best
  ask turtles with [(breed = starts or breed = arguments) and
    mytheory = start 0][
    ; variable for the current argument
    let askargu self
    
    if any? in-attack-neighbors [
      ask in-attack-neighbors [
        ; variable for the attacking argument, if such an argument exists
        let askattack self
        ; a defending attack is only created if there is not yet an attack
        ; from an argument of the best theory towards the attacking argument
        if not any? in-attack-neighbors with [mytheory = start 0][
          create-attack-from one-of turtles with [(breed = starts or
	        breed = arguments) and mytheory = start 0 and not
	        (in-discovery-neighbor? askattack or in-attack-neighbor?
	        askattack or out-discovery-neighbor? askattack or
	        out-attack-neighbor? askattack) and not (self = askargu)][
            set color gray
          ]
        ]
      ]
    ]
  ]
end





; creates the visible tree, centered around 
; the root of the best theory
to define-attack-relation-visualize
  layout-radial
  turtles with [breed = arguments or breed = starts]
  links with [breed = discoveries or breed = starters]
  start 0
end





; in this procedure the agents are created,
; including their memory and the social netoworks
; and they are distributed randomly over the theories
to distribute-agents [scientistsno]
  set-default-shape agents "person"
  
  ; the right number of agents is created
  ; and the agent variables are initialized
  agents-create-scientists scientistsno
  
  ; create the network of collaborators
  ; if in the interface "within-theory" is on, collaborative networks are created
  ; among agents that start from the same theory
  ; a network has at most 5 agents in it
  ifelse within-theory [
    distribute-agents-within-theory-on
  ][
  ; if "within-theory" is off in the interface, random collaborative networks
  ; are created, all of size 5
  distribute-agents-within-theory-off    
  ]
  
  ; the memory of the agents is created
  agents-create-memory
  
  ; the networks in which agents share with other groups is created
  create-networks
end





; create agents and initialize their variables
to agents-create-scientists [scientistsno]
  create-agents scientistsno [
    ; the agents are blue-colored
    ; and start on one of the roots
    set color blue
    move-to one-of starts
    
    ; the agent-own variables are initialized
    set collaborator-network []
    set subjective-relations []
    set subjective-arguments []
    set times-jumped 0
    set communicating 0
    set moved false
    set rep-agent false
    
    ; an agent is always aware of all the theories
    ; the information the agent has about a theory
    ; is collected in current-theory-info which has
    ; the form [[(start 0) no. adm args] ...]
    let theories []
    ask starts [
      let start-add []
      set start-add lput self start-add
      set start-add lput 0 start-add
      set theories lput start-add theories
    ]
    set current-theory-info theories
  ]
end





; create the memory of the agent
; keep track of the theories and arguments that the agent has visited
; an argument memory entry has two elements: the argument and its color:
; [[(argument a) colora] ... [(argument i) colori] ...]
to agents-create-memory
  ask agents [
    ; variables for the x and y coordinate and the theory of
    ; the current agent
    let myx xcor
    let myy ycor
    let cur-theory one-of starts with [xcor = myx and ycor = myy]
    
    ; the current theory is added to the subjective-arguments list:
    ; [[(start x) lime]]
    let add-cur []
    set add-cur lput cur-theory add-cur
    set add-cur lput [color] of cur-theory add-cur
    set subjective-arguments lput add-cur subjective-arguments
  ]
end





; if in the interface "within-theory" is on, collaborative networks are created
; among agents that start from the same theory
; a network has at most 5 agents in it
to distribute-agents-within-theory-on
  ask starts [
    ; variables for the x and y coordinates of the root
    ; and an empty list for the created network
    let myx xcor
    let myy ycor
    let cur-col []
    
    ; while there are more than five agents on the root without a network
    ; networks of exactly five agents are created
    if any? agents with [xcor = myx and ycor = myy and
      empty? collaborator-network][
      while [count agents with [xcor = myx and ycor = myy and
        empty? collaborator-network] > 5][
        ; five agents are added to the list cur-col
        ; which is then set as the collaborator-network of each of these agents
        ask n-of 5 agents with [xcor = myx and ycor = myy and
	        empty? collaborator-network] [
          set cur-col lput self cur-col
        ]
        ask agents with [member? self cur-col][
          set collaborator-network cur-col
        ]
        set cur-col []
      ]
      ; once there are five or less agents without a network
      ; they form a network together
      ask agents with [xcor = myx and ycor = myy and
        empty? collaborator-network] [
        set cur-col lput self cur-col
      ]
      ask agents with [member? self cur-col][
        set collaborator-network cur-col
      ]
    ]
  ]
end





; if "within-theory" is off in the interface random collaborative networks
; are created, all of size 5
to distribute-agents-within-theory-off
  while [any? agents with [empty? collaborator-network]][
    ; variable that collects exactly five agents for a network
    let cur-col []
    ask n-of 5 agents with [empty? collaborator-network][
      set cur-col lput self cur-col
    ]
    ask agents with [member? self cur-col][
      set collaborator-network cur-col
    ]
  ]
end





; computations for the Popularity plot
; it computes for every theory the number of
; agents working on it
to compute-popularity
  ; initialize the variable at 0 
  ask starts [ set myscientists 0 ]
  
  ask agents [
    ; variables for x and y coordinate of the current agent,
    ; the argument it is currently working on and the 
    ; theory this argument belongs to
    let myx xcor
    let myy ycor
    let myargu one-of turtles with [(breed = starts or breed = arguments) and
      xcor = myx and ycor = myy]
    let mystart [mytheory] of myargu
    
    ; the myscientists variable of the theory the agent
    ; is working on is increased by one
    ask mystart [
      set myscientists myscientists + 1
    ]
  ]
end




; the social network structures for collaborator networks
; is created according to the choice made in the interface:
; cycle, wheel or complete
to create-networks
  ; initialize variables for the collection of the networks
  ; and the networks that will share with each other
  set colla-networks []
  ; an entry in share-structure starts with the network that
  ; is the network that initializes the sharing
  set share-structure []
  
  ; list of all sorted collaborator-networks
  let networks []
  ask agents [
    set networks lput sort collaborator-network networks
  ]
  set colla-networks remove-duplicates networks
  
  ; in the case that the choice in the interface is cycle
  ifelse network-structure = "cycle" [
    let connect-networks colla-networks
    
    ; when there are only two collaborator-networks
    ; they always share with each other
    ifelse length colla-networks = 2 [
      set share-structure lput colla-networks share-structure
      set share-structure lput reverse colla-networks share-structure
    ][ 
    
    ; in all other cases networks share with two neighboring networks
    ; for three networks this is still a complete case
    while [length connect-networks > 2] [
      ; first the entries for the beginning and end of the list
      ifelse empty? share-structure[
        let to-add-structure1 []
        let to-add-structure2 []
        set to-add-structure1 lput first connect-networks to-add-structure1
        set to-add-structure1 lput first but-first connect-networks to-add-structure1
        set to-add-structure1 lput last connect-networks to-add-structure1
        set to-add-structure2 lput last connect-networks to-add-structure2
        set to-add-structure2 lput first connect-networks to-add-structure2
        set to-add-structure2 lput last but-last connect-networks to-add-structure2
        set share-structure lput to-add-structure1 share-structure
        set share-structure lput to-add-structure2 share-structure
      ][
      ; then the networks in between
      let to-add-structure []
      set to-add-structure lput first but-first connect-networks to-add-structure
      set to-add-structure lput first connect-networks to-add-structure
      set connect-networks remove-item 0 connect-networks
      set to-add-structure lput first but-first connect-networks to-add-structure
      set share-structure lput to-add-structure share-structure 
      ]
    ]
    ]
  ][
  
  ; in the case that the choice in the interface is wheel
  ifelse network-structure = "wheel" [
    let connect-networks colla-networks
    
    ; when there are only two or three collaborator-networks
    ; they always share with each other
    ifelse length colla-networks < 4 [
      set share-structure lput colla-networks share-structure
      set share-structure lput reverse colla-networks share-structure
      if length colla-networks = 3 [
        let add-colla-networks []
        set add-colla-networks lput first but-first colla-networks add-colla-networks
        set add-colla-networks lput first colla-networks add-colla-networks
        set add-colla-networks lput last colla-networks add-colla-networks
        set share-structure lput add-colla-networks share-structure
      ]
    ][ 
    
    ; the first network is defined to be the royal family:
    ; the network that shares with all other networks
    let middle first connect-networks
    set connect-networks remove-item 0 connect-networks
    let add-middle []
    set add-middle lput middle add-middle
    foreach connect-networks [
      if ? != middle [
        set add-middle lput ? add-middle
      ]
    ]
    ; the other networks are put in a cycle, with the
    ; addition that every networks shares with middle (the royal family)
    while [length connect-networks > 2] [
      ifelse empty? share-structure[
        let to-add-structure1 []
        let to-add-structure2 []
        set to-add-structure1 lput first connect-networks to-add-structure1
        set to-add-structure1 lput first but-first connect-networks to-add-structure1
        set to-add-structure1 lput last connect-networks to-add-structure1
        set to-add-structure1 lput middle to-add-structure1
        set to-add-structure2 lput last connect-networks to-add-structure2
        set to-add-structure2 lput first connect-networks to-add-structure2
        set to-add-structure2 lput last but-last connect-networks to-add-structure2
        set to-add-structure2 lput middle to-add-structure2
        set share-structure lput to-add-structure1 share-structure
        set share-structure lput to-add-structure2 share-structure
      ][
      let to-add-structure []
      set to-add-structure lput first but-first connect-networks to-add-structure
      set to-add-structure lput first connect-networks to-add-structure
      set connect-networks remove-item 0 connect-networks
      set to-add-structure lput first but-first connect-networks to-add-structure
      set to-add-structure lput middle to-add-structure
      set share-structure lput to-add-structure share-structure
      ]
    ]
    
    ; the first entry of share-structure is the royal family entry
    set share-structure fput add-middle share-structure
    ]
  ][
  
  ; the other cases: a completely connected graph
  ; for each collaborator-network an entry is created with at the 
  ; first position the network and then all others
  foreach colla-networks [
    let cur-network ? 
    let to-add-structure []
    set to-add-structure lput cur-network to-add-structure
    foreach colla-networks [
      if ? != cur-network [
        set to-add-structure lput ? to-add-structure
      ]
    ]
    set share-structure lput to-add-structure share-structure
  ]
  ]
  ]
end

