
starts-own [mytheory current-start myscientists researcher-ticks full-research research-time-monist research-time-pluralist myscientists-pluralist objective-admissibility group-color-mem group-color-mem-cache full-research]

arguments-own [mytheory current-argument researcher-ticks group-color-mem group-color-mem-cache full-research]
attacks-own [mytheory-end1 mytheory-end2 uncontested in-group-i-memory processed?]

researchers-own [theory-jump times-jumped collaborator-network
  subjective-arguments subjective-relations current-theory-info cur-best-th
  admissible-subj-argu th-args th-relations communicating neighborargs moved
  rep-researcher to-add-mem-argu to-add-mem-rel lastalist lastblist
  lastalistafter flag-updated-memory conference-attended non-admiss-subj-argu subj-argu-as mygps group-id argu-cache]

globals [disc-startsargum-non-red v15 rel-costfactor]

to update-landscape-test15
  carefully [
  ask disc-startsargum-non-red [
    let cur-argum self
    let cur-theory mytheory
    ; discoveries only occur when an researcher is working on that argument,
    ; it is the 5th time step or the researcher does not communicate
    ; working on an argument means that the researcher did
    ; not communicate in that round
    if non-comm-scientists-here-tst13 [
      set researcher-ticks researcher-ticks + 1

      ; the color of an argument is changed if researchers have been working
      ; on that argument for research-speed time steps
      if researcher-ticks mod research-speed = 0 [
        set color color - 10
        ifelse color = red [
          set disc-startsargum-non-red other disc-startsargum-non-red
          full-discovery-test15 cur-argum cur-theory
        ][
          ; depending on the color a new child-argument is discovered, 
          ; until all child-arguments are discovered
          let my-out-disc-neighbor-gt one-of 
            out-discovery-neighbors with [color = gray or color = turquoise]
          if my-out-disc-neighbor-gt != nobody [
            ask my-out-disc-neighbor-gt [
              set color lime
              set disc-startsargum-non-red (turtle-set disc-startsargum-non-red self)
              ask my-in-discoveries [
                set color cyan
              ]
            ]
          ]
        ]
      ]      
      ; for arguments that have still undiscovered relations/neighbors and are
      ; not fully researched
      if ticks mod 5 = 0 [
        let attack-random random-float 1.00

        ; with visibility-probability a new attacked/attacking argument is
        ; discovered
        if attack-random < visibility-probability [
          let my-gray-attack one-of my-attacks with [color = gray]
          if my-gray-attack != nobody [
            ask my-gray-attack [
              discover-attack cur-argum cur-theory
            ]
          ]
        ]
      ]
    ]
    ; if both ends of a discovery relation are discovered
    ; by research, the relation is discovered as well
    ask my-out-discoveries with [color = gray][
      if [not member? color [gray turquoise]] of other-end [
        set color cyan
      ]
    ]    
  ]
  ][show (word "update-landscape-test15" error-message)]
end



to full-discovery-test15 [cur-argum cur-theory]
carefully [
  ; once an argument is fully researched all its relations,
  ; attack and discovery, are discovered
  ask out-discovery-neighbors with [member? color [gray turquoise]] [
    set color lime
    ask my-in-discoveries [
      set color cyan
    ]
  ]
  ; note that in the case of a discovery via attack relation the other
  ; argument is not really discovered: it needs to be discovered by a
  ; discovery relation in the other theory to become lime
  ask my-attacks with [color = gray] [
    discover-attack cur-argum cur-theory     
  ]  
  ][show error-message]
end

to discover-attack [cur-argum cur-theory]
  set color red
  let other-end-argum 0
  let other-theory 0  
  ask other-end [
    set other-end-argum self
    set other-theory mytheory
    if color = gray [set color turquoise]
  ]
  ; ifelse [out-attack-neighbor? other-end-argum] of cur-argum  [
  ifelse mytheory-end1 = cur-theory [
    ask [my-out-attacks with [mytheory-end2 = cur-theory]] of other-end-argum [
      set uncontested false
      ; set color lime ; debugging / test
    ]  
  ][
    ask [my-out-attacks with [mytheory-end2 = other-theory]] of cur-argum [
      set uncontested false
      ; set color blue ; debugging / test
    ]  
  ]
end


to update-memories-test15
carefully [
  ; the argument the researcher is standing on is written to cur-argum
  let cur-argum mygps
  let cur-researcher self
  let cur-group-id group-id
  ; information of current argument in the format of the memory
  let to-add-mem-argu-cache cur-argum
  let to-add-mem-rel-cache no-links
  ask cur-argum [
    set group-color-mem replace-item cur-group-id group-color-mem color
    ask my-links with [color != gray ] [
      let cur-link self
      ask other-end [
        set to-add-mem-argu-cache (turtle-set to-add-mem-argu-cache self)            
        set group-color-mem replace-item cur-group-id group-color-mem color
      ]
      if [breed] of cur-link = attacks [
        set to-add-mem-rel-cache (link-set to-add-mem-rel-cache cur-link)        
      ]
    ]
  ]
  set to-add-mem-argu (turtle-set to-add-mem-argu to-add-mem-argu-cache)
  set to-add-mem-rel (link-set to-add-mem-rel to-add-mem-rel-cache)
  set flag-updated-memory true  
  ][show (word "update-memories-test15" error-message)]
end


to share-with-group-test15
carefully [
  foreach colla-networks [ [cur-group] ->
    let group-sharing-done false
    let grp-share-researcher []
    foreach cur-group [ [cur-researcher] ->
      ifelse group-sharing-done [
        ask cur-researcher [
          set rep-researcher false
          set subjective-arguments [subjective-arguments] of
          grp-share-researcher
          set subjective-relations [subjective-relations] of
          grp-share-researcher
          set subj-argu-as [subj-argu-as] of grp-share-researcher ;is double now for compatibility; should be removed later on
          set to-add-mem-argu no-turtles
          set to-add-mem-rel no-links
        ]
      ][
        set group-sharing-done true
        set grp-share-researcher cur-researcher        
        ask cur-researcher [          
          ; reset the variables
          set rep-researcher false
          let cur-group-id group-id
          ; variables to keep track of the current researchers own memory
          ; and the combined memory of all the sharing researchers
          ; let own-memory-argu subjective-arguments
          ; let own-memory-rel subjective-relations
          let comb-memory-argu no-turtles
          let comb-memory-rel no-links
          ; collaborator network of the current researcher
          transfer-argu-cache-to-memory     
          ; the information in the memories of the single researchers in
          ; the network are combined
          foreach cur-group [ [input-researcher] ->
            set comb-memory-argu (turtle-set comb-memory-argu [to-add-mem-argu] of input-researcher)
            set comb-memory-rel (link-set comb-memory-rel [to-add-mem-rel] of input-researcher)
          ]
          ask comb-memory-rel [
            set in-group-i-memory replace-item cur-group-id in-group-i-memory true
          ]
          ; the group-share-researcher adds the combined memory to its own  
          set subjective-arguments (turtle-set subjective-arguments comb-memory-argu)
          set subjective-relations (link-set subjective-relations comb-memory-rel)
          set subj-argu-as subjective-arguments ;is double now for compatibility; should be removed later on
          set to-add-mem-argu no-turtles
          set to-add-mem-rel no-links
        ]
      ]
    ]
  ]
  ][show (word "share-with-group-test15" error-message)]
end

to transfer-argu-cache-to-memory
  carefully [
  let cur-group-id group-id
  let cached-aguments 0
  let last-inter-group-sharer one-of (turtle-set item cur-group-id colla-networks) with [any? argu-cache]
  if last-inter-group-sharer != nobody [
    ask last-inter-group-sharer [
      set cached-aguments argu-cache with [
        item cur-group-id group-color-mem-cache < 
        item cur-group-id group-color-mem]
      set to-add-mem-argu (turtle-set to-add-mem-argu argu-cache)
      set argu-cache no-turtles
    ]
    ask cached-aguments  [      
      set group-color-mem replace-item cur-group-id group-color-mem 
        (item cur-group-id group-color-mem-cache)   
    ]   
  ]
  ][show (word "transfer-argu-cache-to-memory" error-message)]
end


to create-share-memory-test15
carefully [
  ; for each collaborator-network one researcher is set to be
  ; the representative researcher
  let rep-researchers no-turtles
  foreach colla-networks [ [curgroup] ->
    ask one-of curgroup [
      set rep-researcher true
      set rep-researchers (turtle-set rep-researchers self)
    ]
  ]
  ; only the representative researchers create a memory
  ; that they want to share with researchers from other networks
  ask rep-researchers [
    let cur-argum mygps  
    let cur-researcher self
    let cur-th [mytheory] of cur-argum
    let cur-group-id group-id
    ; create a set of arguments and a set of relations that the researcher
    ; can share with researchers from other collaborative networks
    ; what researchers share depends on the "social-action" and "sharing"
    ; from the interface   
    let th-relations-cache no-links
    let th-args-cache no-turtles
    ask cur-argum [
      ; this has the possibility that a turquoise argument in the discovery neighborhood gets added just although the discovery is not found yet. But for this to happen the researcher must know the argument via an attack relation. This is arguably ok and doesn't collide with our intentions when we "banned" turquoise arguments from being shared      
      set th-args-cache link-neighbors with [
        color != gray and item cur-group-id group-color-mem != cyan] ; this formulation is redundant, but might provide performance benefits -> check
      ifelse social-actions = "biased" [
        set th-relations-cache my-out-attacks with [color != gray]        
      ][
        set th-relations-cache my-attacks with [color != gray]
      ]
    ]
    
    set th-relations th-relations-cache
    set th-args (turtle-set th-args-cache cur-argum)
   ; comments have been removed and need to be added again
  ]
  ][show (word "create-share-memory-test15" error-message)]
end


; can be optimized in multiple regards: group id's, complete-netw optimization,â€¦
; be careful when there can be a case where a group has no rep-researchers. Currently thats not possible but in older versions the singleton protection could cause that with homogenous groups. Not sure whether previous versions (i.e. v10) took this into account appropriately
to share-with-other-netw-test15
carefully [
  ; let rep-researchers researchers with [rep-researcher]
  foreach share-structure [ [cur-share-groups] ->
    let comb-memory-argu no-turtles
    let comb-memory-rel no-links
    ; let other-share-researchers no-turtles
    ; let other-group-ids []
    let askresearcher one-of (turtle-set first cur-share-groups) with [rep-researcher]
    let askresearcher-id [group-id] of askresearcher
    let com-costs 0
    foreach but-first cur-share-groups [[cur-other-group] -> 
      let other-researcher one-of (turtle-set cur-other-group) with [rep-researcher]     
      ; set other-share-researchers (turtle-set other-share-researchers other-researcher)
      ask other-researcher [
        let other-researcher-id group-id
        
        ask th-args with [item other-researcher-id group-color-mem < item askresearcher-id group-color-mem][ ;maybe the "with" could be dropped for more performance?
          if item askresearcher-id group-color-mem-cache = cyan [
            set group-color-mem-cache replace-item 
              askresearcher-id group-color-mem-cache (item askresearcher-id group-color-mem)
          ]
          let other-researcher-color item other-researcher-id group-color-mem
          let askresearcher-cur-color item askresearcher-id group-color-mem-cache
          if other-researcher-color < askresearcher-cur-color [
            set com-costs (com-costs + (askresearcher-cur-color - other-researcher-color))
            set group-color-mem-cache replace-item askresearcher-id group-color-mem-cache other-researcher-color
            set comb-memory-argu (turtle-set comb-memory-argu self)
          ]
        ]      
        ; set comb-memory-argu (turtle-set comb-memory-argu th-args with [
          ; item group-id group-color-mem < item askresearcher-id group-color-mem
        ; ])
        set comb-memory-rel (link-set comb-memory-rel th-relations with [
          not item askresearcher-id in-group-i-memory
        ])
      ]      
    ]
    set com-costs (com-costs + (count comb-memory-rel) * rel-costfactor)
    ; every 1 [show com-costs]
    ask askresearcher [
      set argu-cache comb-memory-argu
      set to-add-mem-rel comb-memory-rel
      ifelse com-costs > (3 * max-learn) [
        let com-cost-remaining (com-costs - 3 * max-learn)
        let cur-group (turtle-set item group-id colla-networks)
        ask cur-group [
          if com-cost-remaining > 0 and not [rep-researcher] of self [
            let com-payment-curresearcher min (list com-cost-remaining (4 * max-learn))
            set communicating ceiling (com-payment-curresearcher / max-learn)
            set com-cost-remaining (com-cost-remaining - com-payment-curresearcher)
          ]
        ]      
      ][
        set communicating ((ceiling (com-costs / max-learn)) + 1)
      ]      
    ] 
  ] 
  ][show (word "share-with-other-netw-test15" error-message)]
end



to compute-subj-attacked-test15
carefully [
  foreach colla-networks [ [cur-group] ->
    let calc-done false
    let calc-researcher 0
    foreach cur-group [ [cur-researcher] ->
      ; if a researcher of the group already calculated defensibility other
      ; group members can copy the results into their memory
      ifelse calc-done [
        ask cur-researcher [
          set admissible-subj-argu [admissible-subj-argu] of calc-researcher ; can be removed, doesn't have any function anymore
          set current-theory-info [current-theory-info] of calc-researcher
          set non-admiss-subj-argu [non-admiss-subj-argu] of calc-researcher
          set cur-best-th [cur-best-th] of calc-researcher
        ]
      ][
        ; if no group member has done the defensibility calculations, the
        ; current researcher does the calculations i.e. she becomes the
        ; groups calc-researcher
        set calc-done true
        set calc-researcher cur-researcher        
        ask cur-researcher [
          let #non-admiss-argu-th []
          let amat attack-mem-to-amat-test15
          set non-admiss-subj-argu []
          ifelse length current-theory-info = 2 [
            set non-admiss-subj-argu turtle-set map turtle adm-calc-core amat
            foreach current-theory-info [[curitem] ->
              let curtheory item 0 curitem
              set #non-admiss-argu-th lput count non-admiss-subj-argu with [mytheory = curtheory] #non-admiss-argu-th              
            ]
          ][   
            let i 0
            foreach current-theory-info [[curitem] ->
              let curtheory item 0 curitem
              let cur-th-amat item i amat
              ; set not-admissible-whos sentence not-admissible-whos adm-calc-core cur-th-amat
              let to-add-non-admiss-argu turtle-set map turtle adm-calc-core cur-th-amat
              set #non-admiss-argu-th lput count to-add-non-admiss-argu with [mytheory = curtheory] #non-admiss-argu-th
              set non-admiss-subj-argu (turtle-set non-admiss-subj-argu to-add-non-admiss-argu)
              set i i + 1
            ]
          ]          
          set-researcher-variables-rest5 #non-admiss-argu-th
          compute-strategies-test14
        ]
      ]        
    ]
  ]
  ][show (word "compute-subj-attacked-test15" error-message)]
end



to-report attack-mem-to-amat-test15
  let attack-relations subjective-relations
  set current-theory-info sort-by [ [?1 ?2] -> item 0 ?1 < item 0 ?2 ] current-theory-info  
  ifelse length current-theory-info = 2 [
    let amat matrix:make-constant count attack-relations 2 -1
    let i 0
    ask attack-relations [
      matrix:set-row amat i (list [who] of end1 [who] of end2 )      
      set i i + 1
    ]
    report amat    
  ][    
    let th-amats []
    foreach current-theory-info [[curentry] ->
      let curtheory item 0 curentry
      
      let curtheory-attacks attack-relations with [mytheory-end1 = curtheory or mytheory-end2 = curtheory]
      let amat-cur-th matrix:make-constant count curtheory-attacks 2 -1
      let i 0
      ask curtheory-attacks [ 
        matrix:set-row amat-cur-th i (list [who] of end1 [who] of end2 )
        set i i + 1       
      ]
      set th-amats lput amat-cur-th th-amats
    ]
    report th-amats  
  ]
end



to move-around-test15
  ; variable to make sure that the procedure find-defense
  ; is only run once
  let run-find-defense false
  ; at the beginning of the procedure no researcher has moved yet
  ask researchers [
    set moved false
  ]
  ask researchers [
    let curresearcher self
    if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
      let myargu mygps     
      ; the researcher owned variable which contains all the non defensible
      ; arguments as a list is written to not-admissible
      let not-admissible non-admiss-subj-argu
      
      ; an researcher working on a non defensible argument will try to find a
      ; defense for this attack, by working further on the attacked argument,
      ; unless she discoveres a child-argument that that has a defense for
      ; the attack (it is not necessarily the case that this defense is
      ; already discovered) or until she has fully researched the argument
      ; the find-defense runs immediately for all researchers working on 
      ; a not fully researched non defensible argument,
      ; hence it is only once executed
      if member? myargu not-admissible and not moved [
        if not run-find-defense [
          find-defense-test13
          set run-find-defense true
        ]
      ]
      
      if not moved and ([color] of myargu = red or not member? myargu not-admissible)[

        ; when an argument exists that:
        ; a) is a child-argument of the current argument;
        ; b) is not gray, red or turquoise; and
        ; c) no researcher from the same collaborator-network is working on it
        ; the researcher moves there, with certain probability
        let nextargu 0
        ask myargu [
          set nextargu one-of out-discovery-neighbors with [
            not member? color [gray red turquoise]
            and not group-member-here-test13 curresearcher]
        ]
        ifelse nextargu != nobody [
          let move-random random-float 1.0


          ; every time step with small-movement of the move-probability
          ; the researcher moves
          ifelse move-random < (small-movement * move-probability *
            (1 - ([color] of myargu / color-move))) [
            move-to-nextargu nextargu
          ][

            ; every 5th time step the researcher mover with the full
            ; move-probability, that depends a bit on the color
            if ticks != 0 and ticks mod 5 = 0 and move-random <
              move-probability * (1 - ([color] of myargu / color-move)) [
              move-to-nextargu nextargu
            ]
          ]
        ][
          if [color] of myargu = red [
            ; if there is no next argument and the current argument is
            ; fully researched, the researcher moves a step back
            ask myargu [set nextargu one-of in-discovery-neighbors with [
              not member? color [gray turquoise]
              and not group-member-here-test13 curresearcher]
            ]
            ifelse nextargu != nobody [
              move-to-nextargu nextargu
            ][
              ; if moving back is not possible, she jumps to another argument in
              ; the same tree/theory that is discovered but not fully researched
              let askstart [mytheory] of myargu
              set nextargu one-of disc-startsargum-non-red with [
                mytheory = askstart                       
                and not group-member-here-test13 curresearcher]
              if nextargu != nobody [ 
                move-to-nextargu nextargu        
              ]              
            ]
          ]
        ]
      ]
    ]
  ]
end



to compute-subj-attacked-test16
carefully [
  foreach colla-networks [ [cur-group] ->
    let calc-done false
    let calc-researcher 0
    foreach cur-group [ [cur-researcher] ->
      ; if a researcher of the group already calculated defensibility other
      ; group members can copy the results into their memory
      ifelse calc-done [
        ask cur-researcher [
          set admissible-subj-argu [admissible-subj-argu] of calc-researcher ; can be removed everywhere when transferred, doesn't have any function anymore
          set current-theory-info [current-theory-info] of calc-researcher
          set non-admiss-subj-argu [non-admiss-subj-argu] of calc-researcher
          set cur-best-th [cur-best-th] of calc-researcher
        ]
      ][
        ; if no group member has done the defensibility calculations, the
        ; current researcher does the calculations i.e. she becomes the
        ; groups calc-researcher
        set calc-done true
        set calc-researcher cur-researcher
        let sorted-starts sort starts
        ask cur-researcher [
          let #non-admiss-argu-th []
          set non-admiss-subj-argu []
          ifelse length sorted-starts = 2 [
            set non-admiss-subj-argu adm-calc-core-test16 subjective-relations
            let #non-admiss-argu-th2 count non-admiss-subj-argu with [mytheory = item 1 sorted-starts]
            let #non-admiss-argu-th1 (count non-admiss-subj-argu - #non-admiss-argu-th2)
            set #non-admiss-argu-th (list #non-admiss-argu-th1 #non-admiss-argu-th2)
           
          ][   
            foreach sorted-starts [[curtheory] ->   
              let to-add-non-admiss-argu adm-calc-core-test16 subjective-relations with [mytheory-end1 = curtheory or mytheory-end2 = curtheory]
              set #non-admiss-argu-th lput count to-add-non-admiss-argu with [mytheory = curtheory] #non-admiss-argu-th
              set non-admiss-subj-argu (turtle-set non-admiss-subj-argu to-add-non-admiss-argu)
            ]
          ]          
          set-researcher-variables-rest5 #non-admiss-argu-th
          compute-strategies-test14
        ]
      ]        
    ]
  ]
  ][show (word "compute-subj-attacked-test16 " error-message)]
end




to-report adm-calc-core-test16-2 [attackset cur-group-id theory]
  let sucattacked no-turtles
  let secondary-attackers no-links
  ask attackset [
    set processed? false
    ifelse uncontested [
      ask end2 [
        set sucattacked (turtle-set sucattacked self)
        ask my-out-attacks [
          set processed? true
          set secondary-attackers secondary-attackers with [self != myself]          
          ; if item cur-group-id in-group-i-memory 
            ; and (mytheory-end1 = theory or mytheory-end2 = theory) [
            ; set attackset attackset with [self != myself]
          ; ]
        ]
      ]
    ][
      if not processed? [
        set secondary-attackers (link-set secondary-attackers self)
      ]
    ]
  ]
  ; let prime-attackers attackset with [uncontested]
  ; if any? prime-attackers [
    ; set sucattacked (turtle-set [end2] of prime-attackers)
  ; ]
  ; let secondary-attackers attackset with [not uncontested] ;could probably be made faster by using an additional attack variable instead of member?
  let sucattacked-temp adm-calc-core-sub1 secondary-attackers cur-group-id theory sucattacked
  report sucattacked-temp
end



to-report adm-calc-core-sub1 [secondary-attackers cur-group-id theory sucattacked]
  ; let secondary-attackers attackset with [not uncontested]
  let another-loop? true
  let i 0
  while [another-loop? and any? secondary-attackers] [
    let sucattacked-cache no-turtles
    set another-loop? false
    ask secondary-attackers [
      set processed? false
      let cur-attacker self
      ask end1 [
        if not any? my-in-attacks with [item cur-group-id in-group-i-memory 
          and (mytheory-end1 = theory or mytheory-end2 = theory)][
          set another-loop? true
          ask cur-attacker [
            set sucattacked-cache (turtle-set sucattacked-cache end2)
            set secondary-attackers secondary-attackers with [self != myself] 
          ]
        ]        
      ]
    ]
    set sucattacked (turtle-set sucattacked sucattacked-cache)
    if another-loop? [
      set secondary-attackers secondary-attackers with [not member? end1 sucattacked-cache]
    ]
  set i i + 1
  ]
  every 2 [show i]
  report sucattacked
end



to share-with-other-netw-1
carefully [
  ask (turtle-set [th-args] of researchers with [rep-researcher]) [
    set group-color-mem-cache group-color-mem
  ]
  foreach share-structure [ [cur-share-groups] ->
    let comb-memory-argu no-turtles
    let comb-memory-rel no-links
    let askresearcher one-of (turtle-set first cur-share-groups) with [rep-researcher]
    let askresearcher-id [group-id] of askresearcher
    let com-costs 0
    foreach but-first cur-share-groups [[cur-other-group] -> 
      let other-researcher one-of (turtle-set cur-other-group) with [rep-researcher]     
      ask other-researcher [
        let other-researcher-id group-id        
        ask th-args with [item other-researcher-id group-color-mem < item askresearcher-id group-color-mem-cache][ 
          let other-researcher-color item other-researcher-id group-color-mem
          let askresearcher-cur-color item askresearcher-id group-color-mem-cache
          set com-costs (com-costs + (askresearcher-cur-color - other-researcher-color))
          set group-color-mem-cache replace-item askresearcher-id group-color-mem-cache other-researcher-color
          set comb-memory-argu (turtle-set comb-memory-argu self)       
        ]      
        set comb-memory-rel (link-set comb-memory-rel th-relations with [
          not item askresearcher-id in-group-i-memory])
      ]      
    ]
    set com-costs (com-costs + (count comb-memory-rel) * rel-costfactor)
    ; every 2 [show com-costs] ; for evaluluation / verification 
    ask askresearcher [
      set argu-cache comb-memory-argu
      set to-add-mem-rel comb-memory-rel
      distribute-com-costs com-costs 
    ] 
  ] 
  ][show (word "share-with-other-netw-test15" error-message)]
end

to distribute-com-costs [com-costs]
  ifelse com-costs > (3 * max-learn) [
    set communicating 4
    let com-cost-remaining (com-costs - 3 * max-learn)
    let cur-group (turtle-set item group-id colla-networks)
    ask cur-group [
      if com-cost-remaining > 0 and not [rep-researcher] of self [
        let com-payment-curresearcher min (list com-cost-remaining (4 * max-learn))
        set communicating ceiling (com-payment-curresearcher / max-learn)
        set com-cost-remaining (com-cost-remaining - com-payment-curresearcher)
      ]
    ]      
  ][
    set communicating ((ceiling (com-costs / max-learn)) + 1)
  ]
end


to share-with-other-netw-2
  let rep-researchers researchers with [rep-researcher]
  let #groups length colla-networks
  let comb-memory-argu (turtle-set [th-args] of rep-researchers)
  let comb-memory-rel (link-set [th-relations] of rep-researchers)
  let costvector n-values #groups [0]
  ask comb-memory-argu [
    let best-color min group-color-mem
    set group-color-mem-cache n-values #groups [best-color]
    let costvector-cur-argu (map - group-color-mem group-color-mem-cache)
    set costvector (map + costvector costvector-cur-argu)
  ]
  ask comb-memory-rel [
    let costvector-cur-rel map [ [group-i-rel-memory] -> 
    ifelse-value group-i-rel-memory [0][rel-costfactor]] in-group-i-memory
    set costvector (map + costvector costvector-cur-rel)
  ]
  ; every 2 [show costvector] ; for evaluluation / verification 
  ask rep-researchers [
    set argu-cache comb-memory-argu
    set to-add-mem-rel comb-memory-rel
    let com-costs item group-id costvector
    distribute-com-costs com-costs
  ]
end


to share-with-other-netw-test17
  ifelse network-structure = "complete" or (length colla-networks <= 3)
  or (length colla-networks <= 4 and network-structure != "cycle") [  
      share-with-other-netw-2
    ][
      share-with-other-netw-1
    ] 

end

; this is not optimal efficient as it has to set variables for lots of agents back and forth. On big landscapes this could become computationally expensive. In this case we should think about creating a own procedure for this or modify the existing one.
to calc-global-admiss
  let startslist sort starts
  let amat-cur-th 0
  ask attacks with [any? [my-in-attacks] of end1][
    set uncontested false    
  ]  
  foreach startslist [[curtheory] ->
    let curtheory-attacks attacks with [mytheory-end1 = curtheory or mytheory-end2 = curtheory]    
    ask curtheory [
      let non-admiss-argu adm-calc-core-test16 curtheory-attacks
      set objective-admissibility (count startsargum with [mytheory = curtheory]
        - count non-admiss-argu with [mytheory = curtheory])
    ]
  ]  
   ask attacks [
    set uncontested true    
  ]  
end



to-report adm-calc-core-test16 [attackset] 
  let prime-attackers attackset with [uncontested]
  let sucattacked (turtle-set [end2] of prime-attackers)
  let secondary-attackers attackset with [not uncontested and not member? end1 sucattacked] ;could probably be made faster by using an additional attack variable instead of member?
  let another-loop? true
  ; every 2 [show count secondary-attackers]
  while [another-loop? and any? secondary-attackers] [
    let sucattacked-cache no-turtles
    set another-loop? false
    ask secondary-attackers [
      set processed? false
      ; let cur-attacker self
      if not [any? my-in-attacks with [member? self secondary-attackers]] of end1  [
        set another-loop? true
        set sucattacked-cache (turtle-set sucattacked-cache end2)
        set processed? true
      ]     
    ]
    set sucattacked (turtle-set sucattacked sucattacked-cache)
    if another-loop? [
      set secondary-attackers secondary-attackers with [
        not processed? and not member? end1 sucattacked-cache]
    ]
  ]
  report sucattacked
end


; revisit after let fix (netlogo v6.0.1) currently quite a bit slower than the normal v16 version
to-report adm-calc-core-beta [attackset]
  let sucattacked no-turtles
  let secondary-attackers no-links
  ask attackset [
    set processed? false
    ifelse uncontested [
      set sucattacked (turtle-set sucattacked end2)
      ask [my-out-attacks] of end2 [set processed? true]
    ][
      if not processed? [
        set secondary-attackers (link-set secondary-attackers self)
      ]
    ]
  ]
  set secondary-attackers secondary-attackers with [not processed?]
  let another-loop? true
  ; every 2 [show count secondary-attackers]
  while [another-loop? and any? secondary-attackers] [
    let sucattacked-cache no-turtles
    set another-loop? false
    ask secondary-attackers [
      set processed? false
      ; let cur-attacker self
      if not [any? my-in-attacks with [member? self secondary-attackers]] of end1  [
        set another-loop? true
        set sucattacked-cache (turtle-set sucattacked-cache end2)
        set processed? true
      ]     
    ]
    set sucattacked (turtle-set sucattacked sucattacked-cache)
    if another-loop? [
      set secondary-attackers secondary-attackers with [
        not processed? and not member? end1 sucattacked-cache]
    ]
  ]
  report sucattacked
end