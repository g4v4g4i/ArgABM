extensions [matrix]

researchers-own [theory-jump times-jumped collaborator-network
  subjective-arguments subjective-relations current-theory-info cur-best-th
  admissible-subj-argu th-args th-relations communicating neighborargs moved
  rep-researcher to-add-mem-argu to-add-mem-rel lastalist lastblist
	lastalistafter flag-updated-memory conference-attended non-admiss-subj-argu subj-argu-as mygps]

to-report adm-calc-core [amat]
  let replacevec [-1 -1]
  ; let sucattacks [] ; maybe this variable is not even needed, left in for debugging purposes currently
  ; let sucattacker [] ; not really needed, just here for debugging purposes
  let sucattacked []
  let amatlist matrix:to-column-list amat
  let alist item 0 amatlist
  let blist item 1 amatlist
  let any-del-in-alist? true
  while [any-del-in-alist? and amat != false] [
    ; let amatlist matrix:to-column-list amat
    ; let alist item 0 amatlist
    ; let blist item 1 amatlist
    ; ; let alist matrix:get-column amat 0
    ; let blist matrix:get-column amat 1
    let sucattacked-tmp []
    let i 0
    foreach alist [ [curitem] ->
      if curitem != -1 and not member? curitem blist [
        ; let currow matrix:get-row amat i
        ; set sucattacks lput currow sucattacks ; probably not needed, currently left for debugging
        ; set sucattacked-tmp lput item 1 currow sucattacked-tmp
        set sucattacked-tmp lput matrix:get amat i 1 sucattacked-tmp
        ; set sucattacker lput item 0 currow sucattacker ; not really needed, just here for debugging purposes
        matrix:set-row amat i replacevec    
      ]
      set i i + 1
    ]
    
    set any-del-in-alist? false
    if not empty? sucattacked-tmp [
      set alist matrix:get-column amat 0
      set i 0
      foreach alist [[curitem] ->
        if curitem != -1 and member? curitem sucattacked-tmp [
          matrix:set-row amat i replacevec
          set any-del-in-alist? true
        ]
        set i i + 1
      ]      
    ]
    set sucattacked sentence sucattacked sucattacked-tmp
    if any-del-in-alist? [
      let cleaned-entries amat-cleaner amat
      ifelse cleaned-entries != false [
        set alist item 0 cleaned-entries
        set blist item 1 cleaned-entries
        set amat item 2 cleaned-entries        
      ][
        set amat false
      ]
    ]
  ]
  report sucattacked 
end

to-report amat-cleaner [amat]
  let amatlist matrix:to-column-list amat
  let alist filter [[curargu] -> curargu != -1 ] item 0 amatlist
  let blist filter [[curargu] -> curargu != -1 ] item 1 amatlist
  ifelse not empty? alist [
    report (list alist blist matrix:from-column-list (list alist blist))
  ][
    report false
  ]

end

to-report provide-testmat1
  let amatlist (list (list 0 0 0 1 2 5 7 6) (list 3 4 6 5 3 0 0 2))
  let amat matrix:from-column-list amatlist
  report amat
end

to test-amat-base
  let amat provide-testmat1
  print amat
  show adm-calc-core amat
end

to-report attack-set-to-matrix [vis] ; vis for visibility
  let dim-amat count attacks with [runresult vis]
  let amat matrix:make-constant dim-amat 2 0
  let i 0
  ask attacks with [runresult vis] [
    matrix:set-row amat i (list [who] of end1 [who] of end2 )
    set i i + 1
  ]
  report amat
end



to test-amat-real
  let amat attack-set-to-matrix [ [] -> true ]
  show length adm-calc-core amat
end

to calc-admiss-new [vis]
  let amat attack-set-to-matrix vis
  set ctiho2 length (adm-calc-core amat)
end

to profile-cadmis-compare-old-with-new [repetitions input number]
  ca
  set rndseed []
  set ctiho-diff []
  set ctiho-new []
  set ctiho-old []
  let vis 0
  ifelse input = red [
		set vis [ [] -> color != gray ]
	][
		set vis [ [] -> true ]
	]
  profilecore repetitions [ [] ->
    setuprs-auto
    if input = red [
      simulate-exploration number
    ]    
    repeat 10 [
    calc-global-admiss-core vis
    let number-non-adm-old count startsargum with [runresult vis] - item 1 item 1 ctiho - item 1 item 0 ctiho
    set ctiho-old lput number-non-adm-old ctiho-old
    calc-admiss-new vis
    set ctiho-new lput ctiho2 ctiho-new
    set ctiho-diff lput ( number-non-adm-old - ctiho2) ctiho-diff
    ]
  ]
  
end

to simulate-exploration [number]
  ask n-of number attacks [
    set color red
    ask both-ends [set color red]
  ]
end

; this procedure is currently only designed to work for landscapes with two theories
to-report researcher-attack-mem-to-amat
  let attack-relations filter [[currelation] -> first currelation = "a" ] subjective-relations
  ; let attack-relations []
  ; foreach subjective-relations [[currelation] -> 
    ; if first currelation = "a" [
      ; ; let cur-attack but-first currelation
      ; set attack-relations lput (map [[curargu] -> [who] of curargu ] but-first currelation) attack-relations
    ; ]
  ; ]
  ifelse length current-theory-info = 2 [
    let amat matrix:make-constant length attack-relations 2 -1
    let i 0
    foreach attack-relations [ [currelation] ->
      matrix:set-row amat i (list [who] of item 1 currelation [who] of item 2 currelation )
      ; matrix:set-row amat i map [[curargu] -> [who] of curargu ] but-first currelation ; slower (2x) than the above solution!
      set i i + 1
    ]
    report amat
    ; ifelse not empty? attack-relations [
      ; report matrix:from-row-list attack-relations
    ; ][
      ; report matrix:from-row-list [[-1 -1]]
     ; ]
  ][
    set current-theory-info sort-by [ [?1 ?2] -> item 0 ?1 < item 0 ?2 ] current-theory-info
    ; let th1 item 0 item 0 sorted-cur-th-info
    ; let th2 item 0 item 1 sorted-cur-th-info
    ; let th3 item 0 item 2 sorted-cur-th-info
    let th-amats []
    foreach current-theory-info [[curentry] ->
      let curtheory item 0 curentry
      let curtheory-attacks filter [[currelation] -> 
        [mytheory] of item 1 currelation = curtheory 
        or [mytheory] of item 2 currelation = curtheory] attack-relations 
      let amat-cur-th matrix:make-constant length curtheory-attacks 2 -1
      let i 0
      foreach curtheory-attacks [ [currelation] ->
        matrix:set-row amat-cur-th i (list [who] of item 1 currelation [who] of item 2 currelation )       
        set i i + 1       
      ]
      set th-amats lput amat-cur-th th-amats
    ]
    report th-amats
    ; let th1-amat matrix:make-constant length attack-relations 2 -1
    ; ; let th1-out matrix:copy th1-in
    ; let th2-amat matrix:copy th1-amat
    ; ; let th2-out matrix:copy th1-in
    ; let th3-amat matrix:copy th1-amat
    ; ; let th3-out matrix:copy th1-in
    ; let th1-count 0
    ; let th2-count 0
    ; let th3-count 0    
    ; let to-input-attack-ap [[currelation] ->
      ; (list [who] of item 1 currelation [who] of item 2 currelation )
    ; ]
    
    ; let to-input-th1 [ [to-input-attack] -> 
      ; matrix:set-row th1-amat th1-count to-input-attack
      ; set th1-count th1-count + 1
      ; ]
    ; let to-input-th2 [ [to-input-attack] -> 
      ; matrix:set-row th2-amat th2-count to-input-attack
      ; set th2-count th2-count + 1
      ; ]
    ; let to-input-th3 [ [to-input-attack] -> 
      ; matrix:set-row th3-amat th3-count to-input-attack
      ; set th3-count th3-count + 1
      ; ]
      
    ; foreach attack-relations [ [currelation] ->
      ; if [mytheory] of item 1 currelation = th1 and  [mytheory] of item 2 currelation = th2 [
        ; let to-input-attack (runresult to-input-attack-ap currelation)
        ; (run to-input-th1 to-input-attack)
        ; (run to-input-th2 to-input-attack)        
      ; ]
      ; if [mytheory] of item 1 currelation = th1 and  [mytheory] of item 2 currelation = th3 [
        ; let to-input-attack (runresult to-input-attack-ap currelation)
        ; (run to-input-th1 to-input-attack)
        ; (run to-input-th3 to-input-attack)       
      ; ]
    ; ]
  ]
end

to compute-subj-attacked-test11
  	foreach colla-networks [ [?1] ->
      let calc-done false
      let calc-researcher []
      let cur-group ?1
      foreach cur-group [ [??1] ->
        let cur-researcher ??1
        if not [rep-researcher] of cur-researcher [
          ; if a researcher of the group already calculated defensibility other
          ; group members can copy the results into their memory
          ifelse calc-done [
            ask cur-researcher [
              set admissible-subj-argu [admissible-subj-argu] of calc-researcher
              set current-theory-info [current-theory-info] of calc-researcher
              set non-admiss-subj-argu [non-admiss-subj-argu] of calc-researcher
            ]
          ][
            ; if no group member has done the defensibility calculations, the
            ; current researcher does the calculations i.e. she becomes the
            ; groups calc-researcher
            set calc-done true
            set calc-researcher cur-researcher
            ask cur-researcher [
              let amat researcher-attack-mem-to-amat
              let not-admissible-whos 0
              ifelse length current-theory-info = 2 [
                set not-admissible-whos adm-calc-core amat
              ][
                let i 0
                foreach current-theory-info [[curentry] ->
                  let cur-th-amat item i amat
                  set not-admissible-whos sentence not-admissible-whos adm-calc-core cur-th-amat
                  set i i + 1
                ]
              ]
              set non-admiss-subj-argu turtle-set map turtle not-admissible-whos
              set-researcher-variables-rest4
              ; set admissible-subj-argu filter [[curargu] -> 
                ; not member? item 0 curargu non-admiss-subj-argu] subjective-arguments
              ; ; show admissible-subj-argu
              ; ; let number-adm-argu [[curtheory adm-subj-argu] -> 
                ; ; length filter [[] -> [mytheory] of item 0 item 0 adm-subj-argu = item 0 curtheory ] adm-subj-argu
              ; ; ]
              ; let cur-th-info-cache []
              ; foreach current-theory-info [ [curtheory ] ->              
                ; set cur-th-info-cache lput (list item 0 curtheory length filter [[curitem] -> [mytheory] of item 0 curitem = item 0 curtheory ] admissible-subj-argu) cur-th-info-cache             
              ; ]
              ; set current-theory-info cur-th-info-cache
            ]
          ]
        ]
      ]
    ]
end


; strangely this variable setting cost massive amounts of time, maybe this is related to the "let bug" ?
; currently this alone costs as much time as the adm-calc + the transformation of the attacks to matrix
; strangely this part of the code was also not recognized by the profiler as part of the exclusive time
; of compute-subj-attacked-test11 before I separated it
to set-researcher-variables-rest
  set-res-var-rest-sub1
  ; let cur-th-info-cache []
  let i 0
  foreach current-theory-info [ [curtheory ] ->              
    set current-theory-info replace-subitem i 1 current-theory-info length filter [[curitem] -> 
      [mytheory] of item 0 curitem = item 0 curtheory ] admissible-subj-argu          
    set i i + 1
  ]
  ; set current-theory-info cur-th-info-cache
end

to set-researcher-variables-rest2
  let subj-argu-wo-color []
  set-res-var-rest-sub1
  foreach subjective-arguments [[curargu] ->
    set subj-argu-wo-color lput item 0 curargu subj-argu-wo-color
  ]
  let non-admiss non-admiss-subj-argu
  let subj-argu-wo-color-as turtle-set subj-argu-wo-color
  let cur-th-info-cache []
  foreach current-theory-info [ [curtheory ] -> 
    let curstart item 0 curtheory
    set cur-th-info-cache lput (list curstart 
    count subj-argu-wo-color-as with [mytheory = curstart 
      and not member? self non-admiss]) cur-th-info-cache       
  ]
  set current-theory-info cur-th-info-cache
end

to set-res-var-rest-sub1
  set admissible-subj-argu filter [[curargu] -> 
    not member? item 0 curargu non-admiss-subj-argu] subjective-arguments
end

to set-researcher-variables-rest3
  set-res-var-rest-sub1
  let subj-argu-wo-color turtle-set map [[curargu] -> item 0 curargu] subjective-arguments
  ; let number-adm-argu [[curtheory subj-argu non-adm-argu] -> ]
  let non-admiss-subj-argu-cache non-admiss-subj-argu
  let i 0
  foreach current-theory-info [[curitem] ->
    let curtheory item 0 curitem
    let number-adm-argu count subj-argu-wo-color with [mytheory = curtheory and not member? self non-admiss-subj-argu-cache]
    set current-theory-info replace-subitem i 1 current-theory-info number-adm-argu
    set i i + 1
  ]
end

to-report replace-subitem [index1 index2 lists value]
  let old-sublist item index1 lists
  report replace-item index1 lists (replace-item index2 old-sublist value)
end

to set-researcher-variables-rest4
 set admissible-subj-argu 0
 ; let subj-argu-wo-color turtle-set map [[curargu] -> item 0 curargu] subjective-arguments
  let non-admiss-subj-argu-cache non-admiss-subj-argu
  let i 0
  foreach current-theory-info [[curitem] ->
    let curtheory item 0 curitem
    let number-adm-argu count subj-argu-as with [mytheory = curtheory and not member? self non-admiss-subj-argu-cache]
    set current-theory-info replace-subitem i 1 current-theory-info number-adm-argu
    set i i + 1
  ]
end


to-report arg-list-dupl-remover-test [alist]
	set alist remove-duplicates alist
	let widearglist convert-argl-long-to-wide-test alist
	set alist convert-argl-wide-to-long-test widearglist
	report alist
end


to-report convert-argl-long-to-wide-test [longarglist]
	let redargs []
	let orangeargs []
	let brownargs []
	let yellowargs []
	let greenargs []
	let limeargs []
	let turquoiseargs []
	let argulist []
	foreach longarglist	[ [colorarg] ->
		let curargu item 0 colorarg
		let curcolor item 1 colorarg
		set argulist lput curargu argulist
		if curcolor = 15 [
			set redargs lput curargu redargs
		]
		if curcolor = 25 [
			set orangeargs lput curargu orangeargs
		]
		if curcolor = 35 [
			set brownargs lput curargu brownargs
		]
		if curcolor = 45 [
			set yellowargs lput curargu yellowargs
		]
		if curcolor = 55 [
			set greenargs lput curargu greenargs
		]
		if curcolor = 65 [
			set limeargs lput curargu limeargs
		]
		if curcolor = 75 [
			set turquoiseargs lput curargu turquoiseargs
		]
	]
	set argulist remove-duplicates argulist
  set subj-argu-as turtle-set argulist
	let widearglist (list redargs orangeargs brownargs yellowargs greenargs limeargs turquoiseargs argulist)
	report widearglist
end


to-report convert-argl-wide-to-long-test [widearglist]
	let redargs item 0 widearglist
	let orangeargs item 1 widearglist
	let brownargs item 2 widearglist
	let yellowargs item 3 widearglist
	let greenargs item 4 widearglist
	let limeargs item 5 widearglist
	let turquoiseargs item 6 widearglist
	let argulist item 7 widearglist
	let longarglist []
	foreach argulist
	[ [argu] ->
		ifelse member? argu redargs [
			set longarglist lput list argu 15 longarglist
		][
			ifelse member? argu orangeargs [
				set longarglist lput list argu 25 longarglist
			][
				ifelse member? argu orangeargs [
					set longarglist lput list argu 35 longarglist
				][
					ifelse member? argu orangeargs [
						set longarglist lput list argu 45 longarglist
					][
						ifelse member? argu orangeargs [
							set longarglist lput list argu 55 longarglist
						][
							ifelse member? argu orangeargs [
								set longarglist lput list argu 65 longarglist
							][
								set longarglist lput list argu 75 longarglist
							]
						]
					]
				]
			]
		]
	]	
	report longarglist
end




; procedure in which researchers share their memory with other researchers
; from their collaborator-network (=group)
to share-with-others-test11
	foreach colla-networks [ [?1] ->
		let group-sharing-done false
		let grp-share-researcher []
		let cur-group ?1
		foreach cur-group [ [??1] ->
			let cur-researcher ??1
			ifelse group-sharing-done [
				ask cur-researcher [
					set rep-researcher false
					set subjective-arguments [subjective-arguments] of
					grp-share-researcher
					set subjective-relations [subjective-relations] of
					grp-share-researcher
          set subj-argu-as [subj-argu-as] of grp-share-researcher
				]
			][
				set group-sharing-done true
				set grp-share-researcher cur-researcher
				ask cur-researcher [
					; reset the variables
					set rep-researcher false
					set to-add-mem-argu []
					set to-add-mem-rel []

					; variables to keep track of the current researchers own memory
					; and the combined memory of all the sharing researchers
					; let own-memory-argu subjective-arguments
					; let own-memory-rel subjective-relations
					let comb-memory-argu []
					let comb-memory-rel []
					; collaborator network of the current researcher
					let cur-network collaborator-network

					; the information in the memories of the single researchers in
					; the network are combined
					foreach cur-group [ [???1] ->
						let input-researcher ???1
						set comb-memory-argu remove-duplicates sentence
							comb-memory-argu [subjective-arguments] of input-researcher 
						set comb-memory-rel remove-duplicates sentence 
							comb-memory-rel [subjective-relations] of	input-researcher 
					]
					; the group-share-researcher adds the combined memory to its own
					set subjective-arguments (arg-list-dupl-remover-test comb-memory-argu)
					set subjective-relations comb-memory-rel
				]
			]
		]
	]
end



to move-around-test11
  ; variable to make sure that the procedure find-defense
  ; is only run once
  let run-find-defense false
  ; at the beginning of the procedure no researcher has moved yet
  ask researchers [
    set moved false
  ]
  ask researchers [
    let curresearcher self
    if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
			let myargu gps     
      ; the researcher owned variable which contains all the non defensible
			; arguments as a list is written to not-admissible
      let not-admissible non-admiss-subj-argu
			
      ; an researcher working on a non defensible argument will try to find a
			; defense for this attack, by working further on the attacked argument,
			; unless she discoveres a child-argument that that has a defense for
			; the attack (it is not necessarily the case that this defense is
			; already discovered) or until she has fully researched the argument
      ; the find-defense runs immediately for all researchers working on 
			; a not fully researched non defensible argument,
			; hence it is only once executed
      if member? myargu not-admissible and not moved [

        if not run-find-defense [
          find-defense
          set run-find-defense true
        ]
      ]

      if not moved and (not member? myargu not-admissible or
        (member? myargu not-admissible and [color] of myargu = red))[

        ; when an argument exists that:
        ; a) is a child-argument of the current argument;
        ; b) is not gray, red or turquoise; and
        ; c) no researcher from the same collaborator-network is working on it
        ; the researcher moves there, with certain probability
        let nextargu 0
        ask myargu [set nextargu out-discovery-neighbors with [[not member? color [gray red turquoise]] of self
					and not group-member-here curresearcher]]
        ifelse any? nextargu [
					let move-random random-float 1.0


					; every time step with small-movement of the move-probability
					; the researcher moves
					ifelse move-random < (small-movement * move-probability *
						(1 - (color / color-move))) [
            set mygps one-of nextargu
						move-to mygps            
						set moved true
					][

						; every 5th time step the researcher mover with the full
						; move-probability, that depends a bit on the color
						if ticks != 0 and ticks mod 5 = 0 and move-random <
							move-probability * (1 - (color / color-move)) [
              set mygps one-of nextargu
              move-to mygps            
              set moved true
						]
					]
				][

					; if there is no next argument and the current argument is
					; fully researched, the researcher moves a step back
          ask myargu [set nextargu in-discovery-neighbors with [
						[not member? color [gray turquoise]] of self
						and not group-member-here curresearcher]]
					ifelse [color] of myargu = red and any? nextargu [
						set mygps one-of nextargu
						move-to mygps    
						set moved true
					][

						; if moving back is not possible, she jumps to another argument in
						; the same tree/theory that is discovered but not fully researched
						if [color] of myargu = red [
							let askstart [mytheory] of myargu
              set nextargu startsargum with [
								[not member? color [gray red turquoise]] of self
								and mytheory = askstart 
								and not group-member-here curresearcher]
              if any? nextargu [ 
                set mygps one-of nextargu
                move-to mygps 
                set moved true              
              ]
            ]
					]
				]
      ]
    ]
  ]
end





; researchers working on a not fully researched non defensible argument will
; try to find a defense for that attack, by staying on the current argument
; if a child-argument is discovered that can potentially provide a defense
; (it is not necessarily the case that this defense is already discovered),
; the researcher moves there
; once an argument is fully researched all its relations are discovered,
; so the researcher can move on and can try to find a defense in another
; branch further away
to find-defense-test11
  ask researchers with [not moved][
    let curresearcher self
		if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
			let myargu gps
			; lists of arguments that are not admissible
			let not-admissible non-admiss-subj-argu
			
			; if the current argument is not fully researched and not admissible
			; and it is a 5th time step or the researcher is not communicating
			; the researcher tries to move prospectively to a child-argument of the
			; current argument that provides a defense for the current argument
			if member? myargu not-admissible [
				ask myargu [
					ask my-in-attacks [
						; check to prevent the researcher from searching for further
						; defender-childs (nextargu) when she already has moved to one
						if not [moved] of curresearcher [
							ask end1 [
							; create a set of arguments that provide a defense for the 
							; current argument, these:
							; a) attack the attacker of the current argument;
							; b) are a child-argument of the current argument;
							; c) are discovered; and
							; d) no researcher from the same group is working on it
								let nextargu in-attack-neighbors with [in-discovery-neighbor?
									myargu
									and	[not member? color [gray red turquoise]] of self
									and not group-member-here curresearcher]
								; if such an argument exists the researcher moves there
								; and cannot move anymore this time step
								if any? nextargu [
									ask curresearcher [
                    set mygps one-of nextargu
										move-to mygps
										set moved true
									]
								]
							]
						]
					]
				]
			]
		]			
  ]
end

to act-on-strategies-test11
  ask researchers with [not rep-researcher][
    ; only when there is a current best theory
    ; it makes sense for the researchers to want to work on that theory
    if not empty? cur-best-th and not member? nobody cur-best-th [
			let myargu gps
      ; let myx xcor
      ; let myy ycor

      ; if the researcher is not currently working on the best theory
      ; it considers jumping
      foreach subjective-arguments [ [?1] ->
				let cur-subj-argu item 0 ?1
				if cur-subj-argu = myargu and not member? [mytheory] of cur-subj-argu
				cur-best-th [
          set theory-jump theory-jump + 1
				]        
      ]

      ; if the researcher has considered jumping jump-threshold times
      ; it jumps to one of the theories it considers best, based
      ; on its memory and the computations
      if theory-jump >= jump-threshold [
        let ch-best one-of cur-best-th
        let subj-argus []
        ; foreach subjective-arguments [ [?1] ->
          ; set subj-argus lput item 0 ?1 subj-argus
        ; ]

        ; if one of the arguments from the best theory is in its memory
        ; the researcher will jump there
        let nextargu subj-argu-as with [
          mytheory = ch-best 
					and color != turquoise]
        ifelse any? nextargu [
          set mygps one-of nextargu
          move-to mygps
        ][ ; otherwise the researcher jumps to the root of the theory
          set mygps ch-best
          move-to mygps
          ]

        set times-jumped times-jumped + 1
        set theory-jump 0
      ]
    ]
  ]
end

