
; the setup procedures for
; 1. the hidden variables (not set in the interface)
; 2. building the argumentative landscape with
;    attacks and discovery relations
; 3. populate the landscape with researchers


; the core-setup procedure:
; the hidden variables (not set in the interface)
; it creates a landscape of arguments and a discovery relation
; on this landscape; attacks are defined;
; the researchers are distributed over the theories
to setupcore-old [clearing numberoftheories theorydepth scientistsno]
  run clearing
  initialize-hidden-variables-old
  create-discovery-landscape-old numberoftheories theorydepth
  define-attack-relation-old
  distribute-researchers-old scientistsno
  reset-ticks
	ask researchers [
		set lastalist []
		set lastblist []
		set lastalistafter []
	]
end

; the setup for a normal run
to setup-old
	setupcore-old [ [] -> clear-all ] number-of-theories theory-depth scientists
end


; procedure in which the variables that are not mentioned
; in the interface can be set
to initialize-hidden-variables-old
  ; the number of arguments that an researcher can learn
  ; each tick
  set max-learn 10

  ; the probability that researchers move every round is
  ; only small-movement * move-probability
  set small-movement 0.2

  ; influence color on move probability
  set color-move 200
end





; a landscape of arguments and a discovery relation
; on these arguments is defined
to create-discovery-landscape-old [numberoftheories theorydepth]
  ; at the start arguments and starts are a circle
  set-default-shape arguments "circle"
  set-default-shape starts "circle"

  repeat numberoftheories [ ; trees are created theory for theory
    create-starts 1 [
      ; variables for color, the theory it belongs to
      ; and whether it just turned red are initialized
      set color lime
      set current-start true
      set mytheory self
      set full-research false
    ]
    let i 0
    while [i < theorydepth] [
      create-arguments ( 4 ^ (theorydepth - i))[
        ; variables for color, the theory it belongs to
        ; and whether it just turned red are initialized
        set color gray
        set current-argument true
        set mytheory one-of starts with [current-start]
        set full-research false
      ]
      set i i + 1
    ]

    ; with the created turtles (arguments and roots)
    ; trees are build, one for each start/root
    create-discovery-trees-old

    ask starts [ ; to make sure that all theories are visible
      create-starters-with other starts [set color black]
      set current-start false
    ]
    ask arguments [set current-argument false]
  ]
  ; set the shape of the arguments of the best theory different from a circle
  ask turtles with [(breed = starts or breed = arguments) and
    mytheory = start 0 ][
    set shape "triangle"
  ]
end





; create the theory discovery trees
; each node has 0 or 4 child-arguments
; starting from the starts as root
to create-discovery-trees-old
  ; first level with starts as roots
  ask starts with [count out-discovery-neighbors = 0 and current-start][
    repeat 4 [
      if any? arguments with [count in-discovery-neighbors = 0 and
        current-argument] [
        create-discovery-to one-of arguments with [
          count in-discovery-neighbors = 0 and current-argument]
      ]
    ]
  ]
  ; then adding all the normal arguments
  while [any? arguments with [count in-discovery-neighbors = 0 and
    current-argument]][
    ask arguments with [count in-discovery-neighbors = 1 and
      count out-discovery-neighbors < 4 and current-argument][
      let curarg self
      repeat (4 - count out-discovery-neighbors) [
        if any? other arguments with [count in-discovery-neighbors = 0 and
          current-argument and not out-discovery-neighbor? curarg][
          create-discovery-to one-of other arguments with
	        [count in-discovery-neighbors = 0 and current-argument]
          ]
      ]
    ]
  ]
end





; on the created landscape an attack relation is defined
; attacks occur only between theories
; the probability that an argument is attacked by another argument
; depends on the attack-probability for the theory the attacked
; argument belongs to, as can be set in the interface
; one theory, the objective best, defends all its arguments
to define-attack-relation-old
  ; first the random attacks are defined
  define-attack-relation-create-attacks-old

  ; then the best theory defends itself
  define-attack-relation-defend-best-old

  ; the arguments and relations are spread over the patches
  define-attack-relation-visualize-old
end





; this procedure creates the random attacks from one theory to another
to define-attack-relation-create-attacks-old
  ask turtles with [breed = starts or breed = arguments][
    ; variables for the current argument, the theory it belongs to,
    ; a random number between 0.00 and 1.00 and a list of theories
    let askargu self
    let curtheory mytheory
    let attack-random random-float 1.00
    let starts-list []
    ask starts [
      set starts-list lput who starts-list
    ]
    set starts-list sort starts-list

    ; with attack-probability-2nd from the interface an attack towards
    ; the current argument is created
    ifelse number-of-theories = 2[
      if attack-random < attack-probability-2nd and curtheory != start 0 [
        create-attack-from one-of other turtles with [(breed = starts or
	      breed = arguments)and mytheory != curtheory and not
	      (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
	      out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        set color gray
            ]
      ]
    ][

    ; when there are three theories both attack-probability-2nd and -3rd are
    ; considered to create attacks, depending on the theory the current argument
    ; belongs to first for the third theory
    ifelse [who] of curtheory = max starts-list and attack-random <
      attack-probability-3rd [
      create-attack-from one-of other turtles with [(breed = starts or
        breed = arguments) and mytheory != curtheory and not
	      (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
	      out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        set color gray
          ]
    ][
    ; then attacks towards arguments of the 2nd theory are created
    if [who] of curtheory != max starts-list and curtheory != start 0 and
      attack-random < attack-probability-2nd [
      create-attack-from one-of other turtles with [(breed = starts or
      breed = arguments) and mytheory != curtheory and not
      (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
	    out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        set color gray
          ]
    ]
    ]
    ]

    ; if the current argument belongs to the objective best theory
    ; an attack towards this argument is created with attack-probability-best
    if attack-random < attack-probability-best and curtheory = start 0 [
      create-attack-from one-of other turtles with [(breed = starts or
      breed = arguments) and mytheory != curtheory and not
	    (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
	    out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        set color gray
          ]
    ]
  ]
end





; after the random attacks are created, attacks coming from the best theory
; are added such that it defends itself completely
to define-attack-relation-defend-best-old
  ask turtles with [(breed = starts or breed = arguments) and
    mytheory = start 0][
    ; variable for the current argument
    let askargu self

    if any? in-attack-neighbors [
      ask in-attack-neighbors [
        ; variable for the attacking argument, if such an argument exists
        let askattack self
        ; a defending attack is only created if there is not yet an attack
        ; from an argument of the best theory towards the attacking argument
        if not any? in-attack-neighbors with [mytheory = start 0][
          create-attack-from one-of turtles with [(breed = starts or
	        breed = arguments) and mytheory = start 0 and not
	        (in-discovery-neighbor? askattack or in-attack-neighbor?
	        askattack or out-discovery-neighbor? askattack or
	        out-attack-neighbor? askattack) and not (self = askargu)][
            set color gray
          ]
        ]
      ]
    ]
  ]
end





; creates the visible tree, centered around
; the root of the best theory
to define-attack-relation-visualize-old
  layout-radial
  turtles with [breed = arguments or breed = starts]
  links with [breed = discoveries or breed = starters]
  start 0
end





; in this procedure the researchers are created,
; including their memory and the social netoworks
; and they are distributed randomly over the theories
to distribute-researchers-old [scientistsno]
  set-default-shape researchers "person"

  ; the right number of researchers is created
  ; and the researcher variables are initialized
  researchers-create-scientists scientistsno

  ; create the network of collaborators
  ; if in the interface "within-theory" is on, collaborative networks are created
  ; among researchers that start from the same theory
  ; a network has at most 5 researchers in it
  ifelse within-theory [
    distribute-researchers-within-theory-on-old
  ][
  ; if "within-theory" is off in the interface, random collaborative networks
  ; are created, all of size 5
  distribute-researchers-within-theory-off-old
  ]

  ; the memory of the researchers is created
  researchers-create-memory-old

  ; the networks in which researchers share with other groups is created
  create-networks-old
end





; create researchers and initialize their variables
to researchers-create-scientists-old [scientistsno]
  create-researchers scientistsno [
    ; the researchers are blue-colored
    ; and start on one of the roots
    set color blue
    move-to one-of starts

    ; the researcher-own variables are initialized
    set collaborator-network []
    set subjective-relations []
    set subjective-arguments []
    set times-jumped 0
    set communicating 0
    set moved false
    set rep-researcher false

    ; an researcher is always aware of all the theories
    ; the information the researcher has about a theory
    ; is collected in current-theory-info which has
    ; the form [[(start 0) no. adm args] ...]
    let theories []
    ask starts [
      let start-add []
      set start-add lput self start-add
      set start-add lput 0 start-add
      set theories lput start-add theories
    ]
    set current-theory-info theories
  ]
end





; create the memory of the researcher
; keep track of the theories and arguments that the researcher has visited
; an argument memory entry has two elements: the argument and its color:
; [[(argument a) colora] ... [(argument i) colori] ...]
to researchers-create-memory-old
  ask researchers [
    ; variables for the x and y coordinate and the theory of
    ; the current researcher
    let myx xcor
    let myy ycor
    let cur-theory one-of starts with [xcor = myx and ycor = myy]

    ; the current theory is added to the subjective-arguments list:
    ; [[(start x) lime]]
    let add-cur []
    set add-cur lput cur-theory add-cur
    set add-cur lput [color] of cur-theory add-cur
    set subjective-arguments lput add-cur subjective-arguments
  ]
end





; if in the interface "within-theory" is on, collaborative networks are created
; among researchers that start from the same theory
; a network has at most 5 researchers in it
to distribute-researchers-within-theory-on-old
  ask starts [
    ; variables for the x and y coordinates of the root
    ; and an empty list for the created network
    let myx xcor
    let myy ycor
    let cur-col []

    ; while there are more than five researchers on the root without a network
    ; networks of exactly five researchers are created
    if any? researchers with [xcor = myx and ycor = myy and
      empty? collaborator-network][
      while [count researchers with [xcor = myx and ycor = myy and
        empty? collaborator-network] > 5][
        ; five researchers are added to the list cur-col
        ; which is then set as the collaborator-network of each of these researchers
        ask n-of 5 researchers with [xcor = myx and ycor = myy and
	        empty? collaborator-network] [
          set cur-col lput self cur-col
        ]
        ask researchers with [member? self cur-col][
          set collaborator-network cur-col
        ]
        set cur-col []
      ]
      ; once there are five or less researchers without a network
      ; they form a network together
      ask researchers with [xcor = myx and ycor = myy and
        empty? collaborator-network] [
        set cur-col lput self cur-col
      ]
      ask researchers with [member? self cur-col][
        set collaborator-network cur-col
      ]
    ]
  ]
end





; if "within-theory" is off in the interface random collaborative networks
; are created, all of size 5
to distribute-researchers-within-theory-off-old
  while [any? researchers with [empty? collaborator-network]][
    ; variable that collects exactly five researchers for a network
    let cur-col []
    ask n-of 5 researchers with [empty? collaborator-network][
      set cur-col lput self cur-col
    ]
    ask researchers with [member? self cur-col][
      set collaborator-network cur-col
    ]
  ]
end





; computations for the Popularity plot
; it computes for every theory the number of
; researchers working on it
to compute-popularity-old
  ; initialize the variable at 0
  ask starts [ set myscientists 0 ]

  ask researchers [
    ; variables for x and y coordinate of the current researcher,
    ; the argument it is currently working on and the
    ; theory this argument belongs to
    let myx xcor
    let myy ycor
    let myargu one-of turtles with [(breed = starts or breed = arguments) and
      xcor = myx and ycor = myy]
    let mystart [mytheory] of myargu

    ; the myscientists variable of the theory the researcher
    ; is working on is increased by one
    ask mystart [
      set myscientists myscientists + 1
    ]
  ]
end




; the social network structures for collaborator networks
; is created according to the choice made in the interface:
; cycle, wheel or complete
to create-networks-old
  ; initialize variables for the collection of the networks
  ; and the networks that will share with each other
  set colla-networks []
  ; an entry in share-structure starts with the network that
  ; is the network that initializes the sharing
  set share-structure []

  ; list of all sorted collaborator-networks
  let networks []
  ask researchers [
    set networks lput sort collaborator-network networks
  ]
  set colla-networks remove-duplicates networks

  ; in the case that the choice in the interface is cycle
  ifelse network-structure = "cycle" [
    let connect-networks colla-networks

    ; when there are only two collaborator-networks
    ; they always share with each other
    ifelse length colla-networks = 2 [
      set share-structure lput colla-networks share-structure
      set share-structure lput reverse colla-networks share-structure
    ][

    ; in all other cases networks share with two neighboring networks
    ; for three networks this is still a complete case
    while [length connect-networks > 2] [
      ; first the entries for the beginning and end of the list
      ifelse empty? share-structure[
        let to-add-structure1 []
        let to-add-structure2 []
        set to-add-structure1 lput first connect-networks to-add-structure1
        set to-add-structure1 lput first but-first connect-networks to-add-structure1
        set to-add-structure1 lput last connect-networks to-add-structure1
        set to-add-structure2 lput last connect-networks to-add-structure2
        set to-add-structure2 lput first connect-networks to-add-structure2
        set to-add-structure2 lput last but-last connect-networks to-add-structure2
        set share-structure lput to-add-structure1 share-structure
        set share-structure lput to-add-structure2 share-structure
      ][
      ; then the networks in between
      let to-add-structure []
      set to-add-structure lput first but-first connect-networks to-add-structure
      set to-add-structure lput first connect-networks to-add-structure
      set connect-networks remove-item 0 connect-networks
      set to-add-structure lput first but-first connect-networks to-add-structure
      set share-structure lput to-add-structure share-structure
      ]
    ]
    ]
  ][

  ; in the case that the choice in the interface is wheel
  ifelse network-structure = "wheel" [
    let connect-networks colla-networks

    ; when there are only two or three collaborator-networks
    ; they always share with each other
    ifelse length colla-networks < 4 [
      set share-structure lput colla-networks share-structure
      set share-structure lput reverse colla-networks share-structure
      if length colla-networks = 3 [
        let add-colla-networks []
        set add-colla-networks lput first but-first colla-networks add-colla-networks
        set add-colla-networks lput first colla-networks add-colla-networks
        set add-colla-networks lput last colla-networks add-colla-networks
        set share-structure lput add-colla-networks share-structure
      ]
    ][

    ; the first network is defined to be the royal family:
    ; the network that shares with all other networks
    let middle first connect-networks
    set connect-networks remove-item 0 connect-networks
    let add-middle []
    set add-middle lput middle add-middle
    foreach connect-networks [ [?1] ->
      if ?1 != middle [
        set add-middle lput ?1 add-middle
      ]
    ]
    ; the other networks are put in a cycle, with the
    ; addition that every networks shares with middle (the royal family)
    while [length connect-networks > 2] [
      ifelse empty? share-structure[
        let to-add-structure1 []
        let to-add-structure2 []
        set to-add-structure1 lput first connect-networks to-add-structure1
        set to-add-structure1 lput first but-first connect-networks to-add-structure1
        set to-add-structure1 lput last connect-networks to-add-structure1
        set to-add-structure1 lput middle to-add-structure1
        set to-add-structure2 lput last connect-networks to-add-structure2
        set to-add-structure2 lput first connect-networks to-add-structure2
        set to-add-structure2 lput last but-last connect-networks to-add-structure2
        set to-add-structure2 lput middle to-add-structure2
        set share-structure lput to-add-structure1 share-structure
        set share-structure lput to-add-structure2 share-structure
      ][
      let to-add-structure []
      set to-add-structure lput first but-first connect-networks to-add-structure
      set to-add-structure lput first connect-networks to-add-structure
      set connect-networks remove-item 0 connect-networks
      set to-add-structure lput first but-first connect-networks to-add-structure
      set to-add-structure lput middle to-add-structure
      set share-structure lput to-add-structure share-structure
      ]
    ]

    ; the first entry of share-structure is the royal family entry
    set share-structure fput add-middle share-structure
    ]
  ][

  ; the other cases: a completely connected graph
  ; for each collaborator-network an entry is created with at the
  ; first position the network and then all others
  foreach colla-networks [ [?1] ->
    let cur-network ?1
    let to-add-structure []
    set to-add-structure lput cur-network to-add-structure
    foreach colla-networks [ [??1] ->
      if ??1 != cur-network [
        set to-add-structure lput ??1 to-add-structure
      ]
    ]
    set share-structure lput to-add-structure share-structure
  ]
  ]
  ]
end
