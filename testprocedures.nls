extensions[profiler]

; procedures for probing, testing and giving additional insights into the model.
; experimental: this file is not properly commented


globals [ctiho] ;current-theory(2)-info-hand-over (sorted)

to calc-global-admiss-core [vis] ;vis for visibility
	let new-info []
  let new-cur-info []
  let not-admissible []
	let subjective-arguments2 []
  let args-cur-arguments []
	let admissible-subj-argu2 []
  let attacked-by-me []
	let attack-relations []
	let cur-attacked []
	let cur-attacker []
  let theories []
  ask starts [
    let start-add []
    set start-add lput self start-add
    set start-add lput 0 start-add
    set theories lput start-add theories
  ]
  let current-theory-info2 theories
  ask attacks with [runresult vis] [
		set attack-relations lput self attack-relations
    set cur-attacked lput end2 cur-attacked
    set cur-attacker lput end1 cur-attacker
  ]
  ask turtles with [(breed = starts or breed = arguments) and runresult vis][
   set args-cur-arguments lput self args-cur-arguments
	 set subjective-arguments2 lput self subjective-arguments2
  ]
  foreach current-theory-info2 [
   set new-info lput replace-item 1 ? 0 new-info
  ]
	set current-theory-info2 new-info
 
 ; the computation of the admissible arguments is done recursively
 ; a list of arguments that are currently considered attacked
	let open-rec []
    ; variable that lets the loop run at least one time
  let i 0
  foreach current-theory-info2 [
  ; the theory that is considered in this loop
  ; and the root of that theory (the start)
		let cur-theory ?
    let askstart item 0 cur-theory
    while [ i < 1 or not empty? open-rec][
			set not-admissible sentence not-admissible open-rec
      set open-rec []
      set attacked-by-me []
        
      ; create a list of arguments that are attacked by the current theory
      ; based on the memory of the current agent
      if not empty? attack-relations [
				ask turtles with [member? self args-cur-arguments and mytheory = askstart][
					if member? self cur-attacker and not member? self not-admissible [
					; the argument considered and a list of arguments
					; attacked by that argument
						let cur-turtle self
						let my-attacked []
						foreach attack-relations [
							if [end1] of ? = cur-turtle [
								set my-attacked lput [end2] of ? my-attacked
							]
						]
						set attacked-by-me sentence my-attacked attacked-by-me
					]
				]
          
        ; arguments that are attacked by arguments from another theory that are
        ; not attacked by non-attacked arguments from the current theory
        ; are added to the open-rec list, the list of attacked-arguments
        ask turtles with [member? self args-cur-arguments and mytheory = askstart and not member? self not-admissible and member? self cur-attacked][
          let cur-turtle self
          foreach attack-relations [
            if [end2] of ? = cur-turtle [
              if not member? [end1] of ? attacked-by-me [
                set open-rec lput cur-turtle open-rec
              ]
            ]
          ]
        ]
      ]
      set i i + 1
    ]
    set i 0
      
    ; for the update of the information in current-theory-info
    set new-cur-info lput replace-item 1 cur-theory (count turtles with [member? self args-cur-arguments and mytheory = askstart] - count turtles with [member? self not-admissible and mytheory = askstart]) new-cur-info
  ]
    
    ; arguments that are part of the not-admissible list
    ; are not part of the admissible subjective arguments and hence removed
    set admissible-subj-argu2 subjective-arguments2
    foreach subjective-arguments2 [
			let cur-argu ?
			if member? cur-argu not-admissible [
				set admissible-subj-argu2 remove cur-argu admissible-subj-argu2
			]
		]
		
    ; update the current-theory-info
    set current-theory-info2 new-cur-info
		set ctiho sort-by [item 0 ? < item 0 ?2] current-theory-info2
end


; cadmis= calc-admissibility input can be red for the discovered landscape or
; anything else (e.g. 1) for the general landscape
to cadmis [input] 
	ifelse input = red [
		calc-global-admiss-core task [color != gray]
	][
		calc-global-admiss-core task [true]
	]
end



; prints the admissibility input the same as for cadmis (gets handed over)
to cadmisp [input]
	cadmis input
	print ctiho
end



; prints the admissibility of theory 170 - 85
to compare-two-with-three [times]
	repeat times [
		setup
		cadmis 1
		print (item 1 item 2 ctiho - item 1 item 1 ctiho)
	]
end



to test1
	let cur-attacked []
	ask attacks [
		set cur-attacked lput end2 cur-attacked
	]
  print cur-attacked
	
end

to test2 ; one random agent shows her attack-relations
  ask one-of agents [
    ; variables for lists that contain:
    ; the current-theory-info with 0 admissible arguments; an updated number
    ; of admissible arguments during the recursive computation; the arguments
    ; that are not admissible; the arguments that the agents knows about; and
    ; the arguments that are attacked by the current theory 
    let new-info []
    let new-cur-info []
    let not-admissible []
    let args-cur-arguments []
    let attacked-by-me []
    
    ; create a list of only the attacks
    let attack-relations []
    foreach subjective-relations [
      if first ? = "a" [
        set attack-relations lput ? attack-relations
      ]
    ]
		show attack-relations
    ; create lists of attacked and attacking arguments
    let cur-attacked []
    let cur-attacker []
    foreach attack-relations [
      set cur-attacked lput last ? cur-attacked
      set cur-attacker lput first but-first ? cur-attacker
    ]
    
    ; create a list of the arguments the agents knows about and 
    ; set the number of admissible arguments for each theory to 0
    foreach subjective-arguments [
      set args-cur-arguments lput first ? args-cur-arguments
    ]
    foreach current-theory-info [
      set new-info lput replace-item 1 ? 0 new-info
    ]
    set current-theory-info new-info
    
    ; the computation of the admissible arguments is done recursively
    ; a list of arguments that are currently considered attacked
    let open-rec []
    ; variable that lets the loop run at least one time
    let i 0
    foreach current-theory-info [
      ; the theory that is considered in this loop
      ; and the root of that theory (the start)
      let cur-theory ?
      let askstart item 0 cur-theory
      while [ i < 1 or not empty? open-rec][
        set not-admissible sentence not-admissible open-rec
        set open-rec []
        set attacked-by-me []
        
        ; create a list of arguments that are attacked by the current theory
        ; based on the memory of the current agent
        if not empty? attack-relations [
          ask turtles with [member? self args-cur-arguments and
	        mytheory = askstart][
            if member? self cur-attacker and not member? self not-admissible [
              ; the argument considered and a list of arguments
              ; attacked by that argument
              let cur-turtle self
              let my-attacked []
              foreach attack-relations [
                if first but-first ? = cur-turtle [
                  set my-attacked lput last ? my-attacked
                ]
              ]
              set attacked-by-me sentence my-attacked attacked-by-me
            ]
          ]
          
          ; arguments that are attacked by arguments from another theory that are
          ; not attacked by non-attacked arguments from the current theory
          ; are added to the open-rec list, the list of attacked-arguments
          ask turtles with [member? self args-cur-arguments and
	          mytheory = askstart and not member? self not-admissible and
	          member? self cur-attacked][
          let cur-turtle self
          foreach attack-relations [
            if last ? = cur-turtle [
              if not member? last but-last ? attacked-by-me [
                set open-rec lput cur-turtle open-rec
              ]
            ]
          ]
            ]
        ]
        set i i + 1
      ]
      set i 0
      
      ; for the update of the information in current-theory-info
      set new-cur-info lput replace-item 1 cur-theory (count turtles with
        [member? self args-cur-arguments and mytheory = askstart] -
	      count turtles with [member? self not-admissible and mytheory = askstart])
	        new-cur-info
    ]
    
    ; arguments that are part of the not-admissible list
    ; are not part of the admissible subjective arguments and hence removed
    set admissible-subj-argu subjective-arguments
    foreach subjective-arguments [
      let cur-argu ?
      if member? first cur-argu not-admissible [
        set admissible-subj-argu remove cur-argu admissible-subj-argu
      ]
    ]
    ; update the current-theory-info
    set current-theory-info new-cur-info
  ]
end

to test3 [input]
	ifelse input = red [
		calc-global-admiss-core task [color != gray]
	][
		calc-global-admiss-core task [true]
	]
end

to test4 [input1]
	ask attacks with [runresult input1] [print self]
end

; performs the setup times often and each time shows the admissibility for
; all theories
to test5 [times]
	repeat times [
		setup
		cadmisp 1
	]
end


; setup for the errorneous attack-relations
to setup-test-error
	clear-all
  initialize-hidden-variables
  create-discovery-landscape number-of-theories theory-depth
  define-attack-relation-error
  distribute-agents scientists
  reset-ticks
end


to define-attack-relation-error
  ; first the random attacks are defined
  define-attack-relation-create-attacks-error
  
  ; then the best theory defends itself
  define-attack-relation-defend-best
  
  ; the arguments and relations are spread over the patches
  define-attack-relation-visualize
end


to define-attack-relation-create-attacks-error
  ask turtles with [breed = starts or breed = arguments][
    ; variables for the current argument, the theory it belongs to,
    ; a random number between 0.00 and 1.00 and a list of theories
    let askargu self
    let curtheory mytheory
    let attack-random random-float 1.00
    let starts-list []
    ask starts [
      set starts-list lput who starts-list
    ]
    set starts-list sort starts-list
    
    ; with attack-probability-2nd from the interface an attack towards
    ; the current argument is created
    ifelse number-of-theories = 2[
      if attack-random < attack-probability-2nd and curtheory != start 0 [
        create-attack-from one-of other turtles with [(breed = starts or
	      breed = arguments)and mytheory != curtheory and not
	      (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
	      out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        set color gray
            ]
      ]
    ][
    
    ; when there are three theories both attack-probability-2nd and -3rd are
    ; considered to create attacks, depending on the theory the current argument
    ; belongs to first for the third theory
    ifelse [who] of curtheory = max starts-list and attack-random <
      attack-probability-3rd [
      create-attack-to one-of other turtles with [(breed = starts or
        breed = arguments) and mytheory != curtheory and not
	      (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
	      out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        set color gray
          ]
    ][
    ; then attacks towards arguments of the 2nd theory are created
    if [who] of curtheory != max starts-list and curtheory != start 0 and
      attack-random < attack-probability-2nd [
      create-attack-from one-of other turtles with [(breed = starts or
      breed = arguments) and mytheory != curtheory and not
      (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
	    out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        set color gray
          ]
    ]
    ]
    ]
    
    ; if the current argument belongs to the objective best theory
    ; an attack towards this argument is created with attack-probability-best
    if attack-random < attack-probability-best and curtheory = start 0 [
      create-attack-from one-of other turtles with [(breed = starts or
      breed = arguments) and mytheory != curtheory and not
	    (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
	    out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        set color gray
          ]
    ]
  ]
end

to compare-error-with-new [times]
	repeat times [
		setup
		cadmis 1
		print (word "fixed:      " ctiho " #attacks: "count attacks)
		setup-test-error
		cadmis 1
		print (word "errorneous: " ctiho " #attacks: "count attacks)
	]
end

to compare-error-with-new-statistics [times]
	repeat times [
		file-open "testprocedure_adm_fixed.txt"
		setup
		cadmis 1
		file-print (word item 1 item 1 ctiho " " item 1 item 2 ctiho)
		file-open "testprocedure_attack_fixed.txt"
		file-print count attacks
		file-open "testprocedure_adm_error.txt"
		setup-test-error
		cadmis 1
		file-print (word item 1 item 1 ctiho " " item 1 item 2 ctiho)
		file-open "testprocedure_attack_error.txt"
		file-print count attacks
	]
	file-close-all
end


to check-full-adm [times]
	file-open "testprocedure_full_adm.txt"
	repeat times [
		setup
		cadmis 1
		file-print item 1 item 0 ctiho
	]
	file-close-all
end

to test6 
	let i 0
	repeat 10 [
		set i (i + 1)
	]
	print i
end

to profilecore [repetitions go-version]               
	profiler:start         ;; start profiling
	repeat repetitions [ run go-version ]       ;; run something you want to measure
	profiler:stop          ;; stop profiling
	print profiler:report  ;; view the results
	profiler:reset         ;; clear the data
end

to profile [repetitions version]
	let go-version 0
	if version = "old" [set go-version task go]
	if version = "v1" [set go-version task go-test-v1]
	if version = "v2" [set go-version task go-test-v2]
	if version = "v31" [set go-version task go-test-v31]
	if version = "v32" [set go-version task go-test-v32]
	if version = "old3" [set go-version task go-test-oldv3]
	if version = "v41" [set go-version task go-test-v41]
	if version = "v51" [set go-version task go-test-v51]
	profilecore repetitions go-version
end


to duplicate-remover-test
  ask agents [
    ; list of arguments of which the duplicates will be removed
    let new-args subjective-arguments
    foreach new-args [
      ; the argument of the current entry and its color
      let argu first ?
      let my-color first but-first ?
      ; list of entries with the same argument, but maybe different color
      let color-argu filter [first ? = argu] new-args
      ; remove entries of arguments that are also present as
      ; better researched entries
      set color-argu sort-by [first but-first ?1 < first but-first ?2] color-argu
      while [length color-argu != 1] [
				show "idiots!"
				show (word "last a list: ")
				analize-list lastalist
				show (word "last b list: ")
				analize-list lastblist
				show (word "last a list after: ")
				analize-list lastalistafter
        set new-args remove last color-argu new-args
        set color-argu but-last color-argu
      ]
    ]
    ; update the agent's memory
    set subjective-arguments new-args
  ]
end

to analize-list [inputlist]
	foreach inputlist [
		let temp ?
		foreach temp [
		show ?
		]
		show ""
	]
end

to update-memories-test
  ask agents [
    let myx xcor
    let myy ycor
    let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      and xcor = myx and ycor = myy]
    let cur-agent self
    ; information of current argument in the format of the memory
    let add-cur (sentence cur-argum [color] of cur-argum)
;    set subjective-arguments lput add-cur subjective-arguments
    ; list of relations (resp. arguments) that are added
    let to-add []
		let to-add-argu []
    set to-add-argu lput add-cur to-add-argu
    ; list of neighborhood arguments of the current argument
    set neighborargs []
    set neighborargs lput cur-argum neighborargs
    
    ; for the current argument
    ; add the neighboring discovered arguments and relations
    ; (attacks and discovery) to a to-add list
    ask cur-argum [
       if any? my-in-discoveries with [color != gray][
        ask my-in-discoveries with [color != gray][
          let add-other-end other-end
          ask cur-agent [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added discovery relation
          let add-rel []
          set add-rel lput "d" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
      
      ; add the child argument of the discovery relation
      if any? my-out-discoveries with [color != gray][
        ask my-out-discoveries with [color != gray][
	  let add-other-end other-end
	  ask cur-agent [
	    set neighborargs lput add-other-end neighborargs
	  ]
	  ; construction of the to be added discovery relation
	  let add-rel []
	  set add-rel lput "d" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput add-other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
     
      ; add the parent argument of the attack relation
      if any? my-in-attacks with [color != gray][
        ask my-in-attacks with [color != gray][
          let add-other-end other-end
          ask cur-agent [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
      
      ; add the child argument of the attack relation
      if any? my-out-attacks with [color != gray][
        ask my-out-attacks with [color != gray][
          let add-other-end other-end
          ask cur-agent [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
    ]
    
    ; remove duplicates from the list
    set subjective-relations remove-duplicates sentence
      subjective-relations to-add
		; show subjective-arguments	
		; foreach to-add-argu [
			; let argu first ?
			; ; show ?
			; let my-color first but-first ?
			; ; list of entries with the same argument, but maybe different color
			; let argu-old filter [first ? = argu] subjective-arguments
			; ; show argu-old
			; if not empty? argu-old [
				; set argu-old item 0 argu-old
				; if my-color < item 1 argu-old [
					; let argument-position position argu-old subjective-arguments
					; ; show argument-position
					; ; remove entries of arguments that are also present as
					; ; better researched entries
					; ; set color-argu sort-by [first but-first ?1 < first but-first ?2] color-argu 
					; if argument-position != false [
						
						; ; show (word "replacing position " argument-position " with " ?)
						; set subjective-arguments replace-item argument-position subjective-arguments ?
					; ]
				; ]
				; if my-color > item 1 argu-old [
							; show "plausi check error new arg is older"
				; ]
			; ]
		; ]
    ; set subjective-arguments remove-duplicates sentence
      ; subjective-arguments to-add-argu
		; ; show subjective-arguments
	set subjective-arguments (merge-arg-wo-duplicates subjective-arguments to-add-argu false)
	set flag-updated-memory true
  ]
  
  ; every 5 plus 4 time-steps the collected information
  ; is shared with other agents
  if ticks mod 5 = 4 [
   share-with-others-test
  ] 
  
end


to update-memories-test2
  ask agents [
    let myx xcor
    let myy ycor
    let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      and xcor = myx and ycor = myy]
    let cur-agent self
    ; information of current argument in the format of the memory
    let add-cur (sentence cur-argum [color] of cur-argum)
;    set subjective-arguments lput add-cur subjective-arguments
    ; list of relations (resp. arguments) that are added
    let to-add []
		let to-add-argu []
    set to-add-argu lput add-cur to-add-argu
    ; list of neighborhood arguments of the current argument
    set neighborargs []
    set neighborargs lput cur-argum neighborargs
    
    ; for the current argument
    ; add the neighboring discovered arguments and relations
    ; (attacks and discovery) to a to-add list
    ask cur-argum [
       if any? my-in-discoveries with [color != gray][
        ask my-in-discoveries with [color != gray][
          let add-other-end other-end
          ask cur-agent [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added discovery relation
          let add-rel []
          set add-rel lput "d" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
      
      ; add the child argument of the discovery relation
      if any? my-out-discoveries with [color != gray][
        ask my-out-discoveries with [color != gray][
	  let add-other-end other-end
	  ask cur-agent [
	    set neighborargs lput add-other-end neighborargs
	  ]
	  ; construction of the to be added discovery relation
	  let add-rel []
	  set add-rel lput "d" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput add-other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
     
      ; add the parent argument of the attack relation
      if any? my-in-attacks with [color != gray][
        ask my-in-attacks with [color != gray][
          let add-other-end other-end
          ask cur-agent [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
      
      ; add the child argument of the attack relation
      if any? my-out-attacks with [color != gray][
        ask my-out-attacks with [color != gray][
          let add-other-end other-end
          ask cur-agent [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
    ]
    
    ; remove duplicates from the list
    set subjective-relations remove-duplicates sentence
      subjective-relations to-add
		; show subjective-arguments	
		; foreach to-add-argu [
			; let argu first ?
			; ; show ?
			; let my-color first but-first ?
			; ; list of entries with the same argument, but maybe different color
			; let argu-old filter [first ? = argu] subjective-arguments
			; ; show argu-old
			; if not empty? argu-old [
				; set argu-old item 0 argu-old
				; if my-color < item 1 argu-old [
					; let argument-position position argu-old subjective-arguments
					; ; show argument-position
					; ; remove entries of arguments that are also present as
					; ; better researched entries
					; ; set color-argu sort-by [first but-first ?1 < first but-first ?2] color-argu 
					; if argument-position != false [
						
						; ; show (word "replacing position " argument-position " with " ?)
						; set subjective-arguments replace-item argument-position subjective-arguments ?
					; ]
				; ]
				; if my-color > item 1 argu-old [
							; show "plausi check error new arg is older"
				; ]
			; ]
		; ]
    ; set subjective-arguments remove-duplicates sentence
      ; subjective-arguments to-add-argu
		; ; show subjective-arguments
	set subjective-arguments (merge-arg-wo-duplicates subjective-arguments to-add-argu false)
	set flag-updated-memory true
  ]
  
  ; every 5 plus 4 time-steps the collected information
  ; is shared with other agents
  if ticks mod 5 = 4 [
   share-with-others-test2
  ] 
  
end


to-report merge-arg-wo-duplicates [alist blist flag]

	if flag [
		set blist remove-duplicates blist
	]
	; set lastalist lput alist lastalist
	; set lastblist lput blist lastblist
	; if length lastalist > 2 [
		; set lastalist remove-item 0 lastalist
	; ]
	; if length lastblist > 2 [
		; set lastblist remove-item 0 lastblist
	; ]
	; if flag [
		; ; set blist list-cleaner blist
	; ]
	foreach blist [
		let argu first ?
		; show ?
		let my-color item 1 ?
		; list of entries with the same argument, but maybe different color
		if flag [
			let duplicate-check filter [first ? = argu] blist		
			foreach duplicate-check [
				if item 1 ? > my-color [
					set blist remove ? blist
				]
			]
		]
		let argu-old filter [first ? = argu] alist
		; show argu-old
		if not empty? argu-old [
			set argu-old item 0 argu-old
			
			if my-color < item 1 argu-old [		
			let argument-position position argu-old alist			
				; show argument-position
				; remove entries of arguments that are also present as
				; better researched entries
				; set color-argu sort-by [first but-first ?1 < first but-first ?2] color-argu 
				if argument-position != false [
					
					; show (word "replacing position " argument-position " with " ?)
					set alist replace-item argument-position alist ?
				]
			]
			if my-color >= item 1 argu-old [
				set blist remove ? blist
				;show (word my-color " " item 1 argu-old)
				;show (word "removed " ? " from " blist)
				; let argument-position position argu-old blist
				; set blist remove-item argument-position blist
				;set blist replace-item argument-position blist 
			]
		]
	]
  set alist remove-duplicates sentence
      alist blist
	
	; set lastalistafter lput alist lastalistafter
	; if length lastalistafter > 2 [
		; set lastalistafter remove-item 0 lastalistafter
	; ]
	report alist
end

to test-test [argu blist]
	let duplicate-check filter [first ? = argu] blist		
end

to-report list-cleaner [blist]
	let i 0
	let help []
	let blisth []
	foreach blist [
		set help lput 0 help	
		set blisth lput sentence ? i blisth
		set i i + 1
	]

	set i 0
	foreach blist [
		if item i help != 1 [
			let argu first ?
			; show ?
			let my-color item 1 ?
			; list of entries with the same argument, but maybe different color
				test-test argu blist
				let duplicate-check filter [first ? = argu] blisth		
				foreach duplicate-check [
					let argpos item 2 ? 
					set help replace-item argpos help 1
					if item 1 ? > my-color [
						set blist remove ? blist
					]
				]
			]
		set i i + 1
		]
		report blist

end

to go-test-v2
  ; update-memories-test
	; if ticks mod 10 = 4 [
		; duplicate-remover-test
	; ]  
  if ticks mod 5 = 4 [
    update-memories-test
		compute-strategies-agents
    act-on-strategy-agents-test
  ]
  move-around-test
  update-landscape
	ask agents [
		set flag-updated-memory false
	]
  compute-popularity
  tick
end

to go-test-v32
  ; update-memories-test
	; if ticks mod 10 = 4 [
		; duplicate-remover-test
	; ]  
  if ticks mod 5 = 4 [
    update-memories-test
		compute-strategies-agents-test
    act-on-strategy-agents-test
  ]
  move-around-test
  update-landscape
	ask agents [
		set flag-updated-memory false
	]
  compute-popularity
  tick
end

to go-test-v1
  update-memories-test
	; if ticks mod 10 = 4 [
		; duplicate-remover-test
	; ]  
  if ticks mod 5 = 4 [
    ; update-memories-test
		compute-strategies-agents
    act-on-strategy-agents
  ]
  move-around
  update-landscape
  compute-popularity
  tick
end

to go-test-v31
  update-memories-test
	; if ticks mod 10 = 4 [
		; duplicate-remover-test
	; ]  
  if ticks mod 5 = 4 [
    ; update-memories-test
		compute-strategies-agents-test
    act-on-strategy-agents
  ]
  move-around
  update-landscape
  compute-popularity
  tick
end

to go-test-oldv3
	update-memories
  duplicate-remover
  if ticks mod 5 = 4 [
    compute-strategies-agents-test
    act-on-strategy-agents
  ]
  move-around
  update-landscape
  compute-popularity
  tick
end

to go-test-v41
  update-memories-test2
	; if ticks mod 10 = 4 [
		; duplicate-remover-test
	; ]  
  if ticks mod 5 = 4 [
    ; update-memories-test
		compute-strategies-agents-test
    act-on-strategy-agents
  ]
  move-around
  update-landscape
  compute-popularity
  tick
end

to go-test-v51
  update-memories-test5

	; if ticks mod 10 = 4 [
		; duplicate-remover-test
	; ]  
  if ticks mod 5 = 4 [
		share-with-others-test5
		create-share-memory-test5
		share-with-other-networks-test5
		compute-time-costs-test5
    ; update-memories-test
		compute-strategies-agents-test
    act-on-strategy-agents
  ]
  move-around
  update-landscape
  compute-popularity
  tick
end

to go-test
	go-test-v51
end

to go-stop-test
	setuprs new-seed
	go-test
	while [any? arguments with [
	color != red and [myscientists] of mytheory !=  0
	]
	][
		go-test
	]
end

to setuprs [rs]
  clear-all
  random-seed rs
	print (word "random seed: " rs)
	print (word "no. scientists: " scientists)
  initialize-hidden-variables
  create-discovery-landscape number-of-theories theory-depth
  define-attack-relation
  distribute-agents scientists
  reset-ticks
	ask agents [
		set lastalist []
		set lastblist []
		set lastalistafter []
		set flag-updated-memory false
		set conference-attended false
		set to-add-mem-argu []
		set to-add-mem-rel []
		
	]	
end




to share-with-others-test
  ask agents [
    ; reset the variables
    set rep-agent false 
    set to-add-mem-argu []
    set to-add-mem-rel []
    
    ; variables to keep track of the current agents own memory
    ; and the combined memory of all the sharing agents
    ; let own-memory-argu subjective-arguments
    ; let own-memory-rel subjective-relations
    let comb-memory-argu []
    let comb-memory-rel []
    ; collaborator network of the current agent
    let cur-network collaborator-network
    
    ; the information in the memories of the single agents in the network
    ; are combined 
    ask turtles with [member? self cur-network] [
      set comb-memory-argu sentence subjective-arguments comb-memory-argu
      set comb-memory-rel sentence subjective-relations comb-memory-rel
    ]
    
    ; each agent adds the combined memory to its own
    ; then removing duplicates
		set subjective-arguments (merge-arg-wo-duplicates subjective-arguments comb-memory-argu true)
    set subjective-relations remove-duplicates sentence
      subjective-relations comb-memory-rel
  ]
  
  ; then agents can share some of their information with agents 
  ; from neighboring networks in the social structures
  create-share-memory-test
  share-with-other-networks-test
  
end




to create-share-memory-test
  
  ; for each collaborator-network one agent is set to be
  ; the representative agent
  foreach colla-networks [
    ifelse length ? > 1 [
      ask one-of agents with [member? self ?][
        set rep-agent true
      ] 	
    ][
    if ticks mod 25 = 4 [
      ask one-of agents with [member? self ?][
        set rep-agent true
      ]
    ]
    ]
  ]
  
  ; only the representative agents create a memory 
  ; that they want to share with agents from other networks
  ask agents with [rep-agent][
    let myx xcor
    let myy ycor
    ; variables for the argument the agent is currently working on,
    ; the agent itself and the theory it is working on
    let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      and xcor = myx and ycor = myy]
    let cur-agent self 
    let cur-th [mytheory] of cur-argum
    ; create a list of arguments and a list of relations that the agent can
    ; share with agents from other collaborative networks
    ; what agents share depends on the "social-action" and "sharing"
    ; from the interface
    set th-args []
    set th-relations []
    
    ; agents share only information obtained in the neighborhood 
    ; they are currently working on
    ; collect the arguments from the agent's memory
    ; that belong also to the neighborargs
    foreach subjective-arguments [
      if member? item 0 ? [neighborargs] of cur-agent [
        set th-args lput ? th-args
      ]
    ]
    ; collect the relations from/to the current argument
    ; from the agent's memory
    foreach subjective-relations [
      if item 1 ? = cur-argum or item 2 ? = cur-argum [
        set th-relations lput ? th-relations
      ]
    ]
    
    ; if the agent behaves biased it does not share the attack relations that
    ; attack its current theory, these relations are removed
    if social-actions = "biased"[
      foreach th-relations [
        if item 0 ? = "a" and [mytheory] of item 2 ? = cur-th [
          set th-relations remove ? th-relations
        ]
      ]
    ]
  ]
end




to share-with-other-networks-test 
  ask agents with [rep-agent][
    ; variables for the combined information (arguments and relations),
    ; the network of the current agent and the theory it is working on
    let comb-memory-argu th-args
    let comb-memory-rel th-relations
    let cur-network sort collaborator-network
    let my-cur-theory [mytheory] of item 0 item 0 th-args
    
    ; create a list of the neighboring networks and then a 
    ; list of the representative agents of these networks
    ; which will be the agents the current agent shares with
    let share-agents []
    let share-neighbors []
    foreach share-structure [    
      if first ? = cur-network [
        set share-neighbors ?
      ]
    ]
    ask agents with [rep-agent][
      let cur-agent self
      foreach share-neighbors [
        if member? cur-agent ? [
          set share-agents lput cur-agent share-agents
        ]
      ]
    ]
    
    ; create a list of arguments and a list of relations that is
    ; shared among the share-agents
    foreach share-agents [
      ; the combined memory is updated to contain that of the sharing agent
      set comb-memory-argu sentence comb-memory-argu [th-args] of ?
      set comb-memory-rel sentence comb-memory-rel [th-relations] of ?
    ]
    ; create lists of arguments/relations that have to be added
    foreach share-agents [
      set to-add-mem-argu remove-duplicates sentence subjective-arguments
        comb-memory-argu
      set to-add-mem-rel remove-duplicates sentence subjective-relations
        comb-memory-rel
    ]
  ] 
  
  ; to compute the time that agents have to
  ; spend on communication
  compute-time-costs-test 
end



to compute-time-costs-test
  ask agents with [rep-agent][
    
    ; variables that contain the arguments and relations the
    ; agent has to update in its memory
    let new-memory-args []
    let new-memory-rel []
		let to-add-argu []
    set new-memory-args filter [not member? ? subjective-arguments]
      to-add-mem-argu
    set new-memory-rel filter [not member? ? subjective-relations]
      to-add-mem-rel
    let comb-new sentence new-memory-args new-memory-rel
    ; every tick an agent can obtain a maximum of 10 new entries
    ; the day that they received information is also lost
    ifelse length comb-new >= (3 * max-learn) [
      set communicating 4
    ][
    set communicating ((ceiling (length comb-new / max-learn)) + 1)
    ]
    
    ; every communication round an agent can update a maximum of 
    ; 3 * max-learn new arguments/relations (corresponding to three ticks of
    ; communication) these new arguments and relations are added to the
    ; memory of the agent
    ; when a new relation is added and the arguments are not part of the
    ; memory of the agent, these arguments are added as well
    ifelse length comb-new > (3 * max-learn) [
      set comb-new shuffle comb-new
      let repeats length comb-new - (3 * max-learn)
      while [length comb-new > repeats] [
        let cur-entr first comb-new
        let new-mem-argargs filter [member? ? new-memory-args] comb-new
        set new-mem-argargs map [first ?] new-mem-argargs
        ifelse member? cur-entr new-memory-args [
          set to-add-argu lput cur-entr to-add-argu
          set comb-new remove cur-entr comb-new
        ][
        set subjective-relations lput cur-entr subjective-relations
        set comb-new remove cur-entr comb-new
        if member? item 1 cur-entr new-mem-argargs[
          let item-1-cur-entr item 1 cur-entr
          foreach comb-new [
            if item-1-cur-entr = item 0 ? [
              set to-add-argu lput ? to-add-argu
              set comb-new remove ? comb-new
            ]
          ] 
        ]
        if member? item 2 cur-entr new-mem-argargs[
          let item-2-cur-entr item 2 cur-entr
          foreach comb-new [
            if item-2-cur-entr = item 0 ? [
              set to-add-argu lput ? to-add-argu
              set comb-new remove ? comb-new
            ]
          ] 
        ]
        ]
      ]
			set subjective-arguments (merge-arg-wo-duplicates subjective-arguments to-add-argu true)
    ][
		set subjective-arguments (merge-arg-wo-duplicates subjective-arguments new-memory-args true)
    set subjective-relations sentence subjective-relations new-memory-rel ;remove duplicates!? bug maybe -> probably no problem b/c remove duplicates for relations is run during "share-with-other-networks" 
    ]
  ]
end


to bla [times]
	repeat times [go-test]
end


to refresh-mem-set-move-parameter
	refresh-mem-before-move
	set moved true
end

to refresh-mem-before-move
	if not flag-updated-memory [
		let myx xcor
		let myy ycor
		let cur-argum one-of turtles with [(breed = starts or breed = arguments)
			and xcor = myx and ycor = myy]
		let cur-agent self
		; information of current argument in the format of the memory
		let add-cur (sentence cur-argum [color] of cur-argum)
	;    set subjective-arguments lput add-cur subjective-arguments
		; list of relations (resp. arguments) that are added
		let to-add []
		let to-add-argu []
		set to-add-argu lput add-cur to-add-argu
		; list of neighborhood arguments of the current argument
		set neighborargs []
		set neighborargs lput cur-argum neighborargs
		
		; for the current argument
		; add the neighboring discovered arguments and relations
		; (attacks and discovery) to a to-add list
		ask cur-argum [
			 if any? my-in-discoveries with [color != gray][
				ask my-in-discoveries with [color != gray][
					let add-other-end other-end
					ask cur-agent [
						set neighborargs lput add-other-end neighborargs
					]
					; construction of the to be added discovery relation
					let add-rel []
					set add-rel lput "d" add-rel
					set add-rel lput add-other-end add-rel
					set add-rel lput cur-argum add-rel
					set to-add lput add-rel to-add
					; the to be added argument
					let add-other (sentence add-other-end [color] of add-other-end)
					set to-add-argu lput add-other to-add-argu
				]
			]
			
			; add the child argument of the discovery relation
			if any? my-out-discoveries with [color != gray][
				ask my-out-discoveries with [color != gray][
		let add-other-end other-end
		ask cur-agent [
			set neighborargs lput add-other-end neighborargs
		]
		; construction of the to be added discovery relation
		let add-rel []
		set add-rel lput "d" add-rel
					set add-rel lput cur-argum add-rel
					set add-rel lput add-other-end add-rel
					set to-add lput add-rel to-add
					; the to be added argument
					let add-other (sentence add-other-end [color] of add-other-end)
					set to-add-argu lput add-other to-add-argu
				]
			]
		 
			; add the parent argument of the attack relation
			if any? my-in-attacks with [color != gray][
				ask my-in-attacks with [color != gray][
					let add-other-end other-end
					ask cur-agent [
						set neighborargs lput add-other-end neighborargs
					]
					; construction of the to be added attack relation
					let add-rel []
					set add-rel lput "a" add-rel
					set add-rel lput add-other-end add-rel
					set add-rel lput cur-argum add-rel
					set to-add lput add-rel to-add
					; the to be added argument
					let add-other (sentence add-other-end [color] of add-other-end)
					set to-add-argu lput add-other to-add-argu
				]
			]
			
			; add the child argument of the attack relation
			if any? my-out-attacks with [color != gray][
				ask my-out-attacks with [color != gray][
					let add-other-end other-end
					ask cur-agent [
						set neighborargs lput add-other-end neighborargs
					]
					; construction of the to be added attack relation
					let add-rel []
					set add-rel lput "a" add-rel
					set add-rel lput cur-argum add-rel
					set add-rel lput other-end add-rel
					set to-add lput add-rel to-add
					; the to be added argument
					let add-other (sentence add-other-end [color] of add-other-end)
					set to-add-argu lput add-other to-add-argu
				]
			]
		]
	
		; remove duplicates from the list
		set subjective-relations remove-duplicates sentence
			subjective-relations to-add
		; show subjective-arguments	
		; foreach to-add-argu [
			; let argu first ?
			; ; show ?
			; let my-color first but-first ?
			; ; list of entries with the same argument, but maybe different color
			; let argu-old filter [first ? = argu] subjective-arguments
			; ; show argu-old
			; if not empty? argu-old [
				; set argu-old item 0 argu-old
				; if my-color < item 1 argu-old [
					; let argument-position position argu-old subjective-arguments
					; ; show argument-position
					; ; remove entries of arguments that are also present as
					; ; better researched entries
					; ; set color-argu sort-by [first but-first ?1 < first but-first ?2] color-argu 
					; if argument-position != false [
						
						; ; show (word "replacing position " argument-position " with " ?)
						; set subjective-arguments replace-item argument-position subjective-arguments ?
					; ]
				; ]
				; if my-color > item 1 argu-old [
							; show "plausi check error new arg is older"
				; ]
			; ]
		; ]
		; set subjective-arguments remove-duplicates sentence
			; subjective-arguments to-add-argu
		; ; show subjective-arguments
		set subjective-arguments (merge-arg-wo-duplicates subjective-arguments to-add-argu false)
		set flag-updated-memory true
  ]
end

to move-around-test
  ; variable to make sure that the procedure find-defense
  ; is only run once
  let run-find-defense false 
  ; at the beginning of the procedure no agent has moved yet
  ask agents [
    set moved false
  ]
  ask agents [
    let curagent self
    if [communicating] of curagent = 0 or ticks mod 5 = 0 [
      let myx xcor
      let myy ycor
      ; variable for the argument the agent is currently working on and
     ; the agent itself
        let myargu one-of turtles with [(breed = starts or breed = arguments) and
        xcor = myx and ycor = myy]
      
      ; a list of not-admissible arguments is created
      let not-admissible []
      if admissible-subj-argu != 0 and not empty? admissible-subj-argu [
        let info-not-admissible filter [not member? ? admissible-subj-argu]
          subjective-arguments
        foreach info-not-admissible [
          set not-admissible lput item 0 ? not-admissible
        ]
      ]
   
      ; an agent working on an attacked argument will try to find a defense for
      ; this attack, by working further on the attacked argument, unless it
      ; discoveres a child-argument that that has a defense for the attack
      ; (it is not necessarily the case that this defense is already discovered)
      ; the find-defense runs immediately for all agents working on a not
      ; fully researched not-admissible argument, hence it is only once executed
      if member? myargu not-admissible and not moved[
      
        if not run-find-defense [
          find-defense-test
          set run-find-defense true
        ]
      ]
    
      if not moved and not member? myargu not-admissible or 
        (member? myargu not-admissible and [color] of myargu = red)[
        
        ; when an argument exists that:
        ; a) is a child-argument of the current argument;
        ; b) is not gray, red or turquoise; and
        ; c) no agent from the same collaborator-network is working on it
        ; the agent moves there, with certain probability
        ifelse any? turtles with [(breed = starts or breed = arguments) and
          in-discovery-neighbor? myargu and color != gray and color != red and
    	  color != turquoise and not (any? turtles with [breed = agents and
	  xcor = [xcor] of myself and ycor = [ycor] of myself and member? self
	  [collaborator-network] of curagent])] [
        let move-random random-float 1.0
      

        ; every time step with small-movement of the move-probability
        ; the agent moves
        ifelse move-random < (small-movement * move-probability *
          (1 - (color / color-move))) [ refresh-mem-before-move
          move-to one-of turtles with [(breed = starts or breed = arguments) and
            in-discovery-neighbor? myargu and color != gray and color != red and
            color != turquoise and not ( any? turtles with [breed = agents and
            xcor = [xcor] of myself and ycor = [ycor] of myself and member? self
  	    [collaborator-network] of curagent])]
          set moved true
        ][
      
        ; every 5th time step the agent mover with the full move-probability,
        ; that depends a bit on the color
        if ticks != 0 and ticks mod 5 = 0 and move-random <
          move-probability * (1 - (color / color-move)) [ refresh-mem-before-move
          move-to one-of turtles with [(breed = starts or breed = arguments) and
            in-discovery-neighbor? myargu and color != gray and color != red and
	    color != turquoise and not ( any? turtles with [breed = agents
	    and xcor = [xcor] of myself and ycor = [ycor] of myself and
	    member? self [collaborator-network] of curagent])]
          set moved true
        ]
        ]
            ][

        ; if there is no next argument and the current argument is
        ; fully researched, the agent moves a step back
        ifelse [color] of myargu = red and any? turtles with [color != gray and
          color != turquoise and out-discovery-neighbor? myargu and not any?
	  turtles with [breed = agents and xcor = [xcor] of myself and
	  ycor = [ycor] of myself and member? self [collaborator-network]
	  of curagent]][ refresh-mem-before-move
        move-to one-of turtles with [color != gray and out-discovery-neighbor?
          myargu and not any? turtles with [breed = agents and xcor = [xcor] of
          myself and ycor = [ycor] of myself and member? self
          [collaborator-network] of curagent]]
        set moved true
          ][
      
        ; if moving back is not possible, it jumps to another argument in
        ; the same tree/theory that is discovered but not fully researched
        if [color] of myargu = red[
          let askstart [mytheory] of myargu
          if any? turtles with [(breed = starts or breed = arguments) and
	    color != gray and color != turquoise and color != red and
	    mytheory = askstart and not any? turtles with [breed = agents and
  	    xcor = [xcor] of myself and ycor = [ycor] of myself and member?
	    self [collaborator-network] of curagent]][ refresh-mem-before-move
          move-to one-of turtles with [(breed = starts or breed = arguments) and
	   color != turquoise and color != gray and color != red and
  	   mytheory = askstart and not any? turtles with [breed = agents and
	   xcor = [xcor] of myself and ycor = [ycor] of myself and member? self
           [collaborator-network] of curagent]]
          set moved true
            ]
        ]
          ]
            ]
      ]
    ]	
  ]
end


to find-defense-test
  ask agents with [not moved][    
    let curagent self
    if [communicating] of curagent = 0 or ticks mod 5 = 0 [
      let myx xcor
      let myy ycor
      ; variables for the argument the agent is working on and
      ; for the agent itself
      let myargu one-of turtles with [(breed = starts or breed = arguments) and
        xcor = myx and ycor = myy]
    
      ; lists of arguments that are not admissible
      let not-admissible []
      if admissible-subj-argu != 0 and not empty? admissible-subj-argu [
        let info-not-admissible filter [not member? ? admissible-subj-argu]
          subjective-arguments
        foreach info-not-admissible [
          set not-admissible lput item 0 ? not-admissible
        ]
      ]
    
      ; if the current argument is not fully researched and not admissible
      ; and it is a 5th time step or the agent is not communicating
      ; the agent tries to move prospectively to a child-argument of the current 
      ; argument that provides a defense for the current argument
      if member? myargu not-admissible[
        ask myargu [
          ask my-in-attacks [
            ask end1 [
              ; create a set of arguments that provide a defense for the current
	      ; argument, these:
              ; a) attack the attacker of the current argument;
	      ; b) are a child-argument of the current argument;
              ; c) are discovered; and
	      ; d) no agent from the same network is working on it
              let nextargu in-attack-neighbors with [in-discovery-neighbor?
	        myargu and color != gray and color != turquoise and not (any?
		agents with [xcor = [xcor] of myself and ycor = [ycor] of myself
		and member? self [collaborator-network] of curagent])]
              ; if such an argument exists the agent moves there
              ; and cannot move anymore this time step
              if any? nextargu [
                ask curagent [
									refresh-mem-before-move
                  move-to one-of nextargu
                  set moved true
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
end


to act-on-strategy-agents-test
  ask agents with [not rep-agent][
    ; only when there is a current best theory
    ; it makes sense for the agents to want to work on that theory
    if not empty? cur-best-th and not member? nobody cur-best-th [
      let myx xcor
      let myy ycor
      
      ; if the agent is not currently working on the best theory
      ; it considers jumping
      foreach subjective-arguments [
        if [xcor] of item 0 ? = myx and [ycor] of item 0 ? = myy and
        not member? [mytheory] of item 0 ? cur-best-th [
          set theory-jump theory-jump + 1
        ]
      ]
      
      ; if the agent has considered jumping jump-threshold times
      ; it jumps to one of the theories it considers best, based
      ; on its memory and the computations
      if theory-jump >= jump-threshold [
        let ch-best one-of cur-best-th
        let subj-argus []
        foreach subjective-arguments [
          set subj-argus lput item 0 ? subj-argus
        ]
        
        ; if one of the arguments from the best theory is in its memory
        ; the agent will jump there
        ifelse any? turtles with [(breed = starts or breed = arguments) and
	        member? self subj-argus and mytheory = ch-best and color != turquoise][
            move-to one-of turtles with [(breed = starts or breed = arguments) and
              member? self subj-argus and mytheory = ch-best and color != turquoise]
          ][ ; otherwise the agent jumps to the root of the theory
					refresh-mem-before-move
          move-to ch-best
          ]
        
        set times-jumped times-jumped + 1
        set theory-jump 0
      ]
    ]
  ]
end


to compute-subj-attacked-test
	foreach colla-networks [
		let calc-done false
		let calc-agent []
		let cur-group ?
		foreach cur-group [
			let cur-agent ?
			if not [rep-agent] of cur-agent [
				ifelse calc-done [
					ask cur-agent [
						set admissible-subj-argu [admissible-subj-argu] of calc-agent
						set current-theory-info [current-theory-info] of calc-agent
					]
				][
					set calc-done true
					set calc-agent cur-agent
					ask cur-agent [
						; variables for lists that contain:
						; the current-theory-info with 0 admissible arguments; an updated number
						; of admissible arguments during the recursive computation; the arguments
						; that are not admissible; the arguments that the agents knows about; and
						; the arguments that are attacked by the current theory 
						let new-info []
						let new-cur-info []
						let not-admissible []
						let args-cur-arguments []
						let attacked-by-me []
						
						; create a list of only the attacks
						let attack-relations []
						foreach subjective-relations [
							if first ? = "a" [
								set attack-relations lput ? attack-relations
							]
						]
						; create lists of attacked and attacking arguments
						let cur-attacked []
						let cur-attacker []
						foreach attack-relations [
							set cur-attacked lput last ? cur-attacked
							set cur-attacker lput first but-first ? cur-attacker
						]
						
						; create a list of the arguments the agents knows about and 
						; set the number of admissible arguments for each theory to 0
						foreach subjective-arguments [
							set args-cur-arguments lput first ? args-cur-arguments
						]
						foreach current-theory-info [
							set new-info lput replace-item 1 ? 0 new-info
						]
						set current-theory-info new-info
						
						; the computation of the admissible arguments is done recursively
						; a list of arguments that are currently considered attacked
						let open-rec []
						; variable that lets the loop run at least one time
						let i 0
						foreach current-theory-info [
							; the theory that is considered in this loop
							; and the root of that theory (the start)
							let cur-theory ?
							let askstart item 0 cur-theory
							while [ i < 1 or not empty? open-rec][
								set not-admissible sentence not-admissible open-rec
								set open-rec []
								set attacked-by-me []
								
								; create a list of arguments that are attacked by the current theory
								; based on the memory of the current agent
								if not empty? attack-relations [
									ask turtles with [member? self args-cur-arguments and
									mytheory = askstart][
										if member? self cur-attacker and not member? self not-admissible [
											; the argument considered and a list of arguments
											; attacked by that argument
											let cur-turtle self
											let my-attacked []
											foreach attack-relations [
												if first but-first ? = cur-turtle [
													set my-attacked lput last ? my-attacked
												]
											]
											set attacked-by-me sentence my-attacked attacked-by-me
										]
									]
									
									; arguments that are attacked by arguments from another theory that are
									; not attacked by non-attacked arguments from the current theory
									; are added to the open-rec list, the list of attacked-arguments
									ask turtles with [member? self args-cur-arguments and
										mytheory = askstart and not member? self not-admissible and
										member? self cur-attacked][
									let cur-turtle self
									foreach attack-relations [
										if last ? = cur-turtle [
											if not member? last but-last ? attacked-by-me [
												set open-rec lput cur-turtle open-rec
											]
										]
									]
										]
								]
								set i i + 1
							]
							set i 0
							
							; for the update of the information in current-theory-info
							set new-cur-info lput replace-item 1 cur-theory (count turtles with
								[member? self args-cur-arguments and mytheory = askstart] -
								count turtles with [member? self not-admissible and mytheory = askstart])
									new-cur-info
						]
						
						; arguments that are part of the not-admissible list
						; are not part of the admissible subjective arguments and hence removed
						set admissible-subj-argu subjective-arguments
						foreach subjective-arguments [
							let cur-argu ?
							if member? first cur-argu not-admissible [
								set admissible-subj-argu remove cur-argu admissible-subj-argu
							]
						]
						; update the current-theory-info
						set current-theory-info new-cur-info
					]
				]
			]
		]
	]
end


to compute-strategies-agents-test
  
  ; agents start with figuring out which argument in their
  ; memory are admissible and which are attacked
  compute-subj-attacked-test
 
  ask agents with [not rep-agent][
    set cur-best-th []
    ; variables for the list that contains the number admissible arguments 
    ; per theory and a sublist which contains only the numbers that are
    ; within the strategy-threshold
    let list-admissible-arguments []
    let threshold-admissible-arguments []
    
    ; create a list with the number of admissible arguments
    ; of each of the theories
    foreach current-theory-info [
      set list-admissible-arguments lput item 1 ? list-admissible-arguments
    ]
    set list-admissible-arguments sort list-admissible-arguments
    
    ; a list of theories with values within the strategy threshold is constructed
    set threshold-admissible-arguments filter [? >=
      ((max list-admissible-arguments) * strategy-threshold)]
        list-admissible-arguments
    set threshold-admissible-arguments sort threshold-admissible-arguments
    
    ; computation of the current best theory
    ; theories with a number of admissible arguments that are
    ; within the threshold can be considered as current best theory
    foreach current-theory-info [
      if member? item 1 ? threshold-admissible-arguments [
        set cur-best-th lput item 0 ? cur-best-th
      ]
    ]
  ]
end




to share-with-others-test2
	foreach colla-networks [
		let group-sharing-done false
		let grp-share-agent []
		let cur-group ?
		foreach cur-group [
			let cur-agent ?
				ifelse group-sharing-done [
					ask cur-agent [			
						set rep-agent false 
						set subjective-arguments [subjective-arguments] of grp-share-agent
						set subjective-relations [subjective-relations] of grp-share-agent
					]
				][
					set group-sharing-done true
					set grp-share-agent cur-agent
					ask cur-agent [
						; reset the variables
						set rep-agent false 
						set to-add-mem-argu []
						set to-add-mem-rel []
						
						; variables to keep track of the current agents own memory
						; and the combined memory of all the sharing agents
						; let own-memory-argu subjective-arguments
						; let own-memory-rel subjective-relations
						let comb-memory-argu []
						let comb-memory-rel []
						; collaborator network of the current agent
						let cur-network collaborator-network
						
						; the information in the memories of the single agents in the network
						; are combined 
						
						foreach cur-group [
							let input-agent ?						
							set comb-memory-argu sentence [subjective-arguments] of input-agent comb-memory-argu
							set comb-memory-rel sentence [subjective-relations] of input-agent comb-memory-rel
						]	
						
						; each agent adds the combined memory to its own
						; then removing duplicates
						set subjective-arguments (merge-arg-wo-duplicates subjective-arguments comb-memory-argu true)
						set subjective-relations remove-duplicates sentence
							subjective-relations comb-memory-rel
							
							]
						]
					]]
  
  ; then agents can share some of their information with agents 
  ; from neighboring networks in the social structures
  create-share-memory-test
  share-with-other-networks-test
  

	
end


to update-memories-test5
  ask agents [
    let myx xcor
    let myy ycor
    let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      and xcor = myx and ycor = myy]
    let cur-agent self
    ; information of current argument in the format of the memory
    let add-cur (sentence cur-argum [color] of cur-argum)
;    set subjective-arguments lput add-cur subjective-arguments
    ; list of relations (resp. arguments) that are added
    let to-add []
		let to-add-argu []
    set to-add-argu lput add-cur to-add-argu
    ; list of neighborhood arguments of the current argument
    set neighborargs []
    set neighborargs lput cur-argum neighborargs
    
    ; for the current argument
    ; add the neighboring discovered arguments and relations
    ; (attacks and discovery) to a to-add list
    ask cur-argum [
       if any? my-in-discoveries with [color != gray][
        ask my-in-discoveries with [color != gray][
          let add-other-end other-end
          ask cur-agent [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added discovery relation
          let add-rel []
          set add-rel lput "d" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
      
      ; add the child argument of the discovery relation
      if any? my-out-discoveries with [color != gray][
        ask my-out-discoveries with [color != gray][
	  let add-other-end other-end
	  ask cur-agent [
	    set neighborargs lput add-other-end neighborargs
	  ]
	  ; construction of the to be added discovery relation
	  let add-rel []
	  set add-rel lput "d" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput add-other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
     
      ; add the parent argument of the attack relation
      if any? my-in-attacks with [color != gray][
        ask my-in-attacks with [color != gray][
          let add-other-end other-end
          ask cur-agent [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
      
      ; add the child argument of the attack relation
      if any? my-out-attacks with [color != gray][
        ask my-out-attacks with [color != gray][
          let add-other-end other-end
          ask cur-agent [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
    ]
    
    ; remove duplicates from the list
    set subjective-relations remove-duplicates sentence
      subjective-relations to-add
		; show subjective-arguments	
		; foreach to-add-argu [
			; let argu first ?
			; ; show ?
			; let my-color first but-first ?
			; ; list of entries with the same argument, but maybe different color
			; let argu-old filter [first ? = argu] subjective-arguments
			; ; show argu-old
			; if not empty? argu-old [
				; set argu-old item 0 argu-old
				; if my-color < item 1 argu-old [
					; let argument-position position argu-old subjective-arguments
					; ; show argument-position
					; ; remove entries of arguments that are also present as
					; ; better researched entries
					; ; set color-argu sort-by [first but-first ?1 < first but-first ?2] color-argu 
					; if argument-position != false [
						
						; ; show (word "replacing position " argument-position " with " ?)
						; set subjective-arguments replace-item argument-position subjective-arguments ?
					; ]
				; ]
				; if my-color > item 1 argu-old [
							; show "plausi check error new arg is older"
				; ]
			; ]
		; ]
    ; set subjective-arguments remove-duplicates sentence
      ; subjective-arguments to-add-argu
		; ; show subjective-arguments
	set subjective-arguments (merge-arg-wo-duplicates subjective-arguments to-add-argu false)
	set flag-updated-memory true
  ]
  
  ; every 5 plus 4 time-steps the collected information
  ; is shared with other agents  
end



to share-with-others-test5
	foreach colla-networks [
		let group-sharing-done false
		let grp-share-agent []
		let cur-group ?
		foreach cur-group [
			let cur-agent ?
				ifelse group-sharing-done [
					ask cur-agent [			
						set rep-agent false 
						set subjective-arguments [subjective-arguments] of grp-share-agent
						set subjective-relations [subjective-relations] of grp-share-agent
					]
				][
					set group-sharing-done true
					set grp-share-agent cur-agent
					ask cur-agent [
						; reset the variables
						set rep-agent false 
						set to-add-mem-argu []
						set to-add-mem-rel []
						
						; variables to keep track of the current agents own memory
						; and the combined memory of all the sharing agents
						; let own-memory-argu subjective-arguments
						; let own-memory-rel subjective-relations
						let comb-memory-argu []
						let comb-memory-rel []
						; collaborator network of the current agent
						let cur-network collaborator-network
						
						; the information in the memories of the single agents in the network
						; are combined 
						
						foreach cur-group [
							let input-agent ?						
							set comb-memory-argu sentence [subjective-arguments] of input-agent comb-memory-argu
							set comb-memory-rel sentence [subjective-relations] of input-agent comb-memory-rel
						]	
						
						; each agent adds the combined memory to its own
						; then removing duplicates
						set subjective-arguments (merge-arg-wo-duplicates subjective-arguments comb-memory-argu true)
						set subjective-relations remove-duplicates sentence
							subjective-relations comb-memory-rel
							
							]
						]
		]
	]
  
  ; then agents can share some of their information with agents 
  ; from neighboring networks in the social structures
end


to create-share-memory-test5
  
  ; for each collaborator-network one agent is set to be
  ; the representative agent
  foreach colla-networks [
    ifelse length ? > 1 [
      ask one-of agents with [member? self ?][
        set rep-agent true
      ] 	
    ][
			if ticks mod 25 = 4 [
				ask one-of agents with [member? self ?][
					set rep-agent true
      ]
    ]
    ]
  ]
  
  ; only the representative agents create a memory 
  ; that they want to share with agents from other networks
  ask agents with [rep-agent][
    let myx xcor
    let myy ycor
    ; variables for the argument the agent is currently working on,
    ; the agent itself and the theory it is working on
    let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      and xcor = myx and ycor = myy]
    let cur-agent self 
    let cur-th [mytheory] of cur-argum
    ; create a list of arguments and a list of relations that the agent can
    ; share with agents from other collaborative networks
    ; what agents share depends on the "social-action" and "sharing"
    ; from the interface
    set th-args []
    set th-relations []
    
    ; agents share only information obtained in the neighborhood 
    ; they are currently working on
    ; collect the arguments from the agent's memory
    ; that belong also to the neighborargs
    foreach subjective-arguments [
      if member? item 0 ? [neighborargs] of cur-agent [
        set th-args lput ? th-args
      ]
    ]
    ; collect the relations from/to the current argument
    ; from the agent's memory
    foreach subjective-relations [
      if item 1 ? = cur-argum or item 2 ? = cur-argum [
        set th-relations lput ? th-relations
      ]
    ]
    
    ; if the agent behaves biased it does not share the attack relations that
    ; attack its current theory, these relations are removed
    if social-actions = "biased"[
      foreach th-relations [
        if item 0 ? = "a" and [mytheory] of item 2 ? = cur-th [
          set th-relations remove ? th-relations
        ]
      ]
    ]
  ]
end



; we have the problem here that agents which learn arguments with a older color than the one they already know in their subjective memory pay for them still although they never will include them in their memory
to share-with-other-networks-test5 
  ask agents with [rep-agent][
		if not conference-attended [
			; let share-group-leader self
		
			; variables for the combined information (arguments and relations),
			; the network of the current agent and the theory it is working on
			let comb-memory-argu th-args
			let comb-memory-rel th-relations
			let cur-network sort collaborator-network
			let my-cur-theory [mytheory] of item 0 item 0 th-args
			
			; create a list of the neighboring networks and then a 
			; list of the representative agents of these networks
			; which will be the agents the current agent shares with
			let share-agents []
			let share-neighbors []
			foreach share-structure [    
				if first ? = cur-network [
					set share-neighbors ?
				]
			]
			ask agents with [rep-agent][
				let cur-agent self
				foreach share-neighbors [
					if member? cur-agent ? [
						set share-agents lput cur-agent share-agents
					]
				]
			]
			
			; create a list of arguments and a list of relations that is
			; shared among the share-agents
			foreach share-agents [
				; the combined memory is updated to contain that of the sharing agent
				set comb-memory-argu remove-duplicates sentence comb-memory-argu [th-args] of ?
				set comb-memory-rel remove-duplicates sentence comb-memory-rel [th-relations] of ?		
			]
			; create lists of arguments/relations that have to be added
			foreach share-agents [
				ask ? [
					set to-add-mem-argu comb-memory-argu
					set to-add-mem-rel comb-memory-rel
					set conference-attended true
				]
			]			
		] 
		
		; to compute the time that agents have to
		; spend on communication
	]
	
end




to compute-time-costs-test5 
	ask agents with [rep-agent][
		; variables that contain the arguments and relations the
		; agent has to update in its memory
		let new-memory-args []
		let new-memory-rel []
		let to-add-argu []
		set new-memory-args filter [not member? ? subjective-arguments]
			to-add-mem-argu
		set new-memory-rel filter [not member? ? subjective-relations]
			to-add-mem-rel
		let comb-new sentence new-memory-args new-memory-rel
		; every tick an agent can obtain a maximum of 10 new entries
		; the day that they received information is also lost
		ifelse length comb-new >= (3 * max-learn) [
			set communicating 4
		][
		set communicating ((ceiling (length comb-new / max-learn)) + 1)
		]
		
		; every communication round an agent can update a maximum of 
		; 3 * max-learn new arguments/relations (corresponding to three ticks of
		; communication) these new arguments and relations are added to the
		; memory of the agent
		; when a new relation is added and the arguments are not part of the
		; memory of the agent, these arguments are added as well
		ifelse length comb-new > (3 * max-learn) [
			set comb-new shuffle comb-new
			let repeats length comb-new - (3 * max-learn)
			while [length comb-new > repeats] [
				let cur-entr first comb-new
				let new-mem-argargs filter [member? ? new-memory-args] comb-new
				set new-mem-argargs map [first ?] new-mem-argargs
				ifelse member? cur-entr new-memory-args [
					set to-add-argu lput cur-entr to-add-argu
					set comb-new remove cur-entr comb-new
				][
				set subjective-relations lput cur-entr subjective-relations
				set comb-new remove cur-entr comb-new
				if member? item 1 cur-entr new-mem-argargs[
					let item-1-cur-entr item 1 cur-entr
					foreach comb-new [
						if item-1-cur-entr = item 0 ? [
							set to-add-argu lput ? to-add-argu
							set comb-new remove ? comb-new
						]
					] 
				]
				if member? item 2 cur-entr new-mem-argargs[
					let item-2-cur-entr item 2 cur-entr
					foreach comb-new [
						if item-2-cur-entr = item 0 ? [
							set to-add-argu lput ? to-add-argu
							set comb-new remove ? comb-new
						]
					] 
				]
				]
			]
			set subjective-arguments (merge-arg-wo-duplicates subjective-arguments to-add-argu true)
		][
		set subjective-arguments (merge-arg-wo-duplicates subjective-arguments new-memory-args true)
		set subjective-relations sentence subjective-relations new-memory-rel ;remove duplicates!? bug maybe -> probably no problem b/c remove duplicates for relations is run during "share-with-other-networks" 
		]	
		set conference-attended false
	]
end
