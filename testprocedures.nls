extensions[profiler]

; procedures for probing, testing and giving additional insights into the model.
; experimental: this file is not properly commented


globals [ctiho] ;current-theory(2)-info-hand-over (sorted)

to calc-global-admiss-core [vis] ;vis for visibility
	let new-info []
  let new-cur-info []
  let not-admissible []
	let subjective-arguments2 []
  let args-cur-arguments []
	let admissible-subj-argu2 []
  let attacked-by-me []
	let attack-relations []
	let cur-attacked []
	let cur-attacker []
  let theories []
  ask starts [
    let start-add []
    set start-add lput self start-add
    set start-add lput 0 start-add
    set theories lput start-add theories
  ]
  let current-theory-info2 theories
  ask attacks with [runresult vis] [
		set attack-relations lput self attack-relations
    set cur-attacked lput end2 cur-attacked
    set cur-attacker lput end1 cur-attacker
  ]
  ask turtles with [(breed = starts or breed = arguments) and runresult vis][
   set args-cur-arguments lput self args-cur-arguments
	 set subjective-arguments2 lput self subjective-arguments2
  ]
  foreach current-theory-info2 [
   set new-info lput replace-item 1 ? 0 new-info
  ]
	set current-theory-info2 new-info
 
 ; the computation of the admissible arguments is done recursively
 ; a list of arguments that are currently considered attacked
	let open-rec []
    ; variable that lets the loop run at least one time
  let i 0
  foreach current-theory-info2 [
  ; the theory that is considered in this loop
  ; and the root of that theory (the start)
		let cur-theory ?
    let askstart item 0 cur-theory
    while [ i < 1 or not empty? open-rec][
			set not-admissible sentence not-admissible open-rec
      set open-rec []
      set attacked-by-me []
        
      ; create a list of arguments that are attacked by the current theory
      ; based on the memory of the current agent
      if not empty? attack-relations [
				ask turtles with [member? self args-cur-arguments and mytheory = askstart][
					if member? self cur-attacker and not member? self not-admissible [
					; the argument considered and a list of arguments
					; attacked by that argument
						let cur-turtle self
						let my-attacked []
						foreach attack-relations [
							if [end1] of ? = cur-turtle [
								set my-attacked lput [end2] of ? my-attacked
							]
						]
						set attacked-by-me sentence my-attacked attacked-by-me
					]
				]
          
        ; arguments that are attacked by arguments from another theory that are
        ; not attacked by non-attacked arguments from the current theory
        ; are added to the open-rec list, the list of attacked-arguments
        ask turtles with [member? self args-cur-arguments and mytheory = askstart and not member? self not-admissible and member? self cur-attacked][
          let cur-turtle self
          foreach attack-relations [
            if [end2] of ? = cur-turtle [
              if not member? [end1] of ? attacked-by-me [
                set open-rec lput cur-turtle open-rec
              ]
            ]
          ]
        ]
      ]
      set i i + 1
    ]
    set i 0
      
    ; for the update of the information in current-theory-info
    set new-cur-info lput replace-item 1 cur-theory (count turtles with [member? self args-cur-arguments and mytheory = askstart] - count turtles with [member? self not-admissible and mytheory = askstart]) new-cur-info
  ]
    
    ; arguments that are part of the not-admissible list
    ; are not part of the admissible subjective arguments and hence removed
    set admissible-subj-argu2 subjective-arguments2
    foreach subjective-arguments2 [
			let cur-argu ?
			if member? cur-argu not-admissible [
				set admissible-subj-argu2 remove cur-argu admissible-subj-argu2
			]
		]
		
    ; update the current-theory-info
    set current-theory-info2 new-cur-info
		set ctiho sort-by [item 0 ? < item 0 ?2] current-theory-info2
end




; cadmis= calc-admissibility input can be red for the discovered landscape or
; anything else (e.g. 1) for the general landscape
to cadmis [input] 
	ifelse input = red [
		calc-global-admiss-core task [color != gray]
	][
		calc-global-admiss-core task [true]
	]
end



; prints the admissibility input the same as for cadmis (gets handed over)
to cadmisp [input]
	cadmis input
	print ctiho
end



; prints the admissibility of theory 170 - 85
to compare-two-with-three [times]
	repeat times [
		setup
		cadmis 1
		print (item 1 item 2 ctiho - item 1 item 1 ctiho)
	]
end



to test1
	let cur-attacked []
	ask attacks [
		set cur-attacked lput end2 cur-attacked
	]
  print cur-attacked
	
end

to test2 ; one random agent shows her attack-relations
  ask one-of agents [
    ; variables for lists that contain:
    ; the current-theory-info with 0 admissible arguments; an updated number
    ; of admissible arguments during the recursive computation; the arguments
    ; that are not admissible; the arguments that the agents knows about; and
    ; the arguments that are attacked by the current theory 
    let new-info []
    let new-cur-info []
    let not-admissible []
    let args-cur-arguments []
    let attacked-by-me []
    
    ; create a list of only the attacks
    let attack-relations []
    foreach subjective-relations [
      if first ? = "a" [
        set attack-relations lput ? attack-relations
      ]
    ]
		show attack-relations
    ; create lists of attacked and attacking arguments
    let cur-attacked []
    let cur-attacker []
    foreach attack-relations [
      set cur-attacked lput last ? cur-attacked
      set cur-attacker lput first but-first ? cur-attacker
    ]
    
    ; create a list of the arguments the agents knows about and 
    ; set the number of admissible arguments for each theory to 0
    foreach subjective-arguments [
      set args-cur-arguments lput first ? args-cur-arguments
    ]
    foreach current-theory-info [
      set new-info lput replace-item 1 ? 0 new-info
    ]
    set current-theory-info new-info
    
    ; the computation of the admissible arguments is done recursively
    ; a list of arguments that are currently considered attacked
    let open-rec []
    ; variable that lets the loop run at least one time
    let i 0
    foreach current-theory-info [
      ; the theory that is considered in this loop
      ; and the root of that theory (the start)
      let cur-theory ?
      let askstart item 0 cur-theory
      while [ i < 1 or not empty? open-rec][
        set not-admissible sentence not-admissible open-rec
        set open-rec []
        set attacked-by-me []
        
        ; create a list of arguments that are attacked by the current theory
        ; based on the memory of the current agent
        if not empty? attack-relations [
          ask turtles with [member? self args-cur-arguments and
	        mytheory = askstart][
            if member? self cur-attacker and not member? self not-admissible [
              ; the argument considered and a list of arguments
              ; attacked by that argument
              let cur-turtle self
              let my-attacked []
              foreach attack-relations [
                if first but-first ? = cur-turtle [
                  set my-attacked lput last ? my-attacked
                ]
              ]
              set attacked-by-me sentence my-attacked attacked-by-me
            ]
          ]
          
          ; arguments that are attacked by arguments from another theory that are
          ; not attacked by non-attacked arguments from the current theory
          ; are added to the open-rec list, the list of attacked-arguments
          ask turtles with [member? self args-cur-arguments and
	          mytheory = askstart and not member? self not-admissible and
	          member? self cur-attacked][
          let cur-turtle self
          foreach attack-relations [
            if last ? = cur-turtle [
              if not member? last but-last ? attacked-by-me [
                set open-rec lput cur-turtle open-rec
              ]
            ]
          ]
            ]
        ]
        set i i + 1
      ]
      set i 0
      
      ; for the update of the information in current-theory-info
      set new-cur-info lput replace-item 1 cur-theory (count turtles with
        [member? self args-cur-arguments and mytheory = askstart] -
	      count turtles with [member? self not-admissible and mytheory = askstart])
	        new-cur-info
    ]
    
    ; arguments that are part of the not-admissible list
    ; are not part of the admissible subjective arguments and hence removed
    set admissible-subj-argu subjective-arguments
    foreach subjective-arguments [
      let cur-argu ?
      if member? first cur-argu not-admissible [
        set admissible-subj-argu remove cur-argu admissible-subj-argu
      ]
    ]
    ; update the current-theory-info
    set current-theory-info new-cur-info
  ]
end

to test3 [input]
	ifelse input = red [
		calc-global-admiss-core task [color != gray]
	][
		calc-global-admiss-core task [true]
	]
end

to test4 [input1]
	ask attacks with [runresult input1] [print self]
end

; performs the setup times often and each time shows the admissibility for
; all theories
to test5 [times]
	repeat times [
		setup
		cadmisp 1
	]
end


; setup for the errorneous attack-relations
to setup-test-error
	clear-all
  initialize-hidden-variables
  create-discovery-landscape number-of-theories theory-depth
  define-attack-relation-error
  distribute-agents scientists
  reset-ticks
end


to define-attack-relation-error
  ; first the random attacks are defined
  define-attack-relation-create-attacks-error
  
  ; then the best theory defends itself
  define-attack-relation-defend-best
  
  ; the arguments and relations are spread over the patches
  define-attack-relation-visualize
end


to define-attack-relation-create-attacks-error
  ask turtles with [breed = starts or breed = arguments][
    ; variables for the current argument, the theory it belongs to,
    ; a random number between 0.00 and 1.00 and a list of theories
    let askargu self
    let curtheory mytheory
    let attack-random random-float 1.00
    let starts-list []
    ask starts [
      set starts-list lput who starts-list
    ]
    set starts-list sort starts-list
    
    ; with attack-probability-2nd from the interface an attack towards
    ; the current argument is created
    ifelse number-of-theories = 2[
      if attack-random < attack-probability-2nd and curtheory != start 0 [
        create-attack-from one-of other turtles with [(breed = starts or
	      breed = arguments)and mytheory != curtheory and not
	      (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
	      out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        set color gray
            ]
      ]
    ][
    
    ; when there are three theories both attack-probability-2nd and -3rd are
    ; considered to create attacks, depending on the theory the current argument
    ; belongs to first for the third theory
    ifelse [who] of curtheory = max starts-list and attack-random <
      attack-probability-3rd [
      create-attack-to one-of other turtles with [(breed = starts or
        breed = arguments) and mytheory != curtheory and not
	      (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
	      out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        set color gray
          ]
    ][
    ; then attacks towards arguments of the 2nd theory are created
    if [who] of curtheory != max starts-list and curtheory != start 0 and
      attack-random < attack-probability-2nd [
      create-attack-from one-of other turtles with [(breed = starts or
      breed = arguments) and mytheory != curtheory and not
      (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
	    out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        set color gray
          ]
    ]
    ]
    ]
    
    ; if the current argument belongs to the objective best theory
    ; an attack towards this argument is created with attack-probability-best
    if attack-random < attack-probability-best and curtheory = start 0 [
      create-attack-from one-of other turtles with [(breed = starts or
      breed = arguments) and mytheory != curtheory and not
	    (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
	    out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        set color gray
          ]
    ]
  ]
end

to compare-error-with-new [times]
	repeat times [
		setup
		cadmis 1
		print (word "fixed:      " ctiho " #attacks: "count attacks)
		setup-test-error
		cadmis 1
		print (word "errorneous: " ctiho " #attacks: "count attacks)
	]
end

to compare-error-with-new-statistics [times]
	repeat times [
		file-open "testprocedure_adm_fixed.txt"
		setup
		cadmis 1
		file-print (word item 1 item 1 ctiho " " item 1 item 2 ctiho)
		file-open "testprocedure_attack_fixed.txt"
		file-print count attacks
		file-open "testprocedure_adm_error.txt"
		setup-test-error
		cadmis 1
		file-print (word item 1 item 1 ctiho " " item 1 item 2 ctiho)
		file-open "testprocedure_attack_error.txt"
		file-print count attacks
	]
	file-close-all
end


to check-full-adm [times]
	file-open "testprocedure_full_adm.txt"
	repeat times [
		setup
		cadmis 1
		file-print item 1 item 0 ctiho
	]
	file-close-all
end

to test6 
	let i 0
	repeat 10 [
		set i (i + 1)
	]
	print i
end

to profile [repetitions]               
	profiler:start         ;; start profiling
	repeat repetitions [ go ]       ;; run something you want to measure
	profiler:stop          ;; stop profiling
	print profiler:report  ;; view the results
	profiler:reset         ;; clear the data
end

to profilet [repetitions]               
	profiler:start         ;; start profiling
	repeat repetitions [ go-test ]       ;; run something you want to measure
	profiler:stop          ;; stop profiling
	print profiler:report  ;; view the results
	profiler:reset         ;; clear the data
end

; procedure that removes all duplicates from the memory of an agent
; duplicates also include arguments that are part of the memory with
; different colors in these cases only the entry with the lowest color value
; is kept these arguments are furthest researched
to duplicate-remover-test
  ask agents [
    ; list of arguments of which the duplicates will be removed
    let new-args subjective-arguments
    foreach new-args [
      ; the argument of the current entry and its color
      let argu first ?
      let my-color first but-first ?
      ; list of entries with the same argument, but maybe different color
      let color-argu filter [first ? = argu] new-args
      ; remove entries of arguments that are also present as
      ; better researched entries
      set color-argu sort-by [first but-first ?1 < first but-first ?2] color-argu
      while [length color-argu != 1] [
				show "idiots!"
				show (word "last a list: ")
				analize-list lastalist
				show (word "last b list: ")
				analize-list lastblist
				show (word "last a list after: ")
				analize-list lastalistafter
        set new-args remove last color-argu new-args
        set color-argu but-last color-argu
      ]
    ]
    ; update the agent's memory
    set subjective-arguments new-args
  ]
end

to analize-list [inputlist]
	foreach inputlist [
		let temp ?
		foreach temp [
		show ?
		]
		show ""
	]
end

to update-memories-test
  ask agents [
    let myx xcor
    let myy ycor
    let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      and xcor = myx and ycor = myy]
    let cur-agent self
    ; information of current argument in the format of the memory
    let add-cur (sentence cur-argum [color] of cur-argum)
;    set subjective-arguments lput add-cur subjective-arguments
    ; list of relations (resp. arguments) that are added
    let to-add []
		let to-add-argu []
    set to-add-argu lput add-cur to-add-argu
    ; list of neighborhood arguments of the current argument
    set neighborargs []
    set neighborargs lput cur-argum neighborargs
    
    ; for the current argument
    ; add the neighboring discovered arguments and relations
    ; (attacks and discovery) to a to-add list
    ask cur-argum [
       if any? my-in-discoveries with [color != gray][
        ask my-in-discoveries with [color != gray][
          let add-other-end other-end
          ask cur-agent [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added discovery relation
          let add-rel []
          set add-rel lput "d" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
      
      ; add the child argument of the discovery relation
      if any? my-out-discoveries with [color != gray][
        ask my-out-discoveries with [color != gray][
	  let add-other-end other-end
	  ask cur-agent [
	    set neighborargs lput add-other-end neighborargs
	  ]
	  ; construction of the to be added discovery relation
	  let add-rel []
	  set add-rel lput "d" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput add-other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
     
      ; add the parent argument of the attack relation
      if any? my-in-attacks with [color != gray][
        ask my-in-attacks with [color != gray][
          let add-other-end other-end
          ask cur-agent [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
      
      ; add the child argument of the attack relation
      if any? my-out-attacks with [color != gray][
        ask my-out-attacks with [color != gray][
          let add-other-end other-end
          ask cur-agent [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
    ]
    
    ; remove duplicates from the list
    set subjective-relations remove-duplicates sentence
      subjective-relations to-add
		; show subjective-arguments	
		; foreach to-add-argu [
			; let argu first ?
			; ; show ?
			; let my-color first but-first ?
			; ; list of entries with the same argument, but maybe different color
			; let argu-old filter [first ? = argu] subjective-arguments
			; ; show argu-old
			; if not empty? argu-old [
				; set argu-old item 0 argu-old
				; if my-color < item 1 argu-old [
					; let argument-position position argu-old subjective-arguments
					; ; show argument-position
					; ; remove entries of arguments that are also present as
					; ; better researched entries
					; ; set color-argu sort-by [first but-first ?1 < first but-first ?2] color-argu 
					; if argument-position != false [
						
						; ; show (word "replacing position " argument-position " with " ?)
						; set subjective-arguments replace-item argument-position subjective-arguments ?
					; ]
				; ]
				; if my-color > item 1 argu-old [
							; show "plausi check error new arg is older"
				; ]
			; ]
		; ]
    ; set subjective-arguments remove-duplicates sentence
      ; subjective-arguments to-add-argu
		; ; show subjective-arguments
	set subjective-arguments (merge-arg-wo-duplicates subjective-arguments to-add-argu false)
  ]
  
  ; every 5 plus 4 time-steps the collected information
  ; is shared with other agents
  if ticks mod 5 = 4 [
   share-with-others-test
  ] 
  
end

to-report merge-arg-wo-duplicates [alist blist flag]

	if flag [
		set blist remove-duplicates blist
	]
	; set lastalist lput alist lastalist
	; set lastblist lput blist lastblist
	; if length lastalist > 2 [
		; set lastalist remove-item 0 lastalist
	; ]
	; if length lastblist > 2 [
		; set lastblist remove-item 0 lastblist
	; ]
	foreach blist [
		let argu first ?
		; show ?
		let my-color first but-first ?
		; list of entries with the same argument, but maybe different color
		let duplicate-check filter [first ? = argu] blist
		if flag [
			foreach duplicate-check [
				if item 1 ? > my-color [
					set blist remove ? blist
				]
			]
		]
		let argu-old filter [first ? = argu] alist
		; show argu-old
		if not empty? argu-old [
			set argu-old item 0 argu-old
			
			if my-color < item 1 argu-old [		
			let argument-position position argu-old alist			
				; show argument-position
				; remove entries of arguments that are also present as
				; better researched entries
				; set color-argu sort-by [first but-first ?1 < first but-first ?2] color-argu 
				if argument-position != false [
					
					; show (word "replacing position " argument-position " with " ?)
					set alist replace-item argument-position alist ?
				]
			]
			if my-color >= item 1 argu-old [
				set blist remove ? blist
				;show (word my-color " " item 1 argu-old)
				;show (word "removed " ? " from " blist)
				; let argument-position position argu-old blist
				; set blist remove-item argument-position blist
				;set blist replace-item argument-position blist 
			]
		]
	]
  set alist remove-duplicates sentence
      alist blist
	
	; set lastalistafter lput alist lastalistafter
	; if length lastalistafter > 2 [
		; set lastalistafter remove-item 0 lastalistafter
	; ]
	report alist
end

to go-test
  update-memories-test
	; if ticks mod 10 = 4 [
		; duplicate-remover-test
	; ]  
  if ticks mod 5 = 4 [
    compute-strategies-agents
    act-on-strategy-agents
  ]
  move-around
  update-landscape
  compute-popularity
  tick
end

to go-stop-test
	setuprs new-seed
	go-test
	while [any? arguments with [
	color != red and [myscientists] of mytheory !=  0
	]
	][
		go-test
	]
end

to setuprs [rs]
  clear-all
  random-seed rs
	print (word "random seed: " rs)
  initialize-hidden-variables
  create-discovery-landscape number-of-theories theory-depth
  define-attack-relation
  distribute-agents scientists
  reset-ticks
	ask agents [
		set lastalist []
		set lastblist []
		set lastalistafter []
	]	
end


to share-with-others-test
  ask agents [
    ; reset the variables
    set rep-agent false 
    set to-add-mem-argu []
    set to-add-mem-rel []
    
    ; variables to keep track of the current agents own memory
    ; and the combined memory of all the sharing agents
    ; let own-memory-argu subjective-arguments
    ; let own-memory-rel subjective-relations
    let comb-memory-argu []
    let comb-memory-rel []
    ; collaborator network of the current agent
    let cur-network collaborator-network
    
    ; the information in the memories of the single agents in the network
    ; are combined 
    ask turtles with [member? self cur-network] [
      set comb-memory-argu sentence subjective-arguments comb-memory-argu
      set comb-memory-rel sentence subjective-relations comb-memory-rel
    ]
    
    ; each agent adds the combined memory to its own
    ; then removing duplicates
		set subjective-arguments (merge-arg-wo-duplicates subjective-arguments comb-memory-argu true)
    set subjective-relations remove-duplicates sentence
      subjective-relations comb-memory-rel
  ]
  
  ; then agents can share some of their information with agents 
  ; from neighboring networks in the social structures
  create-share-memory-test
  share-with-other-networks-test
  
end




to create-share-memory-test
  
  ; for each collaborator-network one agent is set to be
  ; the representative agent
  foreach colla-networks [
    ifelse length ? > 1 [
      ask one-of agents with [member? self ?][
        set rep-agent true
      ] 	
    ][
    if ticks mod 25 = 4 [
      ask one-of agents with [member? self ?][
        set rep-agent true
      ]
    ]
    ]
  ]
  
  ; only the representative agents create a memory 
  ; that they want to share with agents from other networks
  ask agents with [rep-agent][
    let myx xcor
    let myy ycor
    ; variables for the argument the agent is currently working on,
    ; the agent itself and the theory it is working on
    let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      and xcor = myx and ycor = myy]
    let cur-agent self 
    let cur-th [mytheory] of cur-argum
    ; create a list of arguments and a list of relations that the agent can
    ; share with agents from other collaborative networks
    ; what agents share depends on the "social-action" and "sharing"
    ; from the interface
    set th-args []
    set th-relations []
    
    ; agents share only information obtained in the neighborhood 
    ; they are currently working on
    ; collect the arguments from the agent's memory
    ; that belong also to the neighborargs
    foreach subjective-arguments [
      if member? item 0 ? [neighborargs] of cur-agent [
        set th-args lput ? th-args
      ]
    ]
    ; collect the relations from/to the current argument
    ; from the agent's memory
    foreach subjective-relations [
      if item 1 ? = cur-argum or item 2 ? = cur-argum [
        set th-relations lput ? th-relations
      ]
    ]
    
    ; if the agent behaves biased it does not share the attack relations that
    ; attack its current theory, these relations are removed
    if social-actions = "biased"[
      foreach th-relations [
        if item 0 ? = "a" and [mytheory] of item 2 ? = cur-th [
          set th-relations remove ? th-relations
        ]
      ]
    ]
  ]
end




to share-with-other-networks-test 
  ask agents with [rep-agent][
    ; variables for the combined information (arguments and relations),
    ; the network of the current agent and the theory it is working on
    let comb-memory-argu th-args
    let comb-memory-rel th-relations
    let cur-network sort collaborator-network
    let my-cur-theory [mytheory] of item 0 item 0 th-args
    
    ; create a list of the neighboring networks and then a 
    ; list of the representative agents of these networks
    ; which will be the agents the current agent shares with
    let share-agents []
    let share-neighbors []
    foreach share-structure [    
      if first ? = cur-network [
        set share-neighbors ?
      ]
    ]
    ask agents with [rep-agent][
      let cur-agent self
      foreach share-neighbors [
        if member? cur-agent ? [
          set share-agents lput cur-agent share-agents
        ]
      ]
    ]
    
    ; create a list of arguments and a list of relations that is
    ; shared among the share-agents
    foreach share-agents [
      ; the combined memory is updated to contain that of the sharing agent
      set comb-memory-argu sentence comb-memory-argu [th-args] of ?
      set comb-memory-rel sentence comb-memory-rel [th-relations] of ?
    ]
    ; create lists of arguments/relations that have to be added
    foreach share-agents [
      set to-add-mem-argu remove-duplicates sentence subjective-arguments
        comb-memory-argu
      set to-add-mem-rel remove-duplicates sentence subjective-relations
        comb-memory-rel
    ]
  ] 
  
  ; to compute the time that agents have to
  ; spend on communication
  compute-time-costs-test 
end



to compute-time-costs-test
  ask agents with [rep-agent][
    
    ; variables that contain the arguments and relations the
    ; agent has to update in its memory
    let new-memory-args []
    let new-memory-rel []
		let to-add-argu []
    set new-memory-args filter [not member? ? subjective-arguments]
      to-add-mem-argu
    set new-memory-rel filter [not member? ? subjective-relations]
      to-add-mem-rel
    let comb-new sentence new-memory-args new-memory-rel
    ; every tick an agent can obtain a maximum of 10 new entries
    ; the day that they received information is also lost
    ifelse length comb-new >= (3 * max-learn) [
      set communicating 4
    ][
    set communicating ((ceiling (length comb-new / max-learn)) + 1)
    ]
    
    ; every communication round an agent can update a maximum of 
    ; 3 * max-learn new arguments/relations (corresponding to three ticks of
    ; communication) these new arguments and relations are added to the
    ; memory of the agent
    ; when a new relation is added and the arguments are not part of the
    ; memory of the agent, these arguments are added as well
    ifelse length comb-new > (3 * max-learn) [
      set comb-new shuffle comb-new
      let repeats length comb-new - (3 * max-learn)
      while [length comb-new > repeats] [
        let cur-entr first comb-new
        let new-mem-argargs filter [member? ? new-memory-args] comb-new
        set new-mem-argargs map [first ?] new-mem-argargs
        ifelse member? cur-entr new-memory-args [
          set to-add-argu lput cur-entr to-add-argu
          set comb-new remove cur-entr comb-new
        ][
        set subjective-relations lput cur-entr subjective-relations
        set comb-new remove cur-entr comb-new
        if member? item 1 cur-entr new-mem-argargs[
          let item-1-cur-entr item 1 cur-entr
          foreach comb-new [
            if item-1-cur-entr = item 0 ? [
              set to-add-argu lput ? to-add-argu
              set comb-new remove ? comb-new
            ]
          ] 
        ]
        if member? item 2 cur-entr new-mem-argargs[
          let item-2-cur-entr item 2 cur-entr
          foreach comb-new [
            if item-2-cur-entr = item 0 ? [
              set to-add-argu lput ? to-add-argu
              set comb-new remove ? comb-new
            ]
          ] 
        ]
        ]
      ]
			set subjective-arguments (merge-arg-wo-duplicates subjective-arguments to-add-argu true)
    ][
		set subjective-arguments (merge-arg-wo-duplicates subjective-arguments new-memory-args true)
    set subjective-relations sentence subjective-relations new-memory-rel ;remove duplicates!? bug maybe
    ]
  ]
end


to bla [times]
	repeat times [go-test]
end