extensions [profiler]

; procedures for probing, testing and giving additional insights into the model.
; experimental: this file is not properly commented


globals [ctiho ctiho2 ctiho-old ctiho-new ctiho-diff rndseed update-mem-every-tick? ] ;current-theory(2)-info-hand-over (sorted)

to startup
  set rndseed []
end

to calc-global-admiss-core [vis] ;vis for visibility
  let new-info []
  let new-cur-info []
  let not-admissible []
  let subjective-arguments2 []
  let args-cur-arguments []
  let admissible-subj-argu2 []
  let attacked-by-me []
  let attack-relations []
  let cur-attacked []
  let cur-attacker []
  let theories []
  ask starts [
    let start-add []
    set start-add lput self start-add
    set start-add lput 0 start-add
    set theories lput start-add theories
  ]
  let current-theory-info2 theories
  ask attacks with [runresult vis] [
    set attack-relations lput self attack-relations
    set cur-attacked lput end2 cur-attacked
    set cur-attacker lput end1 cur-attacker
  ]
  ; ask startsargum with [runresult vis][
   ; set args-cur-arguments lput self args-cur-arguments
   ; set subjective-arguments2 lput self subjective-arguments2
  ; ]
  let args-cur-arguments-as startsargum with [runresult vis]
  set subjective-arguments2 sort args-cur-arguments-as
  set args-cur-arguments subjective-arguments2 ; not really needed anymore
  foreach current-theory-info2 [ [?1] ->
   set new-info lput replace-item 1 ?1 0 new-info
  ]
  set current-theory-info2 new-info

 ; the computation of the admissible arguments is done recursively
 ; a list of arguments that are currently considered attacked
  let open-rec []
    ; variable that lets the loop run at least one time
  let i 0
  foreach current-theory-info2 [ [?1] ->
  ; the theory that is considered in this loop
  ; and the root of that theory (the start)
    let cur-theory ?1
    let askstart item 0 cur-theory
    while [ i < 1 or not empty? open-rec][
      set not-admissible sentence not-admissible open-rec
      set open-rec []
      set attacked-by-me []

      ; create a list of arguments that are attacked by the current theory
      ; based on the memory of the current researcher
      if not empty? attack-relations [
        ask args-cur-arguments-as with [mytheory = askstart][
          if member? self cur-attacker and not member? self not-admissible [
          ; the argument considered and a list of arguments
          ; attacked by that argument
            let cur-turtle self
            let my-attacked []
            foreach attack-relations [ [??1] ->
              if [end1] of ??1 = cur-turtle [
                set my-attacked lput [end2] of ??1 my-attacked
              ]
             ]
            set attacked-by-me sentence my-attacked attacked-by-me
          ]
        ]

        ; arguments that are attacked by arguments from another theory that are
        ; not attacked by non-attacked arguments from the current theory
        ; are added to the open-rec list, the list of attacked-arguments
        ask args-cur-arguments-as with [mytheory = askstart and not member? self not-admissible and member? self cur-attacked][
          let cur-turtle self
          foreach attack-relations [ [??1] ->
            if [end2] of ??1 = cur-turtle [
              if not member? [end1] of ??1 attacked-by-me [
                set open-rec lput cur-turtle open-rec
              ]
            ]
          ]
        ]
      ]
      set i i + 1
    ]
    set i 0

    ; for the update of the information in current-theory-info
    set new-cur-info lput replace-item 1 cur-theory (count args-cur-arguments-as with [mytheory = askstart] - count args-cur-arguments-as with [mytheory = askstart and member? self not-admissible]) new-cur-info
  ]

    ; arguments that are part of the not-admissible list
    ; are not part of the admissible subjective arguments and hence removed
    set admissible-subj-argu2 subjective-arguments2
    foreach subjective-arguments2 [ [?1] ->
      let cur-argu ?1
      if member? cur-argu not-admissible [
        set admissible-subj-argu2 remove cur-argu admissible-subj-argu2
      ]
     ]

    ; update the current-theory-info
    set current-theory-info2 new-cur-info
    set ctiho sort-by [ [?1 ?2] -> item 0 ?1 < item 0 ?2 ] current-theory-info2
end


; cadmis= calc-admissibility input can be red for the discovered landscape or
; anything else (e.g. 1) for the general landscape
to cadmis [input]
  ifelse input = red [
    calc-global-admiss-core [ [] -> color != gray ]
  ][
    calc-global-admiss-core [ [] -> true ]
  ]
end



; prints the admissibility input the same as for cadmis (gets handed over)
to cadmisp [input]
  cadmis input
  print ctiho
end



; prints the admissibility of theory 170 - 85
to compare-two-with-three [times]
  repeat times [
    setup
    cadmis 1
    print (item 1 item 2 ctiho - item 1 item 1 ctiho)
  ]
end



to test1
  let cur-attacked []
  ask attacks [
    set cur-attacked lput end2 cur-attacked
  ]
  print cur-attacked

end

to test2 ; one random researcher shows her attack-relations
  ask one-of researchers [
    ; variables for lists that contain:
    ; the current-theory-info with 0 admissible arguments; an updated number
    ; of admissible arguments during the recursive computation; the arguments
    ; that are not admissible; the arguments that the researchers knows about; and
    ; the arguments that are attacked by the current theory
    let new-info []
    let new-cur-info []
    let not-admissible []
    let args-cur-arguments []
    let attacked-by-me []

    ; create a list of only the attacks
    let attack-relations []
    foreach subjective-relations [ [?1] ->
      if first ?1 = "a" [
        set attack-relations lput ?1 attack-relations
      ]
    ]
    show attack-relations
    ; create lists of attacked and attacking arguments
    let cur-attacked []
    let cur-attacker []
    foreach attack-relations [ [?1] ->
      set cur-attacked lput last ?1 cur-attacked
      set cur-attacker lput first but-first ?1 cur-attacker
    ]

    ; create a list of the arguments the researchers knows about and
    ; set the number of admissible arguments for each theory to 0
    foreach subjective-arguments [ [?1] ->
      set args-cur-arguments lput first ?1 args-cur-arguments
    ]
    foreach current-theory-info [ [?1] ->
      set new-info lput replace-item 1 ?1 0 new-info
    ]
    set current-theory-info new-info

    ; the computation of the admissible arguments is done recursively
    ; a list of arguments that are currently considered attacked
    let open-rec []
    ; variable that lets the loop run at least one time
    let i 0
    foreach current-theory-info [ [?1] ->
      ; the theory that is considered in this loop
      ; and the root of that theory (the start)
      let cur-theory ?1
      let askstart item 0 cur-theory
      while [ i < 1 or not empty? open-rec][
        set not-admissible sentence not-admissible open-rec
        set open-rec []
        set attacked-by-me []

        ; create a list of arguments that are attacked by the current theory
        ; based on the memory of the current researcher
        if not empty? attack-relations [
          ask turtles with [member? self args-cur-arguments and
          mytheory = askstart][
            if member? self cur-attacker and not member? self not-admissible [
              ; the argument considered and a list of arguments
              ; attacked by that argument
              let cur-turtle self
              let my-attacked []
              foreach attack-relations [ [??1] ->
                if first but-first ??1 = cur-turtle [
                  set my-attacked lput last ??1 my-attacked
                ]
              ]
              set attacked-by-me sentence my-attacked attacked-by-me
            ]
          ]

          ; arguments that are attacked by arguments from another theory that are
          ; not attacked by non-attacked arguments from the current theory
          ; are added to the open-rec list, the list of attacked-arguments
          ask turtles with [member? self args-cur-arguments and
            mytheory = askstart and not member? self not-admissible and
            member? self cur-attacked][
          let cur-turtle self
          foreach attack-relations [ [??1] ->
            if last ??1 = cur-turtle [
              if not member? last but-last ??1 attacked-by-me [
                set open-rec lput cur-turtle open-rec
              ]
            ]
          ]
            ]
        ]
        set i i + 1
      ]
      set i 0

      ; for the update of the information in current-theory-info
      set new-cur-info lput replace-item 1 cur-theory (count turtles with
        [member? self args-cur-arguments and mytheory = askstart] -
        count turtles with [member? self not-admissible and mytheory = askstart])
          new-cur-info
    ]

    ; arguments that are part of the not-admissible list
    ; are not part of the admissible subjective arguments and hence removed
    set admissible-subj-argu subjective-arguments
    foreach subjective-arguments [ [?1] ->
      let cur-argu ?1
      if member? first cur-argu not-admissible [
        set admissible-subj-argu remove cur-argu admissible-subj-argu
      ]
    ]
    ; update the current-theory-info
    set current-theory-info new-cur-info
  ]
end

to test3 [input]
  ifelse input = red [
    calc-global-admiss-core [ [] -> color != gray ]
  ][
    calc-global-admiss-core [ [] -> true ]
  ]
end

to test4 [input1]
  ask attacks with [runresult input1] [print self]
end

; performs the setup times often and each time shows the admissibility for
; all theories
to test5 [times]
  repeat times [
    setup
    cadmisp 1
  ]
end


; setup for the errorneous attack-relations
; to setup-test-error
  ; clear-all
  ; initialize-hidden-variables
  ; create-discovery-landscape number-of-theories theory-depth
  ; define-attack-relation-error
  ; distribute-researchers scientists
  ; reset-ticks
; end


; to define-attack-relation-error
  ; ; first the random attacks are defined
  ; define-attack-relation-create-attacks-error

  ; ; then the best theory defends itself
  ; define-attack-relation-defend-best

  ; ; the arguments and relations are spread over the patches
  ; define-attack-relation-visualize
; end


; to define-attack-relation-create-attacks-error
  ; ask turtles with [breed = starts or breed = arguments][
    ; ; variables for the current argument, the theory it belongs to,
    ; ; a random number between 0.00 and 1.00 and a list of theories
    ; let askargu self
    ; let curtheory mytheory
    ; let attack-random random-float 1.00
    ; let starts-list []
    ; ask starts [
      ; set starts-list lput who starts-list
    ; ]
    ; set starts-list sort starts-list

    ; ; with attack-probability-2nd from the interface an attack towards
    ; ; the current argument is created
    ; ifelse number-of-theories = 2[
      ; if attack-random < attack-probability-2nd and curtheory != start 0 [
        ; create-attack-from one-of other turtles with [(breed = starts or
        ; breed = arguments)and mytheory != curtheory and not
        ; (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
        ; out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        ; set color gray
            ; ]
      ; ]
    ; ][

    ; ; when there are three theories both attack-probability-2nd and -3rd are
    ; ; considered to create attacks, depending on the theory the current argument
    ; ; belongs to first for the third theory
    ; ifelse [who] of curtheory = max starts-list and attack-random <
      ; attack-probability-3rd [
      ; create-attack-to one-of other turtles with [(breed = starts or
        ; breed = arguments) and mytheory != curtheory and not
        ; (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
        ; out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        ; set color gray
          ; ]
    ; ][
    ; ; then attacks towards arguments of the 2nd theory are created
    ; if [who] of curtheory != max starts-list and curtheory != start 0 and
      ; attack-random < attack-probability-2nd [
      ; create-attack-from one-of other turtles with [(breed = starts or
      ; breed = arguments) and mytheory != curtheory and not
      ; (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
      ; out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        ; set color gray
          ; ]
    ; ]
    ; ]
    ; ]

    ; ; if the current argument belongs to the objective best theory
    ; ; an attack towards this argument is created with attack-probability-best
    ; if attack-random < attack-probability-best and curtheory = start 0 [
      ; create-attack-from one-of other turtles with [(breed = starts or
      ; breed = arguments) and mytheory != curtheory and not
      ; (in-discovery-neighbor? askargu or in-attack-neighbor? askargu or
      ; out-discovery-neighbor? askargu or out-attack-neighbor? askargu)][
        ; set color gray
          ; ]
    ; ]
  ; ]
; end

; to compare-error-with-new [times]
  ; repeat times [
    ; setup
    ; cadmis 1
    ; print (word "fixed:      " ctiho " #attacks: "count attacks)
    ; setup-test-error
    ; cadmis 1
    ; print (word "errorneous: " ctiho " #attacks: "count attacks)
  ; ]
; end

; to compare-error-with-new-statistics [times]
  ; repeat times [
    ; file-open "testprocedure_adm_fixed.txt"
    ; setup
    ; cadmis 1
    ; file-print (word item 1 item 1 ctiho " " item 1 item 2 ctiho)
    ; file-open "testprocedure_attack_fixed.txt"
    ; file-print count attacks
    ; file-open "testprocedure_adm_error.txt"
    ; setup-test-error
    ; cadmis 1
    ; file-print (word item 1 item 1 ctiho " " item 1 item 2 ctiho)
    ; file-open "testprocedure_attack_error.txt"
    ; file-print count attacks
  ; ]
  ; file-close-all
; end


to check-full-adm [times]
  file-open "testprocedure_full_adm.txt"
  repeat times [
    setup
    cadmis 1
    file-print item 1 item 0 ctiho
  ]
  file-close-all
end

to test6
  let i 0
  repeat 10 [
    set i (i + 1)
  ]
  print i
end

to profilecore [repetitions go-version]
  profiler:start         ;; start profiling
  repeat repetitions [ run go-version ]       ;; run something you want to measure
  profiler:stop          ;; stop profiling
  print profiler:report  ;; view the results
  profiler:reset         ;; clear the data
end

to profile [repetitions version]
  let go-version 0
  if version = "old" [set go-version [ [] -> go-old ]]
  if version = "v1" [set go-version [ [] -> go-test-v1 ]]
  if version = "v2" [set go-version [ [] -> go-test-v2 ]]
  if version = "v31" [set go-version [ [] -> go-test-v31 ]]
  if version = "v32" [set go-version [ [] -> go-test-v32 ]]
  if version = "old3" [set go-version [ [] -> go-test-oldv3 ]]
  if version = "v41" [set go-version [ [] -> go-test-v41 ]]
  if version = "v51" [set go-version [ [] -> go-test-v51 ]]
  if version = "v61" [set go-version [ [] -> go-test-v61 ]]
  if version = "v71" [set go-version [ [] -> go-test-v71 ]]
  if version = "go" [set go-version [ [] -> go ]]
  if version = "v81" [set go-version [ [] -> go-test-v81 ]]
  if version = "v91" [set go-version [ [] -> go-test-v91 ]]
  if version = "v101" [set go-version [ [] -> go-test-v101 ]]
  if version = "v111" [set go-version [ [] -> go-test-v111 ]]
  if version = "v12" [set go-version [ [] -> go-test-v12 ]]
  if version = "v122" [set go-version [ [] -> go-test-v122 ]]
  if version = "v13" [set go-version [ [] -> go-test-v13 ]]
  if version = "v14" [set go-version [ [] -> go-test-v14 ]]
  if version = "prosp" [set go-version [ [] -> go-test-prosp ]]
  if version = "v15" [set go-version [ [] -> go-test-v15 ]]
  if version = "v16" [set go-version [ [] -> go-test-v16 ]]
  if version = "v17" [set go-version [ [] -> go-test-v17 ]]
  profilecore repetitions go-version
end


to duplicate-remover-test
  ask researchers [
    ; list of arguments of which the duplicates will be removed
    let new-args subjective-arguments
    foreach new-args [ [?1] ->
      ; the argument of the current entry and its color
      let argu first ?1
      let my-color first but-first ?1
      ; list of entries with the same argument, but maybe different color
      let color-argu filter [ [??1] -> first ??1 = argu ] new-args
      ; remove entries of arguments that are also present as
      ; better researched entries
      set color-argu sort-by [ [??1 ??2] -> first but-first ??1 < first but-first ??2 ] color-argu
      while [length color-argu != 1] [
        show "idiots!"
        show (word "last a list: ")
        analize-list lastalist
        show (word "last b list: ")
        analize-list lastblist
        show (word "last a list after: ")
        analize-list lastalistafter
        set new-args remove last color-argu new-args
        set color-argu but-last color-argu
      ]
    ]
    ; update the researcher's memory
    set subjective-arguments new-args
  ]
end

to analize-list [inputlist]
  foreach inputlist [ [?1] ->
    let temp ?1
    foreach temp [ [??1] ->
    show ??1
     ]
    show ""
   ]
end

to update-memories-test
  ask researchers [
    let myx xcor
    let myy ycor
    let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      and xcor = myx and ycor = myy]
    let cur-researcher self
    ; information of current argument in the format of the memory
    let add-cur (sentence cur-argum [color] of cur-argum)
;    set subjective-arguments lput add-cur subjective-arguments
    ; list of relations (resp. arguments) that are added
    let to-add []
    let to-add-argu []
    set to-add-argu lput add-cur to-add-argu
    ; list of neighborhood arguments of the current argument
    set neighborargs []
    set neighborargs lput cur-argum neighborargs

    ; for the current argument
    ; add the neighboring discovered arguments and relations
    ; (attacks and discovery) to a to-add list
    ask cur-argum [
       if any? my-in-discoveries with [color != gray][
        ask my-in-discoveries with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added discovery relation
          let add-rel []
          set add-rel lput "d" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the child argument of the discovery relation
      if any? my-out-discoveries with [color != gray][
        ask my-out-discoveries with [color != gray][
    let add-other-end other-end
    ask cur-researcher [
      set neighborargs lput add-other-end neighborargs
    ]
    ; construction of the to be added discovery relation
    let add-rel []
    set add-rel lput "d" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput add-other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the parent argument of the attack relation
      if any? my-in-attacks with [color != gray][
        ask my-in-attacks with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the child argument of the attack relation
      if any? my-out-attacks with [color != gray][
        ask my-out-attacks with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
    ]

    ; remove duplicates from the list
    set subjective-relations remove-duplicates sentence
      subjective-relations to-add
    ; show subjective-arguments
    ; foreach to-add-argu [
      ; let argu first ?
      ; ; show ?
      ; let my-color first but-first ?
      ; ; list of entries with the same argument, but maybe different color
      ; let argu-old filter [first ? = argu] subjective-arguments
      ; ; show argu-old
      ; if not empty? argu-old [
        ; set argu-old item 0 argu-old
        ; if my-color < item 1 argu-old [
          ; let argument-position position argu-old subjective-arguments
          ; ; show argument-position
          ; ; remove entries of arguments that are also present as
          ; ; better researched entries
          ; ; set color-argu sort-by [first but-first ?1 < first but-first ?2] color-argu
          ; if argument-position != false [

            ; ; show (word "replacing position " argument-position " with " ?)
            ; set subjective-arguments replace-item argument-position subjective-arguments ?
          ; ]
        ; ]
        ; if my-color > item 1 argu-old [
              ; show "plausi check error new arg is older"
        ; ]
      ; ]
    ; ]
    ; set subjective-arguments remove-duplicates sentence
      ; subjective-arguments to-add-argu
    ; ; show subjective-arguments
  set subjective-arguments (merge-arg-wo-dupl-tst subjective-arguments to-add-argu false)
  set flag-updated-memory true
  ]

  ; every 5 plus 4 time-steps the collected information
  ; is shared with other researchers
  if ticks mod 5 = 4 [
   share-with-others-test
  ]

end


to update-memories-test2
  ask researchers [
    let myx xcor
    let myy ycor
    let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      and xcor = myx and ycor = myy]
    let cur-researcher self
    ; information of current argument in the format of the memory
    let add-cur (sentence cur-argum [color] of cur-argum)
;    set subjective-arguments lput add-cur subjective-arguments
    ; list of relations (resp. arguments) that are added
    let to-add []
    let to-add-argu []
    set to-add-argu lput add-cur to-add-argu
    ; list of neighborhood arguments of the current argument
    set neighborargs []
    set neighborargs lput cur-argum neighborargs

    ; for the current argument
    ; add the neighboring discovered arguments and relations
    ; (attacks and discovery) to a to-add list
    ask cur-argum [
       if any? my-in-discoveries with [color != gray][
        ask my-in-discoveries with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added discovery relation
          let add-rel []
          set add-rel lput "d" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the child argument of the discovery relation
      if any? my-out-discoveries with [color != gray][
        ask my-out-discoveries with [color != gray][
    let add-other-end other-end
    ask cur-researcher [
      set neighborargs lput add-other-end neighborargs
    ]
    ; construction of the to be added discovery relation
    let add-rel []
    set add-rel lput "d" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput add-other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the parent argument of the attack relation
      if any? my-in-attacks with [color != gray][
        ask my-in-attacks with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the child argument of the attack relation
      if any? my-out-attacks with [color != gray][
        ask my-out-attacks with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
    ]

    ; remove duplicates from the list
    set subjective-relations remove-duplicates sentence
      subjective-relations to-add
    ; show subjective-arguments
    ; foreach to-add-argu [
      ; let argu first ?
      ; ; show ?
      ; let my-color first but-first ?
      ; ; list of entries with the same argument, but maybe different color
      ; let argu-old filter [first ? = argu] subjective-arguments
      ; ; show argu-old
      ; if not empty? argu-old [
        ; set argu-old item 0 argu-old
        ; if my-color < item 1 argu-old [
          ; let argument-position position argu-old subjective-arguments
          ; ; show argument-position
          ; ; remove entries of arguments that are also present as
          ; ; better researched entries
          ; ; set color-argu sort-by [first but-first ?1 < first but-first ?2] color-argu
          ; if argument-position != false [

            ; ; show (word "replacing position " argument-position " with " ?)
            ; set subjective-arguments replace-item argument-position subjective-arguments ?
          ; ]
        ; ]
        ; if my-color > item 1 argu-old [
              ; show "plausi check error new arg is older"
        ; ]
      ; ]
    ; ]
    ; set subjective-arguments remove-duplicates sentence
      ; subjective-arguments to-add-argu
    ; ; show subjective-arguments
  set subjective-arguments (merge-arg-wo-dupl-tst subjective-arguments to-add-argu false)
  set flag-updated-memory true
  ]

  ; every 5 plus 4 time-steps the collected information
  ; is shared with other researchers
  if ticks mod 5 = 4 [
   share-with-others-test2
  ]

end


to-report merge-arg-wo-duplicates-backup [alist blist flag]

  if flag [
    set blist remove-duplicates blist
  ]
  ; set lastalist lput alist lastalist
  ; set lastblist lput blist lastblist
  ; if length lastalist > 2 [
    ; set lastalist remove-item 0 lastalist
  ; ]
  ; if length lastblist > 2 [
    ; set lastblist remove-item 0 lastblist
  ; ]
  ; if flag [
    ; ; set blist list-cleaner blist
  ; ]
  foreach blist [ [?1] ->
    let argu first ?1
    ; show ?
    let my-color item 1 ?1
    ; list of entries with the same argument, but maybe different color
    if flag [
      let duplicate-check filter [ [??1] -> first ??1 = argu ] blist
      foreach duplicate-check [ [??1] ->
        if item 1 ??1 > my-color [
          set blist remove ??1 blist
        ]
       ]
    ]
    let argu-old filter [ [??1] -> first ??1 = argu ] alist
    ; show argu-old
    if not empty? argu-old [
      set argu-old item 0 argu-old

      if my-color < item 1 argu-old [
      let argument-position position argu-old alist
        ; show argument-position
        ; remove entries of arguments that are also present as
        ; better researched entries
        ; set color-argu sort-by [first but-first ?1 < first but-first ?2] color-argu
        if argument-position != false [

          ; show (word "replacing position " argument-position " with " ?)
          set alist replace-item argument-position alist ?1
        ]
      ]
      if my-color >= item 1 argu-old [
        set blist remove ?1 blist
        ;show (word my-color " " item 1 argu-old)
        ;show (word "removed " ? " from " blist)
        ; let argument-position position argu-old blist
        ; set blist remove-item argument-position blist
        ;set blist replace-item argument-position blist
      ]
    ]
   ]
  set alist remove-duplicates sentence
      alist blist

  ; set lastalistafter lput alist lastalistafter
  ; if length lastalistafter > 2 [
    ; set lastalistafter remove-item 0 lastalistafter
  ; ]
  report alist
end



to-report merge-arg-wo-dupl-tst [alist blist flag]
  if flag [
    set blist remove-duplicates blist
  ]
  foreach blist [ [?1] ->
    let argu first ?1
    let my-color item 1 ?1
    if flag [
      let duplicate-check list-filter argu my-color blist
      ; let duplicate-check filter [ [??1] -> first ??1 = argu ] blist
      foreach duplicate-check [ [??1] ->
        if item 1 ??1 > my-color [
          set blist remove ??1 blist
        ]
      ]
    ]
    ; argu-old will contain the current argument (argu) from blist if this
    ; argument also is present in alist. argu-old is a nested list:
    ; lists [[(argu) color-argu-in-alist]]
    let argu-old filter [ [??1] -> first ??1 = argu ] alist
    if not empty? argu-old [
      ; item 0 will reduce the degree of nestedness of the argu-old by one i.e.
      ; argu-old will now now be [(argu) color-argu-in-alist] 
      set argu-old item 0 argu-old
      if my-color < item 1 argu-old [
      let argument-position position argu-old alist
        if argument-position != false [
          set alist replace-item argument-position alist ?1
        ]
      ]
      if my-color >= item 1 argu-old [
        set blist remove ?1 blist
      ]
    ]
  ]
  ; finally the lists which had their respective duplicates removed are merged
  ; and identical entries are removed. The result is then reported
  set alist remove-duplicates sentence alist blist
  report alist
end




to-report merge-arg-wo-duplicates2 [alist blist flag]
  if flag [
    set blist duplicate-remover-command blist
    ; set blist remove-duplicates blist
  ]
  foreach blist [ [?1] ->
    let argu first ?1
    let my-color item 1 ?1
    
    if flag [
      let duplicate-check list-filter2 argu my-color blist
      ; let duplicate-check filter [ [??1] -> first ??1 = argu and item 1 ??1 > my-color] blist
      foreach duplicate-check [ [??1] ->
        if item 1 ??1 > my-color [
          set blist remove ??1 blist
        ]
      ]
    ]
    ; ; argu-old will contain the current argument (argu) from blist if this
    ; ; argument also is present in alist. argu-old is a nested list:
    ; ; lists [[(argu) color-argu-in-alist]]
    ; let argu-old filter [ [??1] -> first ??1 = argu ] alist
    ; if not empty? argu-old [
      ; ; item 0 will reduce the degree of nestedness of the argu-old by one i.e.
      ; ; argu-old will now now be [(argu) color-argu-in-alist] 
      ; set argu-old item 0 argu-old
      ; if my-color < item 1 argu-old [
      ; let argument-position position argu-old alist
        ; if argument-position != false [
          ; set alist replace-item argument-position alist ?1
        ; ]
      ; ]
      ; if my-color >= item 1 argu-old [
        ; set blist remove ?1 blist
      ; ]
    ; ]
  ]
  ; finally the lists which had their respective duplicates removed are merged
  ; and identical entries are removed. The result is then reported
  ; set alist remove-duplicates sentence alist blist
  set alist blist
  report alist
end

to-report duplicate-remover-command [blist]
  set blist remove-duplicates blist
  report blist

end




to-report list-filter [argu my-color blist]
  let duplicate-check filter [ [??1] -> first ??1 = argu and item 1 ??1 > my-color] blist
  report duplicate-check
end

to-report list-filter2 [argu my-color blist]
  let duplicate-check filter [ [??1] -> first ??1 = argu and item 1 ??1 > my-color] blist
  report duplicate-check
end

to test-test [argu blist]
  let duplicate-check filter [ [?1] -> first ?1 = argu ] blist
end

to-report list-cleaner [blist]
  let i 0
  let help []
  let blisth []
  foreach blist [ [?1] ->
    set help lput 0 help
    set blisth lput sentence ?1 i blisth
    set i i + 1
   ]

  set i 0
  foreach blist [ [?1] ->
    if item i help != 1 [
      let argu first ?1
      ; show ?
      let my-color item 1 ?1
      ; list of entries with the same argument, but maybe different color
        test-test argu blist
        let duplicate-check filter [ [??1] -> first ??1 = argu ] blisth
        foreach duplicate-check [ [??1] ->
          let argpos item 2 ??1
          set help replace-item argpos help 1
          if item 1 ??1 > my-color [
            set blist remove ??1 blist
          ]
         ]
      ]
    set i i + 1
     ]
    report blist

end

to go-test-v2
  ; update-memories-test
  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    update-memories-test
    compute-strategies-researchers-old
    act-on-strategy-researchers-test
  ]
  move-around-test
  update-landscape-old
  ask researchers [
    set flag-updated-memory false
  ]
  compute-popularity-old
  tick
end

to go-test-v32
  ; update-memories-test
  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    update-memories-test
    compute-strategies-researchers-test
    act-on-strategy-researchers-test
  ]
  move-around-test
  update-landscape-old
  ask researchers [
    set flag-updated-memory false
  ]
  compute-popularity-old
  tick
end

to go-test-v1
  update-memories-test
  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    ; update-memories-test
    compute-strategies-researchers-old
    act-on-strategy-researchers-old
  ]
  move-around-old
  update-landscape-old
  compute-popularity-old
  tick
end

to go-test-v31
  update-memories-test
  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    ; update-memories-test
    compute-strategies-researchers-test
    act-on-strategy-researchers-old
  ]
  move-around-old
  update-landscape-old
  compute-popularity-old
  tick
end

to go-test-oldv3
  update-memories-old
  duplicate-remover-old
  if ticks mod 5 = 4 [
    compute-strategies-researchers-test
    act-on-strategy-researchers-old
  ]
  move-around-old
  update-landscape-old
  compute-popularity-old
  tick
end

to go-test-v41
  update-memories-test2
  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    ; update-memories-test
    compute-strategies-researchers-test
    act-on-strategy-researchers-old
  ]
  move-around-old
  update-landscape-old
  compute-popularity-old
  tick
end

to go-test-v51
  update-memories-test5

  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    share-with-others-test5
    create-share-memory-test5
    share-with-other-networks-test5
    compute-time-costs-test5
    ; update-memories-test
    compute-strategies-researchers-test
    act-on-strategy-researchers-old
  ]
  move-around-old
  update-landscape-old
  compute-popularity-old
  tick
end


to go-test-v61
  update-memories-test5

  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    share-with-others-test5
    create-share-memory-test5
    share-with-other-networks-test5
    compute-time-costs-test5
    ; update-memories-test
    compute-subj-attacked-test6
    compute-strategies-researchers-test6
    act-on-strategy-researchers-old
  ]
  move-around-test6
  update-landscape-old
  compute-popularity-old
  tick
end

to go-test-v71
  update-memories-test7

  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    share-with-others-test5
    create-share-memory-test7
    share-with-other-networks-test5
    compute-time-costs-test5
    ; update-memories-test
    compute-subj-attacked-test7
    compute-strategies-researchers-test6
    act-on-strat-ag-tst7
  ]
  move-around-test7
  update-landscape-test7
  full-discovery-test7
  if ticks mod 5 != 0 [
    communication-regress
  ]
  compute-popularity-tst7
  tick
end



to go-test-v81
  update-memories-test8

  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    share-with-others-test8
    create-share-memory-test7
    share-with-other-networks-test5
    compute-time-costs-test5
    ; update-memories-test
    compute-subj-attacked-test7
    compute-strategies-researchers-test6
    act-on-strat-ag-tst7
  ]
  move-around-test7
  update-landscape-test7
  full-discovery-test7
  if ticks mod 5 != 0 [
    communication-regress
  ]
  compute-popularity-tst7
  tick
end



to go-test-v91
  update-memories-test8

  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    share-with-others-test8
    create-share-memory-test7
    share-with-other-networks-test5
    compute-time-costs-test5
    ; update-memories-test
    compute-subj-attacked-test9
    compute-strategies-researchers-test6
    act-on-strat-ag-tst7
  ]
  move-around-test7
  update-landscape-test7
  full-discovery-test7
  if ticks mod 5 != 0 [
    communication-regress
  ]
  compute-popularity-tst7
  tick
end





to go-test-v101
  update-memories-test8

  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    share-with-others-test8
    create-share-memory-test7
    share-w-other-netw-test10
    compute-time-costs-test10
    ; update-memories-test
    compute-subj-attacked-test9
    compute-strategies-researchers-test6
    act-on-strat-ag-tst7
  ]
  move-around-test10
  update-landscape-test7
  full-discovery-test7
  if ticks mod 5 != 0 [
    communication-regress
  ]
  compute-popularity-tst7
  tick
end


to go-test-v111
  update-memories-test11

  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    share-with-others-test11
    create-share-memory-test11
    share-w-other-netw-test10
    compute-time-costs-test10
    ; update-memories-test
    compute-subj-attacked-test11
    compute-strategies-researchers-test6
    act-on-strategies-test11
  ]
  move-around-test11
  update-landscape-test7
  full-discovery-test7
  if ticks mod 5 != 0 [
    communication-regress
  ]
  compute-popularity-test11
  tick
end


to go-test-v12
  if ticks = 0 [set update-mem-every-tick? true]
  ask researchers [
    update-memories-test12
  ]

  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    share-with-others-test12
    create-share-memory-test11
    share-w-other-netw-test10
    compute-time-costs-test12
    ; update-memories-test
    compute-subj-attacked-test11
    compute-strategies-researchers-test6
    act-on-strategies-test11
  ]
  move-around-test11
  update-landscape-test7
  full-discovery-test7
  if ticks mod 5 != 0 [
    communication-regress
  ]
  compute-popularity-test11
  tick
end

to go-test-v122
  
  if ticks = 0 [set update-mem-every-tick? false]
  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    ask researchers [
      update-memories-test12
    ]
    share-with-others-test12
    create-share-memory-test11
    share-w-other-netw-test10
    compute-time-costs-test12
    ; update-memories-test
    compute-subj-attacked-test11
    compute-strategies-researchers-test6
    act-on-strategies-test11
  ]
  move-around-test11
  update-landscape-test7  
  full-discovery-test7
  ask researchers [
    set flag-updated-memory false
  ]
  if ticks mod 5 != 0 [
    communication-regress
  ]
  compute-popularity-test11
  tick
end



to go-test-v13
  
  if ticks = 0 [set update-mem-every-tick? false]
  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    ask researchers [
      update-memories-test12
    ]
    share-with-others-test12
    create-share-memory-test11
    share-w-other-netw-test10
    compute-time-costs-test12
    ; update-memories-test
    compute-subj-attacked-test11
    compute-strategies-researchers-test6
    act-on-strategies-test11
  ]
  move-around-test13
  update-landscape-test13  
  full-discovery-test13
  ask researchers [
    set flag-updated-memory false
  ]
  if ticks mod 5 != 0 [
    communication-regress
  ]
  compute-popularity-test11
  tick
end



to go-test-v14
  
  if ticks = 0 [set update-mem-every-tick? false]
  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    ask researchers [
      update-memories-test12
    ]
    share-with-others-test12
    create-share-memory-test14
    share-w-other-netw-test10
    compute-time-costs-test14
    ; update-memories-test
    compute-subj-attacked-test14
    act-on-strategies-test14
  ]
  move-around-test13
  update-landscape-test13  
  full-discovery-test13
  ask researchers [
    set flag-updated-memory false
  ]
  if ticks mod 5 != 0 [
    communication-regress
  ]
  compute-popularity-test11
  tick
end


to go-test-v15
  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    ask researchers [
      update-memories-test15
    ]
    share-with-group-test15
    create-share-memory-test15
    share-with-other-netw-test15
    ; compute-time-costs-test14
    ; update-memories-test
    compute-subj-attacked-test15
    act-on-strategies-test14
  ]
  move-around-test15
  update-landscape-test15
  ask researchers [
    set flag-updated-memory false
  ]
  if ticks mod 5 != 0 [
    communication-regress
  ]
  compute-popularity-test11
  tick
end



to go-test-v16
  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    ask researchers [
      update-memories-test15
    ]
    share-with-group-test15
    create-share-memory-test15
    share-with-other-netw-test15
    ; compute-time-costs-test14
    ; update-memories-test
    compute-subj-attacked-test16
    act-on-strategies-test14
  ]
  move-around-test15
  update-landscape-test15
  ask researchers [
    set flag-updated-memory false
  ]
  if ticks mod 5 != 0 [
    communication-regress
  ]
  compute-popularity-test11
  tick
end



to go-test-v17
  ; if ticks mod 10 = 4 [
    ; duplicate-remover-test
  ; ]
  if ticks mod 5 = 4 [
    ask researchers [
      update-memories-test15
    ]
    share-with-group-test15
    create-share-memory-test15
    share-with-other-netw-test17
    ; compute-time-costs-test14
    ; update-memories-test
    compute-subj-attacked-test16
    act-on-strategies-test14
  ]
  move-around-test15
  update-landscape-test15
  ask researchers [
    set flag-updated-memory false
  ]
  if ticks mod 5 != 0 [
    communication-regress
  ]
  compute-popularity
  tick
end




to go-test
  go-test-v17
end

to go-stop-test
  setuprs new-seed "v15"
  go-test
  while [not exit-condition-new][
    go-test
  ]
end

to bla [times]
  repeat times [go-test]
end

to setuprs [rs version]
  clear-all
  random-seed rs
  print (word "random seed: " rs)
  print (word "no. scientists: " scientists)
  initialize-hidden-variables
  setup-hidden-variables-test15
  create-discovery-landscape number-of-theories theory-depth
  define-attack-relation
  ; scientists is the chooser for the number of researchers from the interface
  distribute-researchers scientists
  set startsargum turtles with [breed = starts or breed = arguments]
  set disc-startsargum-non-red starts
  setup-attacks
  setup-group-ids
  calc-global-admiss
  setup-argu-memory
  if version = "v15" [
    set update-mem-every-tick? false set v15 true
    ask starters [die] ; to prevent potential conflicts when asking for "links" in general
  ]
  ask researchers [
    set lastalist []
    set lastblist []
    set lastalistafter []
    set flag-updated-memory false
    set conference-attended false
    set to-add-mem-argu []
    set to-add-mem-rel []
    set non-admiss-subj-argu []
    set mygps gps-setup
    set argu-cache no-turtles
    if version = "v15" [
      set subjective-arguments one-of (starts in-radius 0)
    ]
    set current-theory-info sort-by [ [?1 ?2] -> item 0 ?1 < item 0 ?2 ] current-theory-info
  ]
  reset-ticks
end


to setuprs-behaviorspace-simple [version]
  clear-all
  random-seed new-seed
  initialize-hidden-variables
  setup-hidden-variables-test15
  create-discovery-landscape number-of-theories theory-depth
  define-attack-relation
  ; scientists is the chooser for the number of researchers from the interface
  distribute-researchers scientists
  set startsargum turtles with [breed = starts or breed = arguments]
  set disc-startsargum-non-red starts
  setup-attacks
  setup-group-ids
  calc-global-admiss
  setup-argu-memory
  if version = "v15" [
    set update-mem-every-tick? false set v15 true
    ask starters [die] ; to prevent potential conflicts when asking for "links" in general
  ]
  ask researchers [
    set lastalist []
    set lastblist []
    set lastalistafter []
    set flag-updated-memory false
    set conference-attended false
    set to-add-mem-argu []
    set to-add-mem-rel []
    set non-admiss-subj-argu []
    set mygps gps-setup
    set to-add-mem-argu []
    set to-add-mem-rel []
    set argu-cache no-turtles
    if version = "v15" [
      set subjective-arguments one-of (starts in-radius 0)
    ]
    set current-theory-info sort-by [ [?1 ?2] -> item 0 ?1 < item 0 ?2 ] current-theory-info
  ]
  reset-ticks
end

to setuprs-behaviorspace [#of-repetitions version]
  clear-all
  file-open "rndseed-table.txt" let rs item ((behaviorspace-run-number - 1) mod #of-repetitions) file-read file-close
  set rndseed rs
  random-seed rs
  initialize-hidden-variables
  setup-hidden-variables-test15
  create-discovery-landscape number-of-theories theory-depth
  define-attack-relation
  ; scientists is the chooser for the number of researchers from the interface
  distribute-researchers scientists
  set startsargum turtles with [breed = starts or breed = arguments]
  setup-attacks
  setup-group-ids
  calc-global-admiss
  if version = "v15" [
    set update-mem-every-tick? false set v15 true
    ask starters [die]
  ]
  ask researchers [
    set lastalist []
    set lastblist []
    set lastalistafter []
    set flag-updated-memory false
    set conference-attended false
    set to-add-mem-argu []
    set to-add-mem-rel []
    set non-admiss-subj-argu []
    set mygps gps-setup
    set to-add-mem-argu []
    set to-add-mem-rel []
    set argu-cache no-turtles
    if version = "v15" [
      set subjective-arguments one-of (starts in-radius 0)
    ]
    set current-theory-info sort-by [ [?1 ?2] -> item 0 ?1 < item 0 ?2 ] current-theory-info
  ]
  reset-ticks

end
 


to setuprs-auto [version]
  clear-turtles
  clear-patches
  clear-drawing
  clear-all-plots
  clear-output
  set rndseed lput new-seed rndseed
  random-seed last rndseed
  initialize-hidden-variables
  setup-hidden-variables-test15
  create-discovery-landscape number-of-theories theory-depth
  define-attack-relation
  ; scientists is the chooser for the number of researchers from the interface
  distribute-researchers scientists

  set startsargum turtles with [breed = arguments or breed = starts]
  setup-attacks
  setup-group-ids
  setup-argu-memory
  if version = "v15" [
    set update-mem-every-tick? false set v15 true
    ask starters [die]
  ]
  ask researchers [
    set lastalist []
    set lastblist []
    set lastalistafter []
    set flag-updated-memory false
    set conference-attended false
    set to-add-mem-argu []
    set to-add-mem-rel []
    set non-admiss-subj-argu []
    set mygps gps-setup
    set subj-argu-as mygps
    set to-add-mem-argu []
    set to-add-mem-rel []
    set argu-cache no-turtles
    if version = "v15" [
      set subjective-arguments one-of (starts in-radius 0)
    ]
    set current-theory-info sort-by [ [?1 ?2] -> item 0 ?1 < item 0 ?2 ] current-theory-info
  ]
  reset-ticks
end

to v15-rest
  set update-mem-every-tick? false set v15 true
end

to setup-attacks
  let in-group-i-memory-list n-values length colla-networks [false]
  ask attacks [
    set mytheory-end1 [mytheory] of end1
    set mytheory-end2 [mytheory] of end2
    set in-group-i-memory in-group-i-memory-list
    set uncontested true    
  ]
end

to setup-group-ids
  let i 0
  foreach colla-networks [ [curgroup] ->
    foreach curgroup [ [curresearcher] ->
      ask curresearcher [
        set group-id i
      ]
    ]
    set i i + 1
  ]
end

to-report gps-setup
  let myx xcor
  let myy ycor
  let myargu one-of starts with [xcor = myx and ycor = myy]
  report myargu
end


to setup-argu-memory
  ; cyan = 85. This is set that way such that the smaller color the more discovered
  let group-colors-list n-values (length colla-networks) [cyan]
  ask startsargum [
    set group-color-mem group-colors-list
    set group-color-mem-cache group-colors-list
  ]
  ask starts [
    let mygroups remove-duplicates [group-id] of researchers in-radius 0
    foreach mygroups [ [curgroup-id] ->
      set group-color-mem replace-item curgroup-id group-color-mem color
    ]
  ]
end

; one argument from nothing (= cyan = 85) to full (= red = 15) costs 70.  A attack relation costs as much as a full argument. They can digest three full arguments / relations (= attacks) per day which mirrors the amount of communication cost payed in the old version.
to setup-hidden-variables-test15
  set rel-costfactor 70
  set max-learn (70 * 3)
end

to share-with-others-test
  ask researchers [
    ; reset the variables
    set rep-researcher false
    set to-add-mem-argu []
    set to-add-mem-rel []

    ; variables to keep track of the current researchers own memory
    ; and the combined memory of all the sharing researchers
    ; let own-memory-argu subjective-arguments
    ; let own-memory-rel subjective-relations
    let comb-memory-argu []
    let comb-memory-rel []
    ; collaborator network of the current researcher
    let cur-network collaborator-network

    ; the information in the memories of the single researchers in the network
    ; are combined
    ask turtles with [member? self cur-network] [
      set comb-memory-argu sentence subjective-arguments comb-memory-argu
      set comb-memory-rel sentence subjective-relations comb-memory-rel
    ]

    ; each researcher adds the combined memory to its own
    ; then removing duplicates
    set subjective-arguments (merge-arg-wo-dupl-tst subjective-arguments comb-memory-argu true)
    set subjective-relations remove-duplicates sentence
      subjective-relations comb-memory-rel
  ]

  ; then researchers can share some of their information with researchers
  ; from neighboring networks in the social structures
  create-share-memory-test
  share-with-other-networks-test

end




to create-share-memory-test

  ; for each collaborator-network one researcher is set to be
  ; the representative researcher
  foreach colla-networks [ [?1] ->
    ifelse length ?1 > 1 [
      ask one-of researchers with [member? self ?1][
        set rep-researcher true
      ]
    ][
    if ticks mod 25 = 4 [
      ask one-of researchers with [member? self ?1][
        set rep-researcher true
      ]
    ]
    ]
  ]

  ; only the representative researchers create a memory
  ; that they want to share with researchers from other networks
  ask researchers with [rep-researcher][
    let myx xcor
    let myy ycor
    ; variables for the argument the researcher is currently working on,
    ; the researcher itself and the theory it is working on
    let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      and xcor = myx and ycor = myy]
    let cur-researcher self
    let cur-th [mytheory] of cur-argum
    ; create a list of arguments and a list of relations that the researcher can
    ; share with researchers from other collaborative networks
    ; what researchers share depends on the "social-action" and "sharing"
    ; from the interface
    set th-args []
    set th-relations []

    ; researchers share only information obtained in the neighborhood
    ; they are currently working on
    ; collect the arguments from the researcher's memory
    ; that belong also to the neighborargs
    foreach subjective-arguments [ [?1] ->
      if member? item 0 ?1 [neighborargs] of cur-researcher [
        set th-args lput ?1 th-args
      ]
    ]
    ; collect the relations from/to the current argument
    ; from the researcher's memory
    foreach subjective-relations [ [?1] ->
      if item 1 ?1 = cur-argum or item 2 ?1 = cur-argum [
        set th-relations lput ?1 th-relations
      ]
    ]

    ; if the researcher behaves biased it does not share the attack relations that
    ; attack its current theory, these relations are removed
    if social-actions = "biased"[
      foreach th-relations [ [?1] ->
        if item 0 ?1 = "a" and [mytheory] of item 2 ?1 = cur-th [
          set th-relations remove ?1 th-relations
        ]
      ]
    ]
  ]
end




to share-with-other-networks-test
  ask researchers with [rep-researcher][
    ; variables for the combined information (arguments and relations),
    ; the network of the current researcher and the theory it is working on
    let comb-memory-argu th-args
    let comb-memory-rel th-relations
    let cur-network sort collaborator-network
    let my-cur-theory [mytheory] of item 0 item 0 th-args

    ; create a list of the neighboring networks and then a
    ; list of the representative researchers of these networks
    ; which will be the researchers the current researcher shares with
    let share-researchers []
    let share-neighbors []
    foreach share-structure [ [?1] ->
      if first ?1 = cur-network [
        set share-neighbors ?1
      ]
    ]
    ask researchers with [rep-researcher][
      let cur-researcher self
      foreach share-neighbors [ [?1] ->
        if member? cur-researcher ?1 [
          set share-researchers lput cur-researcher share-researchers
        ]
      ]
    ]

    ; create a list of arguments and a list of relations that is
    ; shared among the share-researchers
    foreach share-researchers [ [?1] ->
      ; the combined memory is updated to contain that of the sharing researcher
      set comb-memory-argu sentence comb-memory-argu [th-args] of ?1
      set comb-memory-rel sentence comb-memory-rel [th-relations] of ?1
    ]
    ; create lists of arguments/relations that have to be added
    foreach share-researchers [
      set to-add-mem-argu remove-duplicates sentence subjective-arguments
        comb-memory-argu
      set to-add-mem-rel remove-duplicates sentence subjective-relations
        comb-memory-rel
    ]
  ]

  ; to compute the time that researchers have to
  ; spend on communication
  compute-time-costs-test
end



to compute-time-costs-test
  ask researchers with [rep-researcher][

    ; variables that contain the arguments and relations the
    ; researcher has to update in its memory
    let new-memory-args []
    let new-memory-rel []
    let to-add-argu []
    set new-memory-args filter [ [?1] -> not member? ?1 subjective-arguments ]
      to-add-mem-argu
    set new-memory-rel filter [ [?1] -> not member? ?1 subjective-relations ]
      to-add-mem-rel
    let comb-new sentence new-memory-args new-memory-rel
    ; every tick an researcher can obtain a maximum of 10 new entries
    ; the day that they received information is also lost
    ifelse length comb-new >= (3 * max-learn) [
      set communicating 4
    ][
    set communicating ((ceiling (length comb-new / max-learn)) + 1)
    ]

    ; every communication round an researcher can update a maximum of
    ; 3 * max-learn new arguments/relations (corresponding to three ticks of
    ; communication) these new arguments and relations are added to the
    ; memory of the researcher
    ; when a new relation is added and the arguments are not part of the
    ; memory of the researcher, these arguments are added as well
    ifelse length comb-new > (3 * max-learn) [
      set comb-new shuffle comb-new
      let repeats length comb-new - (3 * max-learn)
      while [length comb-new > repeats] [
        let cur-entr first comb-new
        let new-mem-argargs filter [ [?1] -> member? ?1 new-memory-args ] comb-new
        set new-mem-argargs map [ [?1] -> first ?1 ] new-mem-argargs
        ifelse member? cur-entr new-memory-args [
          set to-add-argu lput cur-entr to-add-argu
          set comb-new remove cur-entr comb-new
        ][
        set subjective-relations lput cur-entr subjective-relations
        set comb-new remove cur-entr comb-new
        if member? item 1 cur-entr new-mem-argargs[
          let item-1-cur-entr item 1 cur-entr
          foreach comb-new [ [?1] ->
            if item-1-cur-entr = item 0 ?1 [
              set to-add-argu lput ?1 to-add-argu
              set comb-new remove ?1 comb-new
            ]
          ]
        ]
        if member? item 2 cur-entr new-mem-argargs[
          let item-2-cur-entr item 2 cur-entr
          foreach comb-new [ [?1] ->
            if item-2-cur-entr = item 0 ?1 [
              set to-add-argu lput ?1 to-add-argu
              set comb-new remove ?1 comb-new
            ]
          ]
        ]
        ]
      ]
      set subjective-arguments (merge-arg-wo-dupl-tst subjective-arguments to-add-argu true)
    ][
    set subjective-arguments (merge-arg-wo-dupl-tst subjective-arguments new-memory-args true)
    set subjective-relations sentence subjective-relations new-memory-rel ;remove duplicates!? bug maybe -> probably no problem b/c remove duplicates for relations is run during "share-with-other-networks"
    ]
  ]
end





to refresh-mem-set-move-parameter
  refresh-mem-before-move
  set moved true
end

to refresh-mem-before-move
  if not flag-updated-memory [
    let myx xcor
    let myy ycor
    let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      and xcor = myx and ycor = myy]
    let cur-researcher self
    ; information of current argument in the format of the memory
    let add-cur (sentence cur-argum [color] of cur-argum)
  ;    set subjective-arguments lput add-cur subjective-arguments
    ; list of relations (resp. arguments) that are added
    let to-add []
    let to-add-argu []
    set to-add-argu lput add-cur to-add-argu
    ; list of neighborhood arguments of the current argument
    set neighborargs []
    set neighborargs lput cur-argum neighborargs

    ; for the current argument
    ; add the neighboring discovered arguments and relations
    ; (attacks and discovery) to a to-add list
    ask cur-argum [
       if any? my-in-discoveries with [color != gray][
        ask my-in-discoveries with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added discovery relation
          let add-rel []
          set add-rel lput "d" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the child argument of the discovery relation
      if any? my-out-discoveries with [color != gray][
        ask my-out-discoveries with [color != gray][
    let add-other-end other-end
    ask cur-researcher [
      set neighborargs lput add-other-end neighborargs
    ]
    ; construction of the to be added discovery relation
    let add-rel []
    set add-rel lput "d" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput add-other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the parent argument of the attack relation
      if any? my-in-attacks with [color != gray][
        ask my-in-attacks with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the child argument of the attack relation
      if any? my-out-attacks with [color != gray][
        ask my-out-attacks with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
    ]

    ; remove duplicates from the list
    set subjective-relations remove-duplicates sentence
      subjective-relations to-add
    ; show subjective-arguments
    ; foreach to-add-argu [
      ; let argu first ?
      ; ; show ?
      ; let my-color first but-first ?
      ; ; list of entries with the same argument, but maybe different color
      ; let argu-old filter [first ? = argu] subjective-arguments
      ; ; show argu-old
      ; if not empty? argu-old [
        ; set argu-old item 0 argu-old
        ; if my-color < item 1 argu-old [
          ; let argument-position position argu-old subjective-arguments
          ; ; show argument-position
          ; ; remove entries of arguments that are also present as
          ; ; better researched entries
          ; ; set color-argu sort-by [first but-first ?1 < first but-first ?2] color-argu
          ; if argument-position != false [

            ; ; show (word "replacing position " argument-position " with " ?)
            ; set subjective-arguments replace-item argument-position subjective-arguments ?
          ; ]
        ; ]
        ; if my-color > item 1 argu-old [
              ; show "plausi check error new arg is older"
        ; ]
      ; ]
    ; ]
    ; set subjective-arguments remove-duplicates sentence
      ; subjective-arguments to-add-argu
    ; ; show subjective-arguments
    set subjective-arguments (merge-arg-wo-dupl-tst subjective-arguments to-add-argu false)
    set flag-updated-memory true
  ]
end

to move-around-test
  ; variable to make sure that the procedure find-defense
  ; is only run once
  let run-find-defense false
  ; at the beginning of the procedure no researcher has moved yet
  ask researchers [
    set moved false
  ]
  ask researchers [
    let curresearcher self
    if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
      let myx xcor
      let myy ycor
      ; variable for the argument the researcher is currently working on and
     ; the researcher itself
        let myargu one-of turtles with [(breed = starts or breed = arguments) and
        xcor = myx and ycor = myy]

      ; a list of not-admissible arguments is created
      let not-admissible []
      if admissible-subj-argu != 0 and not empty? admissible-subj-argu [
        let info-not-admissible filter [ [?1] -> not member? ?1 admissible-subj-argu ]
          subjective-arguments
        foreach info-not-admissible [ [?1] ->
          set not-admissible lput item 0 ?1 not-admissible
        ]
      ]

      ; an researcher working on an attacked argument will try to find a defense for
      ; this attack, by working further on the attacked argument, unless it
      ; discoveres a child-argument that that has a defense for the attack
      ; (it is not necessarily the case that this defense is already discovered)
      ; the find-defense runs immediately for all researchers working on a not
      ; fully researched not-admissible argument, hence it is only once executed
      if member? myargu not-admissible and not moved[

        if not run-find-defense [
          find-defense-test
          set run-find-defense true
        ]
      ]

      if not moved and not member? myargu not-admissible or
        (member? myargu not-admissible and [color] of myargu = red)[

        ; when an argument exists that:
        ; a) is a child-argument of the current argument;
        ; b) is not gray, red or turquoise; and
        ; c) no researcher from the same collaborator-network is working on it
        ; the researcher moves there, with certain probability
        ifelse any? turtles with [(breed = starts or breed = arguments) and
          in-discovery-neighbor? myargu and color != gray and color != red and
        color != turquoise and not (any? turtles with [breed = researchers and
    xcor = [xcor] of myself and ycor = [ycor] of myself and member? self
    [collaborator-network] of curresearcher])] [
        let move-random random-float 1.0


        ; every time step with small-movement of the move-probability
        ; the researcher moves
        ifelse move-random < (small-movement * move-probability *
          (1 - (color / color-move))) [ refresh-mem-before-move
          move-to one-of turtles with [(breed = starts or breed = arguments) and
            in-discovery-neighbor? myargu and color != gray and color != red and
            color != turquoise and not ( any? turtles with [breed = researchers and
            xcor = [xcor] of myself and ycor = [ycor] of myself and member? self
        [collaborator-network] of curresearcher])]
          set moved true
        ][

        ; every 5th time step the researcher mover with the full move-probability,
        ; that depends a bit on the color
        if ticks != 0 and ticks mod 5 = 0 and move-random <
          move-probability * (1 - (color / color-move)) [ refresh-mem-before-move
          move-to one-of turtles with [(breed = starts or breed = arguments) and
            in-discovery-neighbor? myargu and color != gray and color != red and
      color != turquoise and not ( any? turtles with [breed = researchers
      and xcor = [xcor] of myself and ycor = [ycor] of myself and
      member? self [collaborator-network] of curresearcher])]
          set moved true
        ]
        ]
            ][

        ; if there is no next argument and the current argument is
        ; fully researched, the researcher moves a step back
        ifelse [color] of myargu = red and any? turtles with [color != gray and
          color != turquoise and out-discovery-neighbor? myargu and not any?
    turtles with [breed = researchers and xcor = [xcor] of myself and
    ycor = [ycor] of myself and member? self [collaborator-network]
    of curresearcher]][ refresh-mem-before-move
        move-to one-of turtles with [color != gray and out-discovery-neighbor?
          myargu and not any? turtles with [breed = researchers and xcor = [xcor] of
          myself and ycor = [ycor] of myself and member? self
          [collaborator-network] of curresearcher]]
        set moved true
          ][

        ; if moving back is not possible, it jumps to another argument in
        ; the same tree/theory that is discovered but not fully researched
        if [color] of myargu = red[
          let askstart [mytheory] of myargu
          if any? turtles with [(breed = starts or breed = arguments) and
      color != gray and color != turquoise and color != red and
      mytheory = askstart and not any? turtles with [breed = researchers and
        xcor = [xcor] of myself and ycor = [ycor] of myself and member?
      self [collaborator-network] of curresearcher]][ refresh-mem-before-move
          move-to one-of turtles with [(breed = starts or breed = arguments) and
     color != turquoise and color != gray and color != red and
       mytheory = askstart and not any? turtles with [breed = researchers and
     xcor = [xcor] of myself and ycor = [ycor] of myself and member? self
           [collaborator-network] of curresearcher]]
          set moved true
            ]
        ]
          ]
            ]
      ]
    ]
  ]
end


to find-defense-test
  ask researchers with [not moved][
    let curresearcher self
    if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
      let myx xcor
      let myy ycor
      ; variables for the argument the researcher is working on and
      ; for the researcher itself
      let myargu one-of turtles with [(breed = starts or breed = arguments) and
        xcor = myx and ycor = myy]

      ; lists of arguments that are not admissible
      let not-admissible []
      if admissible-subj-argu != 0 and not empty? admissible-subj-argu [
        let info-not-admissible filter [ [?1] -> not member? ?1 admissible-subj-argu ]
          subjective-arguments
        foreach info-not-admissible [ [?1] ->
          set not-admissible lput item 0 ?1 not-admissible
        ]
      ]

      ; if the current argument is not fully researched and not admissible
      ; and it is a 5th time step or the researcher is not communicating
      ; the researcher tries to move prospectively to a child-argument of the current
      ; argument that provides a defense for the current argument
      if member? myargu not-admissible[
        ask myargu [
          ask my-in-attacks [
            ask end1 [
              ; create a set of arguments that provide a defense for the current
        ; argument, these:
              ; a) attack the attacker of the current argument;
        ; b) are a child-argument of the current argument;
              ; c) are discovered; and
        ; d) no researcher from the same network is working on it
              let nextargu in-attack-neighbors with [in-discovery-neighbor?
          myargu and color != gray and color != turquoise and not (any?
    researchers with [xcor = [xcor] of myself and ycor = [ycor] of myself
    and member? self [collaborator-network] of curresearcher])]
              ; if such an argument exists the researcher moves there
              ; and cannot move anymore this time step
              if any? nextargu [
                ask curresearcher [
                  refresh-mem-before-move
                  move-to one-of nextargu
                  set moved true
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
end


to act-on-strategy-researchers-test
  ask researchers with [not rep-researcher][
    ; only when there is a current best theory
    ; it makes sense for the researchers to want to work on that theory
    if not empty? cur-best-th and not member? nobody cur-best-th [
      let myx xcor
      let myy ycor

      ; if the researcher is not currently working on the best theory
      ; it considers jumping
      foreach subjective-arguments [ [?1] ->
        if [xcor] of item 0 ?1 = myx and [ycor] of item 0 ?1 = myy and
        not member? [mytheory] of item 0 ?1 cur-best-th [
          set theory-jump theory-jump + 1
        ]
      ]

      ; if the researcher has considered jumping jump-threshold times
      ; it jumps to one of the theories it considers best, based
      ; on its memory and the computations
      if theory-jump >= jump-threshold [
        let ch-best one-of cur-best-th
        let subj-argus []
        foreach subjective-arguments [ [?1] ->
          set subj-argus lput item 0 ?1 subj-argus
        ]

        ; if one of the arguments from the best theory is in its memory
        ; the researcher will jump there
        ifelse any? turtles with [(breed = starts or breed = arguments) and
          member? self subj-argus and mytheory = ch-best and color != turquoise][
            move-to one-of turtles with [(breed = starts or breed = arguments) and
              member? self subj-argus and mytheory = ch-best and color != turquoise]
          ][ ; otherwise the researcher jumps to the root of the theory
          refresh-mem-before-move
          move-to ch-best
          ]

        set times-jumped times-jumped + 1
        set theory-jump 0
      ]
    ]
  ]
end


to compute-subj-attacked-test
  foreach colla-networks [ [?1] ->
    let calc-done false
    let calc-researcher []
    let cur-group ?1
    foreach cur-group [ [??1] ->
      let cur-researcher ??1
      if not [rep-researcher] of cur-researcher [
        ifelse calc-done [
          ask cur-researcher [
            set admissible-subj-argu [admissible-subj-argu] of calc-researcher
            set current-theory-info [current-theory-info] of calc-researcher
          ]
        ][
          set calc-done true
          set calc-researcher cur-researcher
          ask cur-researcher [
            ; variables for lists that contain:
            ; the current-theory-info with 0 admissible arguments; an updated number
            ; of admissible arguments during the recursive computation; the arguments
            ; that are not admissible; the arguments that the researchers knows about; and
            ; the arguments that are attacked by the current theory
            let new-info []
            let new-cur-info []
            let not-admissible []
            let args-cur-arguments []
            let attacked-by-me []

            ; create a list of only the attacks
            let attack-relations []
            foreach subjective-relations [ [???1] ->
              if first ???1 = "a" [
                set attack-relations lput ???1 attack-relations
              ]
             ]
            ; create lists of attacked and attacking arguments
            let cur-attacked []
            let cur-attacker []
            foreach attack-relations [ [???1] ->
              set cur-attacked lput last ???1 cur-attacked
              set cur-attacker lput first but-first ???1 cur-attacker
             ]

            ; create a list of the arguments the researchers knows about and
            ; set the number of admissible arguments for each theory to 0
            foreach subjective-arguments [ [???1] ->
              set args-cur-arguments lput first ???1 args-cur-arguments
             ]
            foreach current-theory-info [ [???1] ->
              set new-info lput replace-item 1 ???1 0 new-info
             ]
            set current-theory-info new-info

            ; the computation of the admissible arguments is done recursively
            ; a list of arguments that are currently considered attacked
            let open-rec []
            ; variable that lets the loop run at least one time
            let i 0
            foreach current-theory-info [ [???1] ->
              ; the theory that is considered in this loop
              ; and the root of that theory (the start)
              let cur-theory ???1
              let askstart item 0 cur-theory
              while [ i < 1 or not empty? open-rec][
                set not-admissible sentence not-admissible open-rec
                set open-rec []
                set attacked-by-me []

                ; create a list of arguments that are attacked by the current theory
                ; based on the memory of the current researcher
                if not empty? attack-relations [
                  ask turtles with [member? self args-cur-arguments and
                  mytheory = askstart][
                    if member? self cur-attacker and not member? self not-admissible [
                      ; the argument considered and a list of arguments
                      ; attacked by that argument
                      let cur-turtle self
                      let my-attacked []
                      foreach attack-relations [ [????1] ->
                        if first but-first ????1 = cur-turtle [
                          set my-attacked lput last ????1 my-attacked
                        ]
                       ]
                      set attacked-by-me sentence my-attacked attacked-by-me
                    ]
                  ]

                  ; arguments that are attacked by arguments from another theory that are
                  ; not attacked by non-attacked arguments from the current theory
                  ; are added to the open-rec list, the list of attacked-arguments
                  ask turtles with [member? self args-cur-arguments and
                    mytheory = askstart and not member? self not-admissible and
                    member? self cur-attacked][
                  let cur-turtle self
                  foreach attack-relations [ [????1] ->
                    if last ????1 = cur-turtle [
                      if not member? last but-last ????1 attacked-by-me [
                        set open-rec lput cur-turtle open-rec
                      ]
                    ]
                   ]
                    ]
                ]
                set i i + 1
              ]
              set i 0

              ; for the update of the information in current-theory-info
              set new-cur-info lput replace-item 1 cur-theory (count turtles with
                [member? self args-cur-arguments and mytheory = askstart] -
                count turtles with [member? self not-admissible and mytheory = askstart])
                  new-cur-info
             ]

            ; arguments that are part of the not-admissible list
            ; are not part of the admissible subjective arguments and hence removed
            set admissible-subj-argu subjective-arguments
            foreach subjective-arguments [ [???1] ->
              let cur-argu ???1
              if member? first cur-argu not-admissible [
                set admissible-subj-argu remove cur-argu admissible-subj-argu
              ]
             ]
            ; update the current-theory-info
            set current-theory-info new-cur-info
          ]
        ]
      ]
     ]
   ]
end


to compute-strategies-researchers-test

  ; researchers start with figuring out which argument in their
  ; memory are admissible and which are attacked
  compute-subj-attacked-test

  ask researchers with [not rep-researcher][
    set cur-best-th []
    ; variables for the list that contains the number admissible arguments
    ; per theory and a sublist which contains only the numbers that are
    ; within the strategy-threshold
    let list-admissible-arguments []
    let threshold-admissible-arguments []

    ; create a list with the number of admissible arguments
    ; of each of the theories
    foreach current-theory-info [ [?1] ->
      set list-admissible-arguments lput item 1 ?1 list-admissible-arguments
    ]
    set list-admissible-arguments sort list-admissible-arguments

    ; a list of theories with values within the strategy threshold is constructed
    set threshold-admissible-arguments filter [ [?1] -> ?1 >=
      ((max list-admissible-arguments) * strategy-threshold) ]
        list-admissible-arguments
    set threshold-admissible-arguments sort threshold-admissible-arguments

    ; computation of the current best theory
    ; theories with a number of admissible arguments that are
    ; within the threshold can be considered as current best theory
    foreach current-theory-info [ [?1] ->
      if member? item 1 ?1 threshold-admissible-arguments [
        set cur-best-th lput item 0 ?1 cur-best-th
      ]
    ]
  ]
end




to share-with-others-test2
  foreach colla-networks [ [?1] ->
    let group-sharing-done false
    let grp-share-researcher []
    let cur-group ?1
    foreach cur-group [ [??1] ->
      let cur-researcher ??1
        ifelse group-sharing-done [
          ask cur-researcher [
            set rep-researcher false
            set subjective-arguments [subjective-arguments] of grp-share-researcher
            set subjective-relations [subjective-relations] of grp-share-researcher
          ]
        ][
          set group-sharing-done true
          set grp-share-researcher cur-researcher
          ask cur-researcher [
            ; reset the variables
            set rep-researcher false
            set to-add-mem-argu []
            set to-add-mem-rel []

            ; variables to keep track of the current researchers own memory
            ; and the combined memory of all the sharing researchers
            ; let own-memory-argu subjective-arguments
            ; let own-memory-rel subjective-relations
            let comb-memory-argu []
            let comb-memory-rel []
            ; collaborator network of the current researcher
            let cur-network collaborator-network

            ; the information in the memories of the single researchers in the network
            ; are combined

            foreach cur-group [ [???1] ->
              let input-researcher ???1
              set comb-memory-argu sentence [subjective-arguments] of input-researcher comb-memory-argu
              set comb-memory-rel sentence [subjective-relations] of input-researcher comb-memory-rel
             ]

            ; each researcher adds the combined memory to its own
            ; then removing duplicates
            set subjective-arguments (merge-arg-wo-dupl-tst subjective-arguments comb-memory-argu true)
            set subjective-relations remove-duplicates sentence
              subjective-relations comb-memory-rel

              ]
            ]
           ] ]

  ; then researchers can share some of their information with researchers
  ; from neighboring networks in the social structures
  create-share-memory-test
  share-with-other-networks-test



end


to update-memories-test5
  ask researchers [
    let myx xcor
    let myy ycor
    let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      and xcor = myx and ycor = myy]
    let cur-researcher self
    ; information of current argument in the format of the memory
    let add-cur (sentence cur-argum [color] of cur-argum)
;    set subjective-arguments lput add-cur subjective-arguments
    ; list of relations (resp. arguments) that are added
    let to-add []
    let to-add-argu []
    set to-add-argu lput add-cur to-add-argu
    ; list of neighborhood arguments of the current argument
    set neighborargs []
    set neighborargs lput cur-argum neighborargs

    ; for the current argument
    ; add the neighboring discovered arguments and relations
    ; (attacks and discovery) to a to-add list
    ask cur-argum [
       if any? my-in-discoveries with [color != gray][
        ask my-in-discoveries with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added discovery relation
          let add-rel []
          set add-rel lput "d" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the child argument of the discovery relation
      if any? my-out-discoveries with [color != gray][
        ask my-out-discoveries with [color != gray][
    let add-other-end other-end
    ask cur-researcher [
      set neighborargs lput add-other-end neighborargs
    ]
    ; construction of the to be added discovery relation
    let add-rel []
    set add-rel lput "d" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput add-other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the parent argument of the attack relation
      if any? my-in-attacks with [color != gray][
        ask my-in-attacks with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the child argument of the attack relation
      if any? my-out-attacks with [color != gray][
        ask my-out-attacks with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
    ]

    ; remove duplicates from the list
    set subjective-relations remove-duplicates sentence
      subjective-relations to-add
    ; show subjective-arguments
    ; foreach to-add-argu [
      ; let argu first ?
      ; ; show ?
      ; let my-color first but-first ?
      ; ; list of entries with the same argument, but maybe different color
      ; let argu-old filter [first ? = argu] subjective-arguments
      ; ; show argu-old
      ; if not empty? argu-old [
        ; set argu-old item 0 argu-old
        ; if my-color < item 1 argu-old [
          ; let argument-position position argu-old subjective-arguments
          ; ; show argument-position
          ; ; remove entries of arguments that are also present as
          ; ; better researched entries
          ; ; set color-argu sort-by [first but-first ?1 < first but-first ?2] color-argu
          ; if argument-position != false [

            ; ; show (word "replacing position " argument-position " with " ?)
            ; set subjective-arguments replace-item argument-position subjective-arguments ?
          ; ]
        ; ]
        ; if my-color > item 1 argu-old [
              ; show "plausi check error new arg is older"
        ; ]
      ; ]
    ; ]
    ; set subjective-arguments remove-duplicates sentence
      ; subjective-arguments to-add-argu
    ; ; show subjective-arguments
  set subjective-arguments (merge-arg-wo-dupl-tst subjective-arguments to-add-argu false)
  set flag-updated-memory true
  ]

  ; every 5 plus 4 time-steps the collected information
  ; is shared with other researchers
end



to share-with-others-test5
  foreach colla-networks [ [?1] ->
    let group-sharing-done false
    let grp-share-researcher []
    let cur-group ?1
    foreach cur-group [ [??1] ->
      let cur-researcher ??1
        ifelse group-sharing-done [
          ask cur-researcher [
            set rep-researcher false
            set subjective-arguments [subjective-arguments] of grp-share-researcher
            set subjective-relations [subjective-relations] of grp-share-researcher
          ]
        ][
          set group-sharing-done true
          set grp-share-researcher cur-researcher
          ask cur-researcher [
            ; reset the variables
            set rep-researcher false
            set to-add-mem-argu []
            set to-add-mem-rel []

            ; variables to keep track of the current researchers own memory
            ; and the combined memory of all the sharing researchers
            ; let own-memory-argu subjective-arguments
            ; let own-memory-rel subjective-relations
            let comb-memory-argu []
            let comb-memory-rel []
            ; collaborator network of the current researcher
            let cur-network collaborator-network

            ; the information in the memories of the single researchers in the network
            ; are combined

            foreach cur-group [ [???1] ->
              let input-researcher ???1
              set comb-memory-argu sentence [subjective-arguments] of input-researcher comb-memory-argu
              set comb-memory-rel sentence [subjective-relations] of input-researcher comb-memory-rel
             ]

            ; each researcher adds the combined memory to its own
            ; then removing duplicates
            set subjective-arguments (merge-arg-wo-dupl-tst subjective-arguments comb-memory-argu true)
            set subjective-relations remove-duplicates sentence
              subjective-relations comb-memory-rel

              ]
            ]
     ]
   ]

  ; then researchers can share some of their information with researchers
  ; from neighboring networks in the social structures
end


to create-share-memory-test5

  ; for each collaborator-network one researcher is set to be
  ; the representative researcher
  foreach colla-networks [ [?1] ->
    ifelse length ?1 > 1 [
      ask one-of researchers with [member? self ?1][
        set rep-researcher true
      ]
    ][
      if ticks mod 25 = 4 [
        ask one-of researchers with [member? self ?1][
          set rep-researcher true
      ]
    ]
    ]
  ]

  ; only the representative researchers create a memory
  ; that they want to share with researchers from other networks
  ask researchers with [rep-researcher][
    let myx xcor
    let myy ycor
    ; variables for the argument the researcher is currently working on,
    ; the researcher itself and the theory it is working on
    let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      and xcor = myx and ycor = myy]
    let cur-researcher self
    let cur-th [mytheory] of cur-argum
    ; create a list of arguments and a list of relations that the researcher can
    ; share with researchers from other collaborative networks
    ; what researchers share depends on the "social-action" and "sharing"
    ; from the interface
    set th-args []
    set th-relations []

    ; researchers share only information obtained in the neighborhood
    ; they are currently working on
    ; collect the arguments from the researcher's memory
    ; that belong also to the neighborargs
    foreach subjective-arguments [ [?1] ->
      if member? item 0 ?1 [neighborargs] of cur-researcher [
        set th-args lput ?1 th-args
      ]
    ]
    ; collect the relations from/to the current argument
    ; from the researcher's memory
    foreach subjective-relations [ [?1] ->
      if item 1 ?1 = cur-argum or item 2 ?1 = cur-argum [
        set th-relations lput ?1 th-relations
      ]
    ]

    ; if the researcher behaves biased it does not share the attack relations that
    ; attack its current theory, these relations are removed
    if social-actions = "biased"[
      foreach th-relations [ [?1] ->
        if item 0 ?1 = "a" and [mytheory] of item 2 ?1 = cur-th [
          set th-relations remove ?1 th-relations
        ]
      ]
    ]
  ]
end



; we have the problem here that researchers which learn arguments with a older color than the one they already know in their subjective memory pay for them still although they never will include them in their memory

; procedure in which the representative researchers of the networks
; share information according to the social structure
; if a rep-researcher already exchanged information researchers in her
; sharing network i.e. if she attended the conference she will set her
; agent-owned variable "conference-attended" to true in order to not add 
; the same information multiple times
to share-with-other-networks-test5
  ask researchers with [rep-researcher][
    if not conference-attended [
      ; variables for the combined information (arguments and relations),
      ; the network of the current researcher and the theory she is working on
      let comb-memory-argu th-args
      let comb-memory-rel th-relations
      let cur-network sort collaborator-network

      ; create a list of the neighboring networks and then a
      ; list of the representative researchers (share-researchers) of these
      ; networks which will be the researchers the current researcher 
      ; shares with
      let share-researchers []
      let share-neighbors []
      foreach share-structure [ [?1] ->
        if first ?1 = cur-network [
          set share-neighbors ?1
        ]
      ]
      ask researchers with [rep-researcher][
        let cur-researcher self
        foreach share-neighbors [ [?1] ->
          if member? cur-researcher ?1 [
            set share-researchers lput cur-researcher share-researchers
          ]
        ]
      ]

      ; create a list of arguments and a list of relations that is
      ; shared among the share-researchers
      foreach share-researchers [ [?1] ->
        ; the combined memory is updated to contain the information
        ; of all the share researchers        
        set comb-memory-argu remove-duplicates sentence comb-memory-argu 
        [th-args] of ?1
        set comb-memory-rel remove-duplicates sentence comb-memory-rel 
        [th-relations] of ?1
      ]     
      ; the combined memory is written into the memory of all the current
      ; share researchers which means they obtained all the information by 
      ; attending the conference
      foreach share-researchers [ [?1] ->
        ask ?1 [
          set to-add-mem-argu comb-memory-argu
          set to-add-mem-rel comb-memory-rel
          set conference-attended true
        ]
      ]
    ]
  ]

end




to compute-time-costs-test5
  ask researchers with [rep-researcher][
    ; variables that contain the arguments and relations the
    ; researcher has to update in its memory
    let new-memory-args []
    let new-memory-rel []
    let to-add-argu []
    set new-memory-args filter [ [?1] -> not member? ?1 subjective-arguments ]
      to-add-mem-argu
    set new-memory-rel filter [ [?1] -> not member? ?1 subjective-relations ]
      to-add-mem-rel
    let comb-new sentence new-memory-args new-memory-rel
    ; every tick an researcher can obtain a maximum of 10 new entries
    ; the day that they received information is also lost
    ifelse length comb-new >= (3 * max-learn) [
      set communicating 4
    ][
    set communicating ((ceiling (length comb-new / max-learn)) + 1)
    ]

    ; every communication round an researcher can update a maximum of
    ; 3 * max-learn new arguments/relations (corresponding to three ticks of
    ; communication) these new arguments and relations are added to the
    ; memory of the researcher
    ; when a new relation is added and the arguments are not part of the
    ; memory of the researcher, these arguments are added as well
    ifelse length comb-new > (3 * max-learn) [
      set comb-new shuffle comb-new
      let repeats length comb-new - (3 * max-learn)
      while [length comb-new > repeats] [
        let cur-entr first comb-new
        let new-mem-argargs filter [ [?1] -> member? ?1 new-memory-args ] comb-new
        set new-mem-argargs map [ [?1] -> first ?1 ] new-mem-argargs
        ifelse member? cur-entr new-memory-args [
          set to-add-argu lput cur-entr to-add-argu
          set comb-new remove cur-entr comb-new
        ][
        set subjective-relations lput cur-entr subjective-relations
        set comb-new remove cur-entr comb-new
        if member? item 1 cur-entr new-mem-argargs[
          let item-1-cur-entr item 1 cur-entr
          foreach comb-new [ [?1] ->
            if item-1-cur-entr = item 0 ?1 [
              set to-add-argu lput ?1 to-add-argu
              set comb-new remove ?1 comb-new
            ]
           ]
        ]
        if member? item 2 cur-entr new-mem-argargs[
          let item-2-cur-entr item 2 cur-entr
          foreach comb-new [ [?1] ->
            if item-2-cur-entr = item 0 ?1 [
              set to-add-argu lput ?1 to-add-argu
              set comb-new remove ?1 comb-new
            ]
           ]
        ]
        ]
      ]
      set subjective-arguments (merge-arg-wo-dupl-tst subjective-arguments to-add-argu true)
    ][
    set subjective-arguments (merge-arg-wo-dupl-tst subjective-arguments new-memory-args true)
    set subjective-relations sentence subjective-relations new-memory-rel ;remove duplicates!? bug maybe -> probably no problem b/c remove duplicates for relations is run during "share-with-other-networks"
    ]
    set conference-attended false
  ]
end


to-report non-admiss-args
  ; let not-admissible []
  ; let info-not-admissible filter [not member? ? admissible-subj-argu]
    ; subjective-arguments
  ; foreach info-not-admissible [
    ; set not-admissible lput item 0 ? not-admissible
  ; ]
  report non-admiss-subj-argu
end


; move, but not both
to move-around-test6
  ; variable to make sure that the procedure find-defense
  ; is only run once
  let run-find-defense false
  ; at the beginning of the procedure no researcher has moved yet
  ask researchers [
    set moved false
  ]
  ask researchers [
    let curresearcher self
    if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
      let myargu gps
      ; let myx xcor
      ; let myy ycor
      ; ; variable for the argument the researcher is currently working on and
     ; ; the researcher itself
        ; let myargu one-of turtles with [(breed = starts or breed = arguments) and
        ; xcor = myx and ycor = myy]

      ; a list of not-admissible arguments is created
      let not-admissible []
      if admissible-subj-argu != 0 and not empty? admissible-subj-argu [
        set not-admissible non-admiss-args
        ; let info-not-admissible filter [not member? ? admissible-subj-argu]
          ; subjective-arguments
        ; foreach info-not-admissible [
          ; set not-admissible lput item 0 ? not-admissible
        ; ]
      ]

      ; an researcher working on an attacked argument will try to find a defense for
      ; this attack, by working further on the attacked argument, unless it
      ; discoveres a child-argument that that has a defense for the attack
      ; (it is not necessarily the case that this defense is already discovered)
      ; the find-defense runs immediately for all researchers working on a not
      ; fully researched not-admissible argument, hence it is only once executed
      if member? myargu not-admissible and not moved[

        if not run-find-defense [
          find-defense-test6
          set run-find-defense true
        ]
      ]

      if not moved and not member? myargu not-admissible or
        (member? myargu not-admissible and [color] of myargu = red)[

        ; when an argument exists that:
        ; a) is a child-argument of the current argument;
        ; b) is not gray, red or turquoise; and
        ; c) no researcher from the same collaborator-network is working on it
        ; the researcher moves there, with certain probability
        ifelse any? turtles with [(breed = starts or breed = arguments) and
          in-discovery-neighbor? myargu and color != gray and color != red and
        color != turquoise and not (any? turtles with [breed = researchers and
    xcor = [xcor] of myself and ycor = [ycor] of myself and member? self
    [collaborator-network] of curresearcher])] [
        let move-random random-float 1.0


        ; every time step with small-movement of the move-probability
        ; the researcher moves
        ifelse move-random < (small-movement * move-probability *
          (1 - (color / color-move))) [
          move-to one-of turtles with [(breed = starts or breed = arguments) and
            in-discovery-neighbor? myargu and color != gray and color != red and
            color != turquoise and not ( any? turtles with [breed = researchers and
            xcor = [xcor] of myself and ycor = [ycor] of myself and member? self
        [collaborator-network] of curresearcher])]
          set moved true
        ][

        ; every 5th time step the researcher mover with the full move-probability,
        ; that depends a bit on the color
        if ticks != 0 and ticks mod 5 = 0 and move-random <
          move-probability * (1 - (color / color-move)) [
          move-to one-of turtles with [(breed = starts or breed = arguments) and
            in-discovery-neighbor? myargu and color != gray and color != red and
      color != turquoise and not ( any? turtles with [breed = researchers
      and xcor = [xcor] of myself and ycor = [ycor] of myself and
      member? self [collaborator-network] of curresearcher])]
          set moved true
        ]
        ]
            ][

        ; if there is no next argument and the current argument is
        ; fully researched, the researcher moves a step back
        ifelse [color] of myargu = red and any? turtles with [color != gray and
          color != turquoise and out-discovery-neighbor? myargu and not any?
    turtles with [breed = researchers and xcor = [xcor] of myself and
    ycor = [ycor] of myself and member? self [collaborator-network]
    of curresearcher]][
        move-to one-of turtles with [color != gray and out-discovery-neighbor?
          myargu and not any? turtles with [breed = researchers and xcor = [xcor] of
          myself and ycor = [ycor] of myself and member? self
          [collaborator-network] of curresearcher]]
        set moved true
          ][

        ; if moving back is not possible, it jumps to another argument in
        ; the same tree/theory that is discovered but not fully researched
        if [color] of myargu = red[
          let askstart [mytheory] of myargu
          if any? turtles with [(breed = starts or breed = arguments) and
      color != gray and color != turquoise and color != red and
      mytheory = askstart and not any? turtles with [breed = researchers and
        xcor = [xcor] of myself and ycor = [ycor] of myself and member?
      self [collaborator-network] of curresearcher]][
          move-to one-of turtles with [(breed = starts or breed = arguments) and
     color != turquoise and color != gray and color != red and
       mytheory = askstart and not any? turtles with [breed = researchers and
     xcor = [xcor] of myself and ycor = [ycor] of myself and member? self
           [collaborator-network] of curresearcher]]
          set moved true
            ]
        ]
          ]
            ]
      ]
    ]
  ]
end





; researchers working on a not fully researched attacked argument will try to find a
; defense for that attack, by staying on the current argument
; if a child-argument is discovered that can provide a defense, the
; researcher moves there
; once an argument is fully researched all its relations are discovered,
; then an researcher can move on and can try to find a defense in another branch,
; further away
to find-defense-test6
  ask researchers with [not moved][
    let curresearcher self
    if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
      let myargu gps
      ; let myx xcor
      ; let myy ycor
      ; ; variables for the argument the researcher is working on and
      ; ; for the researcher itself
      ; let myargu one-of turtles with [(breed = starts or breed = arguments) and
        ; xcor = myx and ycor = myy]

      ; lists of arguments that are not admissible
      let not-admissible []
      if admissible-subj-argu != 0 and not empty? admissible-subj-argu [
        set not-admissible non-admiss-args
      ]
      ; let not-admissible []
      ; if admissible-subj-argu != 0 and not empty? admissible-subj-argu [
        ; let info-not-admissible filter [not member? ? admissible-subj-argu]
          ; subjective-arguments
        ; foreach info-not-admissible [
          ; set not-admissible lput item 0 ? not-admissible
        ; ]
      ; ]

      ; if the current argument is not fully researched and not admissible
      ; and it is a 5th time step or the researcher is not communicating
      ; the researcher tries to move prospectively to a child-argument of the current
      ; argument that provides a defense for the current argument
      if member? myargu not-admissible[
        ask myargu [
          ask my-in-attacks [
            ask end1 [
              ; create a set of arguments that provide a defense for the current
        ; argument, these:
              ; a) attack the attacker of the current argument;
        ; b) are a child-argument of the current argument;
              ; c) are discovered; and
        ; d) no researcher from the same network is working on it
              let nextargu in-attack-neighbors with [in-discovery-neighbor?
          myargu and color != gray and color != turquoise and not (any?
    researchers with [xcor = [xcor] of myself and ycor = [ycor] of myself
    and member? self [collaborator-network] of curresearcher])]
              ; if such an argument exists the researcher moves there
              ; and cannot move anymore this time step
              if any? nextargu [
                ask curresearcher [
                  move-to one-of nextargu
                  set moved true
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
end





to compute-subj-attacked-test6
  foreach colla-networks [ [?1] ->
    let calc-done false
    let calc-researcher []
    let cur-group ?1
    foreach cur-group [ [??1] ->
      let cur-researcher ??1
      if not [rep-researcher] of cur-researcher [
        ifelse calc-done [
          ask cur-researcher [
            set admissible-subj-argu [admissible-subj-argu] of calc-researcher
            set current-theory-info [current-theory-info] of calc-researcher
            set non-admiss-subj-argu [non-admiss-subj-argu] of calc-researcher
          ]
        ][
          set calc-done true
          set calc-researcher cur-researcher
          ask cur-researcher [
            ; variables for lists that contain:
            ; the current-theory-info with 0 admissible arguments; an updated number
            ; of admissible arguments during the recursive computation; the arguments
            ; that are not admissible; the arguments that the researchers knows about; and
            ; the arguments that are attacked by the current theory
            let new-info []
            let new-cur-info []
            let not-admissible []
            let args-cur-arguments []
            let attacked-by-me []

            ; create a list of only the attacks
            let attack-relations []
            foreach subjective-relations [ [???1] ->
              if first ???1 = "a" [
                set attack-relations lput ???1 attack-relations
              ]
             ]
            ; create lists of attacked and attacking arguments
            let cur-attacked []
            let cur-attacker []
            foreach attack-relations [ [???1] ->
              set cur-attacked lput last ???1 cur-attacked
              set cur-attacker lput first but-first ???1 cur-attacker
             ]

            ; create a list of the arguments the researchers knows about and
            ; set the number of admissible arguments for each theory to 0
            foreach subjective-arguments [ [???1] ->
              set args-cur-arguments lput first ???1 args-cur-arguments
             ]
            foreach current-theory-info [ [???1] ->
              set new-info lput replace-item 1 ???1 0 new-info
             ]
            set current-theory-info new-info

            ; the computation of the admissible arguments is done recursively
            ; a list of arguments that are currently considered attacked
            let open-rec []
            ; variable that lets the loop run at least one time
            let i 0
            foreach current-theory-info [ [???1] ->
              ; the theory that is considered in this loop
              ; and the root of that theory (the start)
              let cur-theory ???1
              let askstart item 0 cur-theory
              while [ i < 1 or not empty? open-rec][
                set not-admissible sentence not-admissible open-rec
                set open-rec []
                set attacked-by-me []

                ; create a list of arguments that are attacked by the current theory
                ; based on the memory of the current researcher
                if not empty? attack-relations [
                  ask turtles with [member? self args-cur-arguments and
                  mytheory = askstart][
                    if member? self cur-attacker and not member? self not-admissible [
                      ; the argument considered and a list of arguments
                      ; attacked by that argument
                      let cur-turtle self
                      let my-attacked []
                      foreach attack-relations [ [????1] ->
                        if first but-first ????1 = cur-turtle [
                          set my-attacked lput last ????1 my-attacked
                        ]
                       ]
                      set attacked-by-me sentence my-attacked attacked-by-me
                    ]
                  ]

                  ; arguments that are attacked by arguments from another theory that are
                  ; not attacked by non-attacked arguments from the current theory
                  ; are added to the open-rec list, the list of attacked-arguments
                  ask turtles with [member? self args-cur-arguments and
                    mytheory = askstart and not member? self not-admissible and
                    member? self cur-attacked][
                  let cur-turtle self
                  foreach attack-relations [ [????1] ->
                    if last ????1 = cur-turtle [
                      if not member? last but-last ????1 attacked-by-me [
                        set open-rec lput cur-turtle open-rec
                      ]
                    ]
                   ]
                    ]
                ]
                set i i + 1
              ]
              set i 0

              ; for the update of the information in current-theory-info
              set new-cur-info lput replace-item 1 cur-theory (count turtles with
                [member? self args-cur-arguments and mytheory = askstart] -
                count turtles with [member? self not-admissible and mytheory = askstart])
                  new-cur-info
             ]

            ; arguments that are part of the not-admissible list
            ; are not part of the admissible subjective arguments and hence removed
            set admissible-subj-argu subjective-arguments
            set non-admiss-subj-argu []
            foreach subjective-arguments [ [???1] ->
              let cur-argu ???1
              if member? first cur-argu not-admissible [
                set admissible-subj-argu remove cur-argu admissible-subj-argu
                set non-admiss-subj-argu lput item 0 cur-argu non-admiss-subj-argu
              ]
             ]
            ; update the current-theory-info
            set current-theory-info new-cur-info
          ]
        ]
      ]
     ]
   ]
end


to compute-strategies-researchers-test6

  ; researchers start with figuring out which argument in their
  ; memory are admissible and which are attacked
  ; compute-subj-attacked-test

  ask researchers with [not rep-researcher][
    set cur-best-th []
    ; variables for the list that contains the number admissible arguments
    ; per theory and a sublist which contains only the numbers that are
    ; within the strategy-threshold
    let list-admissible-arguments []
    let threshold-admissible-arguments []

    ; create a list with the number of admissible arguments
    ; of each of the theories
    foreach current-theory-info [ [?1] ->
      set list-admissible-arguments lput item 1 ?1 list-admissible-arguments
    ]
    set list-admissible-arguments sort list-admissible-arguments

    ; a list of theories with values within the strategy threshold is constructed
    set threshold-admissible-arguments filter [ [?1] -> ?1 >=
      ((max list-admissible-arguments) * strategy-threshold) ]
        list-admissible-arguments
    set threshold-admissible-arguments sort threshold-admissible-arguments

    ; computation of the current best theory
    ; theories with a number of admissible arguments that are
    ; within the threshold can be considered as current best theory
    foreach current-theory-info [ [?1] ->
      if member? item 1 ?1 threshold-admissible-arguments [
        set cur-best-th lput item 0 ?1 cur-best-th
      ]
    ]
  ]
end


to update-memories-test7
  ask researchers [
    let cur-argum gps
    ; let myx xcor
    ; let myy ycor
    ; let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      ; and xcor = myx and ycor = myy]
    let cur-researcher self
    ; information of current argument in the format of the memory
    let add-cur (sentence cur-argum [color] of cur-argum)
;    set subjective-arguments lput add-cur subjective-arguments
    ; list of relations (resp. arguments) that are added
    let to-add []
    let to-add-argu []
    set to-add-argu lput add-cur to-add-argu
    ; list of neighborhood arguments of the current argument
    set neighborargs []
    set neighborargs lput cur-argum neighborargs

    ; for the current argument
    ; add the neighboring discovered arguments and relations
    ; (attacks and discovery) to a to-add list
    ask cur-argum [
       if any? my-in-discoveries with [color != gray][
        ask my-in-discoveries with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added discovery relation
          let add-rel []
          set add-rel lput "d" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the child argument of the discovery relation
      if any? my-out-discoveries with [color != gray][
        ask my-out-discoveries with [color != gray][
    let add-other-end other-end
    ask cur-researcher [
      set neighborargs lput add-other-end neighborargs
    ]
    ; construction of the to be added discovery relation
    let add-rel []
    set add-rel lput "d" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput add-other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the parent argument of the attack relation
      if any? my-in-attacks with [color != gray][
        ask my-in-attacks with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the child argument of the attack relation
      if any? my-out-attacks with [color != gray][
        ask my-out-attacks with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
    ]

    ; remove duplicates from the list
    set subjective-relations remove-duplicates sentence
      subjective-relations to-add
    ; show subjective-arguments
    ; foreach to-add-argu [
      ; let argu first ?
      ; ; show ?
      ; let my-color first but-first ?
      ; ; list of entries with the same argument, but maybe different color
      ; let argu-old filter [first ? = argu] subjective-arguments
      ; ; show argu-old
      ; if not empty? argu-old [
        ; set argu-old item 0 argu-old
        ; if my-color < item 1 argu-old [
          ; let argument-position position argu-old subjective-arguments
          ; ; show argument-position
          ; ; remove entries of arguments that are also present as
          ; ; better researched entries
          ; ; set color-argu sort-by [first but-first ?1 < first but-first ?2] color-argu
          ; if argument-position != false [

            ; ; show (word "replacing position " argument-position " with " ?)
            ; set subjective-arguments replace-item argument-position subjective-arguments ?
          ; ]
        ; ]
        ; if my-color > item 1 argu-old [
              ; show "plausi check error new arg is older"
        ; ]
      ; ]
    ; ]
    ; set subjective-arguments remove-duplicates sentence
      ; subjective-arguments to-add-argu
    ; ; show subjective-arguments
  set subjective-arguments (merge-arg-wo-dupl-tst subjective-arguments to-add-argu false)
  set flag-updated-memory true
  ]

  ; every 5 plus 4 time-steps the collected information
  ; is shared with other researchers
end



to create-share-memory-test7

  ; for each collaborator-network one researcher is set to be
  ; the representative researcher
  foreach colla-networks [ [?1] ->
    ifelse length ?1 > 1 [
      ask one-of researchers with [member? self ?1][
        set rep-researcher true
      ]
    ][
      if ticks mod 25 = 4 [
        ask one-of researchers with [member? self ?1][
          set rep-researcher true
      ]
    ]
    ]
  ]

  ; only the representative researchers create a memory
  ; that they want to share with researchers from other networks
  ask researchers with [rep-researcher][
    let cur-argum gps
    ; let myx xcor
    ; let myy ycor
    ; ; variables for the argument the researcher is currently working on,
    ; ; the researcher itself and the theory it is working on
    ; let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      ; and xcor = myx and ycor = myy]
    let cur-researcher self
    let cur-th [mytheory] of cur-argum
    ; create a list of arguments and a list of relations that the researcher can
    ; share with researchers from other collaborative networks
    ; what researchers share depends on the "social-action" and "sharing"
    ; from the interface
    set th-args []
    set th-relations []

    ; researchers share only information obtained in the neighborhood
    ; they are currently working on
    ; collect the arguments from the researcher's memory
    ; that belong also to the neighborargs
    foreach subjective-arguments [ [?1] ->
      if member? item 0 ?1 [neighborargs] of cur-researcher [
        set th-args lput ?1 th-args
      ]
    ]
    ; collect the relations from/to the current argument
    ; from the researcher's memory
    foreach subjective-relations [ [?1] ->
      if item 1 ?1 = cur-argum or item 2 ?1 = cur-argum [
        set th-relations lput ?1 th-relations
      ]
    ]

    ; if the researcher behaves biased it does not share the attack relations that
    ; attack its current theory, these relations are removed
    if social-actions = "biased"[
      foreach th-relations [ [?1] ->
        if item 0 ?1 = "a" and [mytheory] of item 2 ?1 = cur-th [
          set th-relations remove ?1 th-relations
        ]
      ]
    ]
  ]
end

; based on their own memory
to act-on-strat-ag-tst7
  ask researchers with [not rep-researcher][
    ; only when there is a current best theory
    ; it makes sense for the researchers to want to work on that theory
    if not empty? cur-best-th and not member? nobody cur-best-th [
      let myargu gps
      ; let myx xcor
      ; let myy ycor

      ; if the researcher is not currently working on the best theory
      ; it considers jumping
      foreach subjective-arguments [ [?1] ->
        let cur-subj-argu item 0 ?1
        if cur-subj-argu = myargu and not member? [mytheory] of cur-subj-argu cur-best-th [
          set theory-jump theory-jump + 1
        ]
        ; if [xcor] of item 0 ? = myx and [ycor] of item 0 ? = myy and
        ; not member? [mytheory] of item 0 ? cur-best-th [
          ; set theory-jump theory-jump + 1
        ; ]
      ]

      ; if the researcher has considered jumping jump-threshold times
      ; it jumps to one of the theories it considers best, based
      ; on its memory and the computations
      if theory-jump >= jump-threshold [
        let ch-best one-of cur-best-th
        let subj-argus []
        foreach subjective-arguments [ [?1] ->
          set subj-argus lput item 0 ?1 subj-argus
        ]

        ; if one of the arguments from the best theory is in its memory
        ; the researcher will jump there
        ifelse any? startsargum with [
          member? self subj-argus and mytheory = ch-best and color != turquoise][
            move-to one-of startsargum with [
              member? self subj-argus and mytheory = ch-best and color != turquoise]
          ][ ; otherwise the researcher jumps to the root of the theory
          move-to ch-best
          ]

        set times-jumped times-jumped + 1
        set theory-jump 0
      ]
    ]
  ]
end


to compute-popularity-tst7
  ; initialize the variable at 0
  ask starts [ set myscientists 0 ]
  ask researchers [
    ; variables for x and y coordinate of the current researcher,
    ; the argument it is currently working on and the
    ; theory this argument belongs to
    let myargu gps
    ; let myx xcor
    ; let myy ycor
    ; let myargu one-of turtles with [(breed = starts or breed = arguments) and
      ; xcor = myx and ycor = myy]
    let mystart [mytheory] of myargu

    ; the myscientists variable of the theory the researcher
    ; is working on is increased by one
    ask mystart [
      set myscientists myscientists + 1
    ]
  ]
end


; move, but not both
to move-around-test7
  ; variable to make sure that the procedure find-defense
  ; is only run once
  let run-find-defense false
  ; at the beginning of the procedure no researcher has moved yet
  ask researchers [
    set moved false
  ]
  ask researchers [
    let curresearcher self
    if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
      let myargu gps
      ; let myx xcor
      ; let myy ycor
      ; ; variable for the argument the researcher is currently working on and
     ; ; the researcher itself
        ; let myargu one-of turtles with [(breed = starts or breed = arguments) and
        ; xcor = myx and ycor = myy]

      ; a list of not-admissible arguments is created
      let not-admissible []
      if admissible-subj-argu != 0 and not empty? admissible-subj-argu [
        set not-admissible non-admiss-args
        ; let info-not-admissible filter [not member? ? admissible-subj-argu]
          ; subjective-arguments
        ; foreach info-not-admissible [
          ; set not-admissible lput item 0 ? not-admissible
        ; ]
      ]

      ; an researcher working on an attacked argument will try to find a defense for
      ; this attack, by working further on the attacked argument, unless it
      ; discoveres a child-argument that that has a defense for the attack
      ; (it is not necessarily the case that this defense is already discovered)
      ; the find-defense runs immediately for all researchers working on a not
      ; fully researched not-admissible argument, hence it is only once executed
      if member? myargu not-admissible and not moved[

        if not run-find-defense [
          find-defense-test7
          set run-find-defense true
        ]
      ]

      if not moved and not member? myargu not-admissible or
        (member? myargu not-admissible and [color] of myargu = red)[

        ; when an argument exists that:
        ; a) is a child-argument of the current argument;
        ; b) is not gray, red or turquoise; and
        ; c) no researcher from the same collaborator-network is working on it
        ; the researcher moves there, with certain probability
        ifelse any? startsargum with [in-discovery-neighbor? myargu
        and [not member? color [gray red turquoise]] of self
          ; and color != gray and color != red and color != turquoise
          and not group-member-here curresearcher
          ; (any? turtles with [breed = researchers and
    ; xcor = [xcor] of myself and ycor = [ycor] of myself and member? self
    ; [collaborator-network] of curresearcher])
    ] [
        let move-random random-float 1.0


        ; every time step with small-movement of the move-probability
        ; the researcher moves
        ifelse move-random < (small-movement * move-probability *
          (1 - (color / color-move))) [
          move-to one-of startsargum with [
            in-discovery-neighbor? myargu
            and [not member? color [gray red turquoise]] of self
            ; and color != gray and color != red and
            ; color != turquoise
            and not group-member-here curresearcher
            ; ( any? turtles with [breed = researchers and
            ; xcor = [xcor] of myself and ycor = [ycor] of myself and member? self
        ; [collaborator-network] of curresearcher])
        ]
          set moved true
        ][

        ; every 5th time step the researcher mover with the full move-probability,
        ; that depends a bit on the color
        if ticks != 0 and ticks mod 5 = 0 and move-random <
          move-probability * (1 - (color / color-move)) [
          move-to one-of startsargum with [
            in-discovery-neighbor? myargu
            and [not member? color [gray red turquoise]] of self
            ; and color != gray and color != red and
      ; color != turquoise
      and not group-member-here curresearcher
      ; ( any? turtles with [breed = researchers
      ; and xcor = [xcor] of myself and ycor = [ycor] of myself and
      ; member? self [collaborator-network] of curresearcher])
      ]
          set moved true
        ]
        ]
            ][

        ; if there is no next argument and the current argument is
        ; fully researched, the researcher moves a step back
        ifelse [color] of myargu = red and any? startsargum with [
        [not member? color [gray turquoise]] of self
        ; color != gray and
          ; color != turquoise
          and out-discovery-neighbor? myargu and not group-member-here curresearcher
          ; any?
    ; turtles with [breed = researchers and xcor = [xcor] of myself and
    ; ycor = [ycor] of myself and member? self [collaborator-network]
    ; of curresearcher]
    ][
        move-to one-of startsargum with [
        [not member? color [gray turquoise]] of self
        ; color != gray
        and out-discovery-neighbor?
          myargu and not group-member-here curresearcher
          ; any? turtles with [breed = researchers and xcor = [xcor] of
          ; myself and ycor = [ycor] of myself and member? self
          ; [collaborator-network] of curresearcher]
          ]
        set moved true
          ][

        ; if moving back is not possible, it jumps to another argument in
        ; the same tree/theory that is discovered but not fully researched
        if [color] of myargu = red[
          let askstart [mytheory] of myargu
          if any? startsargum with [
          [not member? color [gray red turquoise]] of self
      ; color != gray and color != turquoise and color != red
      and
      mytheory = askstart and not group-member-here curresearcher
      ; any? turtles with [breed = researchers and
        ; xcor = [xcor] of myself and ycor = [ycor] of myself and member?
      ; self [collaborator-network] of curresearcher]
      ][
          move-to one-of startsargum with [
          [not member? color [gray red turquoise]] of self
          ; and color != turquoise and color != gray and color != red
     and
       mytheory = askstart and not group-member-here curresearcher
       ; any? turtles with [breed = researchers and
     ; xcor = [xcor] of myself and ycor = [ycor] of myself and member? self
           ; [collaborator-network] of curresearcher]
           ]
          set moved true
            ]
        ]
          ]
            ]
      ]
    ]
  ]
end


to find-defense-test7
  ask researchers with [not moved][
    let curresearcher self
    if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
      let myargu gps
      ; let myx xcor
      ; let myy ycor
      ; ; variables for the argument the researcher is working on and
      ; ; for the researcher itself
      ; let myargu one-of turtles with [(breed = starts or breed = arguments) and
        ; xcor = myx and ycor = myy]

      ; lists of arguments that are not admissible
      let not-admissible []
      if admissible-subj-argu != 0 and not empty? admissible-subj-argu [
        set not-admissible non-admiss-args
      ]
      ; let not-admissible []
      ; if admissible-subj-argu != 0 and not empty? admissible-subj-argu [
        ; let info-not-admissible filter [not member? ? admissible-subj-argu]
          ; subjective-arguments
        ; foreach info-not-admissible [
          ; set not-admissible lput item 0 ? not-admissible
        ; ]
      ; ]

      ; if the current argument is not fully researched and not admissible
      ; and it is a 5th time step or the researcher is not communicating
      ; the researcher tries to move prospectively to a child-argument of the current
      ; argument that provides a defense for the current argument
      if member? myargu not-admissible[
        ask myargu [
          ask my-in-attacks [
            ask end1 [
              ; create a set of arguments that provide a defense for the current
        ; argument, these:
              ; a) attack the attacker of the current argument;
        ; b) are a child-argument of the current argument;
              ; c) are discovered; and
        ; d) no researcher from the same network is working on it
              let nextargu in-attack-neighbors with [in-discovery-neighbor?
          myargu and
          [not member? color [gray turquoise]] of self
          ; color != gray and color != turquoise
          and not group-member-here curresearcher
          ; (any?
    ; researchers with [xcor = [xcor] of myself and ycor = [ycor] of myself
    ; and member? self [collaborator-network] of curresearcher])
    ]
              ; if such an argument exists the researcher moves there
              ; and cannot move anymore this time step
              if any? nextargu [
                ask curresearcher [
                  move-to one-of nextargu
                  set moved true
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
end


; every five time steps the landscape is updated:
; new arguments become visible and attacks are discovered

to update-landscape-test7
  ask startsargum [
    let myx xcor
    let myy ycor
    ; discoveries only occur when an researcher is working on that argument,
    ; it is the 5th time step or the researcher does not communicate
    ; working on an argument means that the researcher did
    ; not communicate in that round
    if non-comm-scientists-here myx myy
    ; any? researchers with [xcor = myx and ycor = myy and
      ; communicating = 0] or (any? researchers with [
      ; xcor = myx and ycor = myy] and ticks mod 5 = 0)
    [
      set researcher-ticks researcher-ticks + 1

      ; the color of an argument is changed if researchers have been working
      ; on that argument for research-speed time steps
      if researcher-ticks mod research-speed = 0 and color != red[
        set color color - 10
        if color = red [set full-research true]
      ]

      ; depending on the color a new child-argument is discovered, until all
      ; child-arguments are discovered
      if color = yellow and count out-discovery-neighbors with
  [color = gray or color = turquoise] >= 4 [
        ask one-of out-discovery-neighbors with
    [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
      if color = brown and count out-discovery-neighbors with
  [color = gray or color = turquoise] >= 3 [
        ask one-of out-discovery-neighbors with
    [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
      if color = orange and count out-discovery-neighbors with
  [color = gray or color = turquoise] >= 2 [
       ask one-of out-discovery-neighbors with
         [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
      if color = red and count out-discovery-neighbors with
  [color = gray or color = turquoise] >= 1 [
        ask one-of out-discovery-neighbors with
     [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]

      ; for arguments that have still undiscovered relations/neighbors and are
      ; not fully researched
      if ticks mod 5 = 0 and color != red [
        let attack-random random-float 1.00

        ; with visibility-probability a new attacked/attacking argument is
        ; discovered
        if attack-random < visibility-probability [
          if any? my-links with [breed = attacks and color = gray][
            ask one-of my-links with [breed = attacks and color = gray][
              set color red
              ask other-end [if color = gray [set color turquoise]]
            ]
          ]
        ]
      ]
    ]

    ; once an argument is fully researched all its relations to other arguments
    ; are discovered as well
    ; full-discovery-test7

    ; if both ends of a discovery relation are discovered
    ; by research, the relation is discovered as well
    if color != gray [
      ask my-out-discoveries with [color = gray][
        if [not member? color [gray turquoise]] of other-end
        ; [color] of other-end != gray and [color] of other-end != turquoise
        [
          set color cyan
        ]
      ]
    ]
  ]

  ; at the end of the time steps 1, 2, 3 and 4 communicating researchers
  ; decrease their communicating value by 1
  ; if ticks mod 5 != 0 [
    ; ask researchers with [communicating > 0][
      ; set communicating communicating - 1
    ; ]
  ; ]
end



; procedure that makes sure that fully researched arguments have a fully
; discovered neighborhood
to full-discovery-test7
  ask startsargum with [full-research][
    let myx xcor
    let myy ycor
    if non-comm-scientists-here myx myy
    ; any? researchers with [xcor = myx and ycor = myy and
      ; communicating = 0] or (ticks mod 5 = 0 and any? researchers with
      ; [xcor = myx and ycor = myy])
      [

      ; once an argument is fully researched all its relations,
      ; attack and discovery, are discovered
      if any? out-discovery-neighbors with [color = gray or color = turquoise][
        ask out-discovery-neighbors with [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]

      ; note that in the case of an attack relation the other argument
      ; is not really discovered: it needs to be discovered by a discovery
      ; relation in the other theory to become lime
      if any? my-in-attacks with [color = gray][
        ask my-in-attacks with [color = gray][
          set color red
          ask other-end [if color = gray [set color turquoise]]
        ]
      ]
      if any? my-out-attacks with [color = gray][
        ask my-out-attacks with [color = gray][
          set color red
          ask other-end [if color = gray [set color turquoise]]
        ]
      ]
    ]
    set full-research false
  ]
end




to compute-subj-attacked-test7
  foreach colla-networks [ [?1] ->
    let calc-done false
    let calc-researcher []
    let cur-group ?1
    foreach cur-group [ [??1] ->
      let cur-researcher ??1
      if not [rep-researcher] of cur-researcher [
        ifelse calc-done [
          ask cur-researcher [
            set admissible-subj-argu [admissible-subj-argu] of calc-researcher
            set current-theory-info [current-theory-info] of calc-researcher
            set non-admiss-subj-argu [non-admiss-subj-argu] of calc-researcher
          ]
        ][
          set calc-done true
          set calc-researcher cur-researcher
          ask cur-researcher [
            ; variables for lists that contain:
            ; the current-theory-info with 0 admissible arguments; an updated number
            ; of admissible arguments during the recursive computation; the arguments
            ; that are not admissible; the arguments that the researchers knows about; and
            ; the arguments that are attacked by the current theory
            let new-info []
            let new-cur-info []
            let not-admissible []
            let args-cur-arguments []
            let attacked-by-me []

            ; create a list of only the attacks
            let attack-relations []
            foreach subjective-relations [ [???1] ->
              if first ???1 = "a" [
                set attack-relations lput ???1 attack-relations
              ]
             ]
            ; create lists of attacked and attacking arguments
            let cur-attacked []
            let cur-attacker []
            foreach attack-relations [ [???1] ->
              set cur-attacked lput last ???1 cur-attacked
              set cur-attacker lput first but-first ???1 cur-attacker
             ]

            ; create a list of the arguments the researchers knows about and
            ; set the number of admissible arguments for each theory to 0
            foreach subjective-arguments [ [???1] ->
              set args-cur-arguments lput first ???1 args-cur-arguments
             ]
            foreach current-theory-info [ [???1] ->
              set new-info lput replace-item 1 ???1 0 new-info
             ]
            set current-theory-info new-info

            ; the computation of the admissible arguments is done recursively
            ; a list of arguments that are currently considered attacked
            let open-rec []
            ; variable that lets the loop run at least one time
            let i 0
            foreach current-theory-info [ [???1] ->
              ; the theory that is considered in this loop
              ; and the root of that theory (the start)
              let cur-theory ???1
              let askstart item 0 cur-theory
              while [ i < 1 or not empty? open-rec][
                set not-admissible sentence not-admissible open-rec
                set open-rec []
                set attacked-by-me []

                ; create a list of arguments that are attacked by the current theory
                ; based on the memory of the current researcher
                if not empty? attack-relations [
                  ask startsargum with [member? self args-cur-arguments and
                  mytheory = askstart][
                    if member? self cur-attacker and not member? self not-admissible [
                      ; the argument considered and a list of arguments
                      ; attacked by that argument
                      let cur-turtle self
                      let my-attacked []
                      foreach attack-relations [ [????1] ->
                        if first but-first ????1 = cur-turtle [
                          set my-attacked lput last ????1 my-attacked
                        ]
                       ]
                      set attacked-by-me sentence my-attacked attacked-by-me
                    ]
                  ]

                  ; arguments that are attacked by arguments from another theory that are
                  ; not attacked by non-attacked arguments from the current theory
                  ; are added to the open-rec list, the list of attacked-arguments
                  ask startsargum with [member? self args-cur-arguments and
                    mytheory = askstart and not member? self not-admissible and
                    member? self cur-attacked][
                  let cur-turtle self
                  foreach attack-relations [ [????1] ->
                    if last ????1 = cur-turtle [
                      if not member? last but-last ????1 attacked-by-me [
                        set open-rec lput cur-turtle open-rec
                      ]
                    ]
                   ]
                    ]
                ]
                set i i + 1
              ]
              set i 0

              ; for the update of the information in current-theory-info
              set new-cur-info lput replace-item 1 cur-theory (count startsargum with
                [member? self args-cur-arguments and mytheory = askstart] -
                count startsargum with [member? self not-admissible and mytheory = askstart])
                  new-cur-info
             ]

            ; arguments that are part of the not-admissible list
            ; are not part of the admissible subjective arguments and hence removed
            set admissible-subj-argu subjective-arguments
            set non-admiss-subj-argu []
            foreach subjective-arguments [ [???1] ->
              let cur-argu ???1
              if member? first cur-argu not-admissible [
                set admissible-subj-argu remove cur-argu admissible-subj-argu
                set non-admiss-subj-argu lput item 0 cur-argu non-admiss-subj-argu
              ]
             ]
            ; update the current-theory-info
            set current-theory-info new-cur-info
          ]
        ]
      ]
     ]
   ]
end




to share-with-others-test8
  foreach colla-networks [ [?1] ->
    let group-sharing-done false
    let grp-share-researcher []
    let cur-group ?1
    foreach cur-group [ [??1] ->
      let cur-researcher ??1
        ifelse group-sharing-done [
          ask cur-researcher [
            set rep-researcher false
            set subjective-arguments [subjective-arguments] of grp-share-researcher
            set subjective-relations [subjective-relations] of grp-share-researcher
          ]
        ][
          set group-sharing-done true
          set grp-share-researcher cur-researcher
          ask cur-researcher [
            ; reset the variables
            set rep-researcher false
            set to-add-mem-argu []
            set to-add-mem-rel []

            ; variables to keep track of the current researchers own memory
            ; and the combined memory of all the sharing researchers
            ; let own-memory-argu subjective-arguments
            ; let own-memory-rel subjective-relations
            let comb-memory-argu []
            let comb-memory-rel []
            ; collaborator network of the current researcher
            let cur-network collaborator-network

            ; the information in the memories of the single researchers in the network
            ; are combined

            foreach cur-group [ [???1] ->
              let input-researcher ???1
              set comb-memory-argu remove-duplicates sentence [subjective-arguments] of input-researcher comb-memory-argu
              set comb-memory-rel remove-duplicates sentence [subjective-relations] of input-researcher comb-memory-rel
             ]

            ; each researcher adds the combined memory to its own
            ; then removing duplicates
            set subjective-arguments (list-cleaner3 comb-memory-argu)
            set subjective-relations comb-memory-rel

              ]
            ]
     ]
   ]

  ; then researchers can share some of their information with researchers
  ; from neighboring networks in the social structures
end

to-report arg-list-reformat-in [colorarglist]
  let redargs []
  let orangeargs []
  let brownargs []
  let yellowargs []
  let greenargs []
  let limeargs []
  let turquoiseargs []
  let argulist []
  foreach colorarglist
  [ [colorarg] ->
    let curargu item 0 colorarg
    let curcolor item 1 colorarg
    set argulist lput curargu argulist
    if curcolor = 15 [
      set redargs lput curargu redargs
    ]
    if curcolor = 25 [
      set orangeargs lput curargu orangeargs
    ]
    if curcolor = 35 [
      set brownargs lput curargu brownargs
    ]
    if curcolor = 45 [
      set yellowargs lput curargu yellowargs
    ]
    if curcolor = 55 [
      set greenargs lput curargu greenargs
    ]
    if curcolor = 65 [
      set limeargs lput curargu limeargs
    ]
    if curcolor = 75 [
      set turquoiseargs lput curargu turquoiseargs
    ]
  ]
  set argulist remove-duplicates argulist
  let newarglist (list redargs orangeargs brownargs yellowargs greenargs limeargs turquoiseargs argulist)
  report newarglist
end

to-report arg-list-reformat-out [newarglist]
  let redargs item 0 newarglist
  let orangeargs item 1 newarglist
  let brownargs item 2 newarglist
  let yellowargs item 3 newarglist
  let greenargs item 4 newarglist
  let limeargs item 5 newarglist
  let turquoiseargs item 6 newarglist
  let argulist item 7 newarglist
  let colorarglist []
  foreach argulist
  [ [argu] ->
    ifelse member? argu redargs [
      set colorarglist lput list argu 15 colorarglist
    ][
      ifelse member? argu orangeargs [
        set colorarglist lput list argu 25 colorarglist
      ][
        ifelse member? argu orangeargs [
          set colorarglist lput list argu 35 colorarglist
        ][
          ifelse member? argu orangeargs [
            set colorarglist lput list argu 45 colorarglist
          ][
            ifelse member? argu orangeargs [
              set colorarglist lput list argu 55 colorarglist
            ][
              ifelse member? argu orangeargs [
                set colorarglist lput list argu 65 colorarglist
              ][
                set colorarglist lput list argu 75 colorarglist
              ]
            ]
          ]
        ]
      ]
    ]
  ] 
  report colorarglist
end


to-report list-cleaner3 [blist]
  set blist duplicate-remover-command blist
  let newarglist arg-list-reformat-in blist
  set blist arg-list-reformat-out newarglist
  report blist
end




to update-memories-test8
  ask researchers [
    ; the argument the researcher is standing on is written to cur-argum
    let cur-argum gps
    let cur-researcher self
    ; information of current argument in the format of the memory
    let add-cur (sentence cur-argum [color] of cur-argum)
    ; list of relations (resp. arguments) that are added
    let to-add []
    let to-add-argu []
    set to-add-argu lput add-cur to-add-argu
    ; list of neighborhood arguments of the current argument
    set neighborargs []
    set neighborargs lput cur-argum neighborargs

    ; for the current argument
    ; add the neighboring discovered arguments and relations
    ; (attacks and discovery) to a to-add list
    ask cur-argum [
       if any? my-in-discoveries with [color != gray][
        ask my-in-discoveries with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added discovery relation
          let add-rel []
          set add-rel lput "d" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the child argument of the discovery relation
      if any? my-out-discoveries with [color != gray][
        ask my-out-discoveries with [color != gray][
    let add-other-end other-end
    ask cur-researcher [
      set neighborargs lput add-other-end neighborargs
    ]
    ; construction of the to be added discovery relation
    let add-rel []
    set add-rel lput "d" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput add-other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the parent argument of the attack relation
      if any? my-in-attacks with [color != gray][
        ask my-in-attacks with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the child argument of the attack relation
      if any? my-out-attacks with [color != gray][
        ask my-out-attacks with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
    ]

    ; remove duplicates from the list
    set subjective-relations sentence
      subjective-relations to-add
    set subjective-arguments (merge-arg-wo-dupl-um2 subjective-arguments
    to-add-argu false)
  ]
end


to-report merge-arg-wo-dupl-um [alist blist flag]
  if flag [
    set blist remove-duplicates blist
  ]
  foreach blist [ [?1] ->
    let argu first ?1
    let my-color item 1 ?1
    if flag [
      let duplicate-check list-filter argu my-color blist
      ; let duplicate-check filter [ [??1] -> first ??1 = argu ] blist
      foreach duplicate-check [ [??1] ->
        if item 1 ??1 > my-color [
          set blist remove ??1 blist
        ]
      ]
    ]
    ; argu-old will contain the current argument (argu) from blist if this
    ; argument also is present in alist. argu-old is a nested list:
    ; lists [[(argu) color-argu-in-alist]]
    let argu-old filter [ [??1] -> first ??1 = argu ] alist
    if not empty? argu-old [
      ; item 0 will reduce the degree of nestedness of the argu-old by one i.e.
      ; argu-old will now now be [(argu) color-argu-in-alist] 
      set argu-old item 0 argu-old
      if my-color < item 1 argu-old [
      let argument-position position argu-old alist
        if argument-position != false [
          set alist replace-item argument-position alist ?1
        ]
      ]
      if my-color >= item 1 argu-old [
        set blist remove ?1 blist
      ]
    ]
  ]
  ; finally the lists which had their respective duplicates removed are merged
  ; and identical entries are removed. The result is then reported
  set alist remove-duplicates sentence alist blist
  report alist
end

to-report merge-arg-wo-dupl-um2 [alist blist flag]
  set alist sentence alist blist
  report alist
end






to compute-subj-attacked-test9
  foreach colla-networks [ [?1] ->
    let calc-done false
    let calc-researcher []
    let cur-group ?1
    foreach cur-group [ [??1] ->
      let cur-researcher ??1
      if not [rep-researcher] of cur-researcher [
        ; if a researcher of the group already calculated defensibility other
        ; group members can copy the results into their memory
        ifelse calc-done [
          ask cur-researcher [
            set admissible-subj-argu [admissible-subj-argu] of calc-researcher
            set current-theory-info [current-theory-info] of calc-researcher
            set non-admiss-subj-argu [non-admiss-subj-argu] of calc-researcher
          ]
        ][
          ; if no group member has done the defensibility calculations, the
          ; current researcher does the calculations i.e. she becomes the
          ; groups calc-researcher
          set calc-done true
          set calc-researcher cur-researcher
          ask cur-researcher [
            ; variables for lists that contain:
            ; the current-theory-info with 0 admissible arguments
            ; an updated number of admissible arguments during the recursive
            ; computation 
            ; the arguments that are not admissible
            ; the arguments that the researchers knows about
            ; and the arguments that are attacked by the current theory
            let new-info []
            let new-cur-info []
            let not-admissible []
            let args-cur-arguments []
            let args-cur-arguments-as 0
            let attacked-by-me []

            ; create a list of only the attacks
            let attack-relations []
            foreach subjective-relations [ [???1] ->
              if first ???1 = "a" [
                set attack-relations lput ???1 attack-relations
              ]
             ]
            ; create lists of attacked and attacking arguments
            let cur-attacked []
            let cur-attacker []
            foreach attack-relations [ [???1] ->
              set cur-attacked lput last ???1 cur-attacked
              set cur-attacker lput first but-first ???1 cur-attacker
             ]

            ; create a list of the arguments the researchers knows about and
            ; set the number of admissible arguments for each theory to 0
            foreach subjective-arguments [ [???1] ->
              set args-cur-arguments lput first ???1 args-cur-arguments
            ]
            ; create an agentset which contains all subjective-arguments
            set args-cur-arguments-as startsargum with [member? self
            args-cur-arguments]
            foreach current-theory-info [ [???1] ->
              set new-info lput replace-item 1 ???1 0 new-info
            ]
            set current-theory-info new-info

            ; the computation of the admissible arguments is done recursively
            ; a list of arguments that are currently consideredto be attacked
            let open-rec []
            ; variable that lets the loop run at least one time
            let i 0
            foreach current-theory-info [ [???1] ->
              ; the theory that is considered in this loop
              ; and the root of that theory (the start)
              let cur-theory ???1
              let askstart item 0 cur-theory
              while [ i < 1 or not empty? open-rec][
                set not-admissible sentence not-admissible open-rec
                set open-rec []
                set attacked-by-me []

                ; create a list of arguments that are attacked by the current
                ; theory based on the memory of the current researcher
                if not empty? attack-relations [
                  ask args-cur-arguments-as with [mytheory = askstart][
                    if member? self cur-attacker and not member? self
                    not-admissible [
                      ; the argument considered and a list of arguments
                      ; attacked by that argument
                      let cur-turtle self
                      let my-attacked []
                      foreach attack-relations [ [????1] ->
                        if item 1 ????1 = cur-turtle [
                          set my-attacked lput last ????1 my-attacked
                        ]
                      ]
                      set attacked-by-me sentence my-attacked attacked-by-me
                    ]
                  ]

                  ; arguments that are attacked by arguments from another
                  ; theory that are not attacked by non-attacked arguments
                  ; from the current theory are added to the open-rec list:
                  ; the list of attacked-arguments
                  ask args-cur-arguments-as with [mytheory = askstart and
                    not member? self not-admissible and
                    member? self cur-attacked][
                    let cur-turtle self
                    foreach attack-relations [ [????1] ->
                      if last ????1 = cur-turtle [
                        if not member? item 1 ????1 attacked-by-me [
                          set open-rec lput cur-turtle open-rec
                        ]
                      ]
                    ]
                  ]
                ]
                set i i + 1
              ]
              set i 0

              ; update of the information in current-theory-info
              set new-cur-info lput replace-item 1 cur-theory (count
                args-cur-arguments-as with [mytheory = askstart] -
                count args-cur-arguments-as with 
                [member? self not-admissible and mytheory = askstart])
                  new-cur-info
            ]

            ; arguments that are part of the not-admissible list
            ; are not part of the admissible subjective arguments and hence
            ; removed
            ; this non-admissible arguments are written into the
            ; researcher owned variable non-admiss-subj-argu which will only
            ; contain these arguments as a list without their respective colors
            set admissible-subj-argu subjective-arguments
            set non-admiss-subj-argu []
            foreach subjective-arguments [ [???1] ->
              let cur-argu ???1
              if member? first cur-argu not-admissible [
                set admissible-subj-argu remove cur-argu admissible-subj-argu
                set non-admiss-subj-argu lput item 0 cur-argu
                non-admiss-subj-argu
              ]
            ]
            ; update the current-theory-info
            set current-theory-info new-cur-info
          ]
        ]
      ]
    ]
  ]
end


; the procedure was in version "test5" is unfortunately buggy (Issue #34)
; this has been fixed in the main procedures and is now applied to the 
;testprocedures
; procedure in which the representative researchers of the networks
; share information according to the social structure
to share-w-other-netw-test10
  let rep-researchers researchers with [rep-researcher]
  ask rep-researchers [
    ; variables for the combined information (arguments and relations),
    ; the network of the current researcher and the theory she is working on
    let askresearcher self
    let comb-memory-argu []
    let comb-memory-rel []
    let cur-network sort collaborator-network

    ; create a list of the neighboring networks and then a
    ; list of the representative researchers (share-researchers) of these
    ; networks which will be the researchers the current researcher 
    ; shares with
    let share-researchers []
    let share-neighbors []
    foreach share-structure [ [?1] ->
      if first ?1 = cur-network [
        set share-neighbors ?1
      ]
    ]
    ask rep-researchers [
      let cur-researcher self
      foreach share-neighbors [ [cur-share-group] ->
        if cur-researcher != askresearcher 
          and member? cur-researcher cur-share-group [
          set share-researchers lput cur-researcher share-researchers
        ]
      ]
    ]

    ; create a list of arguments and a list of relations that is
    ; shared among the share-researchers
    foreach share-researchers [ [cur-share-researcher] ->
      ; the combined memory is updated to contain the information
      ; of all the share researchers        
      set comb-memory-argu sentence comb-memory-argu 
      [th-args] of cur-share-researcher
      set comb-memory-rel sentence comb-memory-rel 
      [th-relations] of cur-share-researcher
    ]
    ; finally the askresearcher inputs the information given to her  
    ;- by the rep. researchers from her share-neighbors groups - into her
    ; respective (researcher owned) variables and removes the duplicates
    set to-add-mem-argu remove-duplicates comb-memory-argu
    set to-add-mem-rel remove-duplicates comb-memory-rel
  ]

end



; procedure that adds the new information to the memory of the
; representative researchers and computes the time they have lost by
; communicating
to compute-time-costs-test10
  ask researchers with [rep-researcher][
    ; variables that contain the arguments and relations the
    ; researcher has to update in its memory
    let new-memory-args []
    let new-memory-rel []
    let to-add-argu []
    set new-memory-args filter [ [?1] -> not member? ?1 subjective-arguments ]
      to-add-mem-argu
    set new-memory-rel filter [ [?1] -> not member? ?1 subjective-relations ]
      to-add-mem-rel
    let comb-new sentence new-memory-args new-memory-rel
    ; every tick an researcher can obtain a maximum of max-learn new entries
    ; (max-learn is hidden-variable which is set to 10 by default)
    ; the day that they received information is also lost
    ifelse length comb-new >= (3 * max-learn) [
      set communicating 4
    ][
      set communicating ((ceiling (length comb-new / max-learn)) + 1)
    ]

    ; every communication round an researcher can update a maximum of
    ; 3 * max-learn new arguments/relations (corresponding to three ticks of
    ; communication) these new arguments and relations are added to the
    ; memory of the researcher
    ; when a new relation is added and the arguments are not part of the
    ; memory of the researcher, these arguments are added as well
    ifelse length comb-new > (3 * max-learn) [
      set comb-new shuffle comb-new
      let repeats length comb-new - (3 * max-learn)
      while [length comb-new > repeats] [
        let cur-entr first comb-new
        let new-mem-argargs filter [ [?1] -> member? ?1 new-memory-args ]
        comb-new
        set new-mem-argargs map [ [?1] -> first ?1 ] new-mem-argargs
        ifelse member? cur-entr new-memory-args [
          set to-add-argu lput cur-entr to-add-argu
          set comb-new remove cur-entr comb-new
        ][
          set subjective-relations lput cur-entr subjective-relations
          set comb-new remove cur-entr comb-new
          if member? item 1 cur-entr new-mem-argargs[
            let item-1-cur-entr item 1 cur-entr
            foreach comb-new [ [?1] ->
              if item-1-cur-entr = item 0 ?1 [
                set to-add-argu lput ?1 to-add-argu
                set comb-new remove ?1 comb-new
              ]
            ]
          ]
          if member? item 2 cur-entr new-mem-argargs [
            let item-2-cur-entr item 2 cur-entr
            foreach comb-new [ [?1] ->
              if item-2-cur-entr = item 0 ?1 [
                set to-add-argu lput ?1 to-add-argu
                set comb-new remove ?1 comb-new
              ]
            ]
          ]
        ]
      ]
      set subjective-arguments (merge-arg-wo-dupl-tst subjective-arguments
      to-add-argu true)
    ][
      set subjective-arguments (merge-arg-wo-dupl-tst subjective-arguments
      new-memory-args true)
      set subjective-relations sentence subjective-relations new-memory-rel
    ]
  ]
end



to move-around-test10
  ; variable to make sure that the procedure find-defense
  ; is only run once
  let run-find-defense false
  ; at the beginning of the procedure no researcher has moved yet
  ask researchers [
    set moved false
  ]
  ask researchers [
    let curresearcher self
    if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
      let myargu gps     
      ; the researcher owned variable which contains all the non defensible
      ; arguments as a list is written to not-admissible
      let not-admissible non-admiss-subj-argu
      
      ; an researcher working on a non defensible argument will try to find a
      ; defense for this attack, by working further on the attacked argument,
      ; unless she discoveres a child-argument that that has a defense for
      ; the attack (it is not necessarily the case that this defense is
      ; already discovered) or until she has fully researched the argument
      ; the find-defense runs immediately for all researchers working on 
      ; a not fully researched non defensible argument,
      ; hence it is only once executed
      if member? myargu not-admissible and not moved [

        if not run-find-defense [
          find-defense-test10
          set run-find-defense true
        ]
      ]

      if not moved and (not member? myargu not-admissible or
        (member? myargu not-admissible and [color] of myargu = red))[

        ; when an argument exists that:
        ; a) is a child-argument of the current argument;
        ; b) is not gray, red or turquoise; and
        ; c) no researcher from the same collaborator-network is working on it
        ; the researcher moves there, with certain probability
        ifelse any? startsargum with [in-discovery-neighbor? myargu
          and [not member? color [gray red turquoise]] of self
          and not group-member-here curresearcher][
          let move-random random-float 1.0


          ; every time step with small-movement of the move-probability
          ; the researcher moves
          ifelse move-random < (small-movement * move-probability *
            (1 - (color / color-move))) [
            move-to one-of startsargum with [
              in-discovery-neighbor? myargu
              and [not member? color [gray red turquoise]] of self
              and not group-member-here curresearcher]
            set moved true
          ][

            ; every 5th time step the researcher mover with the full
            ; move-probability, that depends a bit on the color
            if ticks != 0 and ticks mod 5 = 0 and move-random <
              move-probability * (1 - (color / color-move)) [
              move-to one-of startsargum with [
                in-discovery-neighbor? myargu
                and [not member? color [gray red turquoise]] of self
                and not group-member-here curresearcher]
              set moved true
            ]
          ]
        ][

          ; if there is no next argument and the current argument is
          ; fully researched, the researcher moves a step back
          ifelse [color] of myargu = red 
            and any? startsargum with 
            [[not member? color [gray turquoise]] of self
            and out-discovery-neighbor? myargu and not group-member-here
            curresearcher][
            move-to one-of startsargum with [ 
            [not member? color [gray turquoise]] of self
            and out-discovery-neighbor? myargu
            and not group-member-here curresearcher]
            set moved true
          ][

            ; if moving back is not possible, she jumps to another argument in
            ; the same tree/theory that is discovered but not fully researched
            if [color] of myargu = red [
              let askstart [mytheory] of myargu
              if any? startsargum with [
                [not member? color [gray red turquoise]] of self
                and mytheory = askstart 
                and not group-member-here curresearcher][
                move-to one-of startsargum with [
                  [not member? color [gray red turquoise]] of self
                  and mytheory = askstart
                  and not group-member-here curresearcher]
                set moved true
              ]
            ]
          ]
        ]
      ]
    ]
  ]
end





to find-defense-test10
  ask researchers with [not moved][
    let curresearcher self
    if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
      let myargu gps
      ; lists of arguments that are not admissible
      let not-admissible non-admiss-subj-argu
      
      ; if the current argument is not fully researched and not admissible
      ; and it is a 5th time step or the researcher is not communicating
      ; the researcher tries to move prospectively to a child-argument of the
      ; current argument that provides a defense for the current argument
      if member? myargu not-admissible [
        ask myargu [
          ask my-in-attacks [
            ; check to prevent the researcher from searching for further
            ; defender-childs (nextargu) when she already has moved to one
            if not [moved] of curresearcher [
              ask end1 [
              ; create a set of arguments that provide a defense for the 
              ; current argument, these:
              ; a) attack the attacker of the current argument;
              ; b) are a child-argument of the current argument;
              ; c) are discovered; and
              ; d) no researcher from the same group is working on it
                let nextargu in-attack-neighbors with [in-discovery-neighbor?
                  myargu
                  and [not member? color [gray red turquoise]] of self
                  and not group-member-here curresearcher]
                ; if such an argument exists the researcher moves there
                ; and cannot move anymore this time step
                if any? nextargu [
                  ask curresearcher [
                    move-to one-of nextargu
                    set moved true
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]     
  ]
end




to compare-member-with-property [input repeats]
  setuprs -628558118 1
  set ctiho (list startsargum with [mytheory = first sort starts]
    startsargum with [mytheory = item 1 sort starts] 
    startsargum with [mytheory = item 2 sort starts])
    if input = 1 [
      repeat repeats [run-member1]
      repeat repeats [run-with1]
    ]
    if input = 2 [
      repeat repeats [run-member2]
      repeat repeats [run-with2]
    ]
    if input = 3 [
      let starterset (turtle-set (start 0) (start 85))
      repeat repeats [run-member3]
      repeat repeats [run-with3 starterset]
    ]
  
end

to run-member1
 set ctiho-new count startsargum with [member? self first ctiho]
end

to run-with1
  set ctiho-old count startsargum with [mytheory = (start 0)]
end

to run-member2
  set ctiho-new count startsargum with [not member? self first ctiho]
end

to run-with2
  set ctiho-old count startsargum with [mytheory != (start 0)]
end

to run-member3
  set ctiho-new count (turtle-set item 0 ctiho item 1 ctiho)
end

to run-with3 [starterset]
  set ctiho-old count startsargum with [member? mytheory (list (start 0) (start 85))]
end


to-report shortest-item [lists]
  let best-entry reduce [[best-so-far next-item] ->
    ifelse-value (length best-so-far <= length next-item) [best-so-far][next-item]
  ] lists
  let #occurrences 0
  foreach lists [[curitem] ->
    if length curitem = length best-entry [
      set #occurrences #occurrences + 1
    ]
  ]
  report (list best-entry length best-entry #occurrences)
end


to-report longest-item [lists]
  let best-entry reduce [[best-so-far next-item] ->
    ifelse-value (length best-so-far >= length next-item) [best-so-far][next-item]
  ] lists
  let #occurrences 0
  foreach lists [[curitem] ->
    if length curitem = length best-entry [
      set #occurrences #occurrences + 1
    ]
  ]
  report (list best-entry length best-entry #occurrences)
end


to test-identity-handover
carefully [
  show self
  show myself
  show other-end
  ask other-end [show self]
  ][show (word "test-identity-handover " error-message)]
end