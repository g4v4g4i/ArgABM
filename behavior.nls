; the procedures that determine
; the basic behavior of the agents:
; 1. how they update their memory
; 2. how they share information
; 3. how they walk around on the landscape
; 4. how the landscape is updated





; every round, the agents update their memory:
; arguments that have changed color, new arguments/links
; every fifth round the agents share their updated memory within their
; collaborator-network
to update-memories
  ask agents [
    let myx xcor
    let myy ycor
    let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      and xcor = myx and ycor = myy]
    let cur-agent self
    ; information of current argument in the format of the memory
    let add-cur (sentence cur-argum [color] of cur-argum)
    set subjective-arguments lput add-cur subjective-arguments
    ; list of relations (resp. arguments) that are added
    let to-add []
    let to-add-argu []
    ; list of neighborhood arguments of the current argument
    set neighborargs []
    set neighborargs lput cur-argum neighborargs
    
    ; for the current argument
    ; add the neighboring discovered arguments and relations
    ; (attacks and discovery) to a to-add list
    ask cur-argum [
       if any? my-in-discoveries with [color != gray][
        ask my-in-discoveries with [color != gray][
          let add-other-end other-end
          ask cur-agent [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added discovery relation
          let add-rel []
          set add-rel lput "d" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
      
      ; add the child argument of the discovery relation
      if any? my-out-discoveries with [color != gray][
        ask my-out-discoveries with [color != gray][
	  let add-other-end other-end
	  ask cur-agent [
	    set neighborargs lput add-other-end neighborargs
	  ]
	  ; construction of the to be added discovery relation
	  let add-rel []
	  set add-rel lput "d" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput add-other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
     
      ; add the parent argument of the attack relation
      if any? my-in-attacks with [color != gray][
        ask my-in-attacks with [color != gray][
          let add-other-end other-end
          ask cur-agent [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
      
      ; add the child argument of the attack relation
      if any? my-out-attacks with [color != gray][
        ask my-out-attacks with [color != gray][
          let add-other-end other-end
          ask cur-agent [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-argu []
          set add-argu lput "a" add-argu
          set add-argu lput cur-argum add-argu
          set add-argu lput other-end add-argu
          set to-add lput add-argu to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
    ]
    
    ; remove duplicates from the list
    set subjective-relations remove-duplicates sentence
      subjective-relations to-add
    set subjective-arguments remove-duplicates sentence
      subjective-arguments to-add-argu
  ]
  
  ; every 5 plus 4 time-steps the collected information
  ; is shared with other agents
  if ticks mod 5 = 4 [
    share-with-others
  ] 
  
end





; procedure in which agents share (part of) their memory with other agents
; first they share their whole memory with agents from their
; collaborator-network
; second they share information with agents from other networks
to share-with-others
  ask agents [
    ; variables to keep track of the current agents own memory
    ; and the combined memory of all the sharing agents
    let own-memory-argu subjective-arguments
    let own-memory-rel subjective-relations
    let comb-memory-argu []
    let comb-memory-rel []
    ; collaborator network of the current agent
    let cur-network collaborator-network
    
    ; the information in the memories of the single agents in the network
    ; are combined 
    ask turtles with [member? self cur-network] [
      set comb-memory-argu sentence subjective-arguments comb-memory-argu
      set comb-memory-rel sentence subjective-relations comb-memory-rel
    ]
    
    ; each agent adds the combined memory to its own
    ; then removing duplicates
    set subjective-arguments remove-duplicates sentence
      own-memory-argu comb-memory-argu
    set subjective-relations remove-duplicates sentence
      own-memory-rel comb-memory-rel
    
    foreach subjective-arguments [
      ; the argument of the current subjective-arguments entry
      let argu first ?
      ; the color of the current subjective-arguments entry
      let my-color first but-first ?
      ; a list of subjective-arguments entries that concern
      ; the same argument
      let color-argu filter [first ? = argu] subjective-arguments
      set color-argu sort-by [first but-first ?1 < first but-first ?2] color-argu
      ; keep only the argument-entry that is researched the most
      ; entries from the same argument but with higher color-value are deleted
      while [length color-argu != 1] [
        set subjective-arguments remove last color-argu subjective-arguments
        set color-argu but-last color-argu
      ]
    ]
  ]
  
  ; then agents can share some of their information with agents 
  ; from neighboring networks in the social structures
  create-share-memory
  share-with-other-networks
  
end





; procedure in which agents collect the information from their
; memory that they want to share with agents that do not 
; belong to their own collaborator-network
to create-share-memory
  
  ; for each collaborator-network one agent is set to be
  ; the representative agent
  foreach colla-networks [
    ask one-of agents with [member? self ?][
      set rep-agent true
    ]
  ]
  
  ; only the representative agents create a memory 
  ; that they want to share with agents from other networks
  ask agents with [rep-agent][
    let myx xcor
    let myy ycor
    ; variables for the argument the agent is currently working on,
    ; the agent itself and the theory it is working on
    let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      and xcor = myx and ycor = myy]
    let cur-agent self 
    let cur-th [mytheory] of cur-argum
    ; create a list of arguments and a list of relations that the agent can
    ; share with agents from other collaborative networks
    ; what agents share depends on the "social-action" and "sharing"
    ; from the interface
    set th-args []
    set th-relations []
    
    ; agents share only information obtained in the neighborhood 
    ; they are currently working on
    ; collect the arguments from the agent's memory
    ; that belong also to the neighborargs
    foreach subjective-arguments [
      if member? item 0 ? [neighborargs] of cur-agent [
        set th-args lput ? th-args
      ]
    ]
    ; collect the relations from/to the current argument
    ; from the agent's memory
    foreach subjective-relations [
      if item 1 ? = cur-argum or item 2 ? = cur-argum [
        set th-relations lput ? th-relations
      ]
    ]
    
    ; if the agent behaves biased it does not share the attack relations that
    ; attack its current theory, these relations are removed
    if social-actions = "biased"[
      foreach th-relations [
        if item 0 ? = "a" and [mytheory] of item 2 ? = cur-th [
          set th-relations remove ? th-relations
        ]
      ]
    ]
  ]
end





; procedure in which the representative agents of the networks
; share information according to the social structure
to share-with-other-networks 
  ask agents with [rep-agent][
    ; variables for the combined information (arguments and relations),
    ; the network of the current agent and the theory it is working on
    let comb-memory-argu th-args
    let comb-memory-rel th-relations
    let cur-network sort collaborator-network
    let my-cur-theory [mytheory] of item 0 item 0 th-args
    
    ; create a list of the neighboring networks and then a 
    ; list of the representative agents of these networks
    ; which will be the agents the current agent shares with
    let share-agents []
    let share-neighbors []
    foreach share-structure [    
      if first ? = cur-network [
        set share-neighbors ?
      ]
    ]
    ask agents with [rep-agent][
      let cur-agent self
      foreach share-neighbors [
        if member? cur-agent ? [
          set share-agents lput cur-agent share-agents
        ]
      ]
    ]
    
    ; create a list of arguments and a list of relations that is
    ; shared among the share-agents
    foreach share-agents [
      ; the combined memory is updated to contain that of the sharing agent
      set comb-memory-argu sentence comb-memory-argu [th-args] of ?
      set comb-memory-rel sentence comb-memory-rel [th-relations] of ?
    ]
    ; create lists of arguments/relations that have to be added
    foreach share-agents [
      set to-add-mem-argu remove-duplicates sentence subjective-arguments
        comb-memory-argu
      set to-add-mem-rel remove-duplicates sentence subjective-relations
        comb-memory-rel
    ]
  ] 
  
  ; to compute the time that agents have to
  ; spend on communication
  compute-time-costs 
end





; procedure that adds the new information to the memory of the 
; representative agents and computes the time they have lost by
; communicating
to compute-time-costs
  ask agents with [rep-agent][
    
    ; variables that contain the arguments and relations the
    ; agent has to update in its memory
    let new-memory-args []
    let new-memory-rel []
    set new-memory-args filter [not member? ? subjective-arguments]
      to-add-mem-argu
    set new-memory-rel filter [not member? ? subjective-relations]
      to-add-mem-rel
    let comb-new sentence new-memory-args new-memory-rel
    
    ; every communication round an agent can update a maximum of 
    ; 30 new arguments/relations (corresponding to three ticks of communication)
    ; these new arguments and relations are added to the memory of the agent
    ifelse length comb-new > 30 [
      set comb-new shuffle comb-new
      repeat 30 [
        let cur-entr first comb-new
        ifelse member? cur-entr new-memory-args [
          set subjective-arguments lput cur-entr subjective-arguments
        ][
        set subjective-relations lput cur-entr subjective-relations
        ]
        set comb-new remove-item 0 comb-new
      ]
    ][
    set subjective-arguments sentence subjective-arguments new-memory-args
    set subjective-relations sentence subjective-relations new-memory-rel
    ]
    ; every tick an agent can obtain a maximum of 10 new entries
    ; the day that they received information is also lost
    set communicating ((ceiling (length comb-new / 10)) + 1)
  ]
  
  ; reset the variables
  ask agents [
    set rep-agent false 
    set to-add-mem-argu []
    set to-add-mem-rel []
  ]
end





; procedure that removes all duplicates from the memory of an agent
; duplicates also include arguments that are part of the memory with
; different colors in these cases only the entry with the lowest color value
; is kept these arguments are furthest researched
to duplicate-remover
  ask agents [
    ; list of arguments of which the duplicates will be removed
    let new-args subjective-arguments
    foreach new-args [
      ; the argument of the current entry and its color
      let argu first ?
      let my-color first but-first ?
      ; list of entries with the same argument, but maybe different color
      let color-argu filter [first ? = argu] new-args
      ; remove entries of arguments that are also present as
      ; better researched entries
      set color-argu sort-by [first but-first ?1 < first but-first ?2] color-argu
      while [length color-argu != 1] [
        set new-args remove last color-argu new-args
        set color-argu but-last color-argu
      ]
    ]
    ; update the agent's memory
    set subjective-arguments new-args
  ]
end





; procedure that describes how the agents move around over the landscape
; they only "see" the colored part of the landscape and hence can only move
; there, the probability of moving increases (a little) when the argument is
; further researched in one time step agents can either receive information or
; move, but not both
to move-around
  ; variable to make sure that the procedure find-defense
  ; is only run once
  let run-find-defense false 
  ; at the beginning of the procedure no agent has moved yet
  ask agents [
    set moved false
  ]
  ask agents [
    let curagent self
    if [communicating] of curagent = 0 or ticks mod 5 = 0 [
      let myx xcor
      let myy ycor
      ; variable for the argument the agent is currently working on and
     ; the agent itself
        let myargu one-of turtles with [(breed = starts or breed = arguments) and
        xcor = myx and ycor = myy]
      
      ; a list of not-admissible arguments is created
      let not-admissible []
      if admissible-subj-argu != 0 and not empty? admissible-subj-argu [
        let info-not-admissible filter [not member? ? admissible-subj-argu]
          subjective-arguments
        foreach info-not-admissible [
          set not-admissible lput item 0 ? not-admissible
        ]
      ]
   
      ; an agent working on an attacked argument will try to find a defense for
      ; this attack, by working further on the attacked argument, unless it
      ; discoveres a child-argument that that has a defense for the attack
      ; (it is not necessarily the case that this defense is already discovered)
      ; the find-defense runs immediately for all agents working on a not
      ; fully researched not-admissible argument, hence it is only once executed
      if member? myargu not-admissible and not moved[
      
        if not run-find-defense [
          find-defense
          set run-find-defense true
        ]
      ]
    
      if not moved and not member? myargu not-admissible or 
        (member? myargu not-admissible and [color] of myargu = red)[
        
        ; when an argument exists that:
        ; a) is a child-argument of the current argument;
        ; b) is not gray, red or turquoise; and
        ; c) no agent from the same collaborator-network is working on it
        ; the agent moves there, with certain probability
        ifelse any? turtles with [(breed = starts or breed = arguments) and
          in-discovery-neighbor? myargu and color != gray and color != red and
    	  color != turquoise and not (any? turtles with [breed = agents and
	  xcor = [xcor] of myself and ycor = [ycor] of myself and member? self
	  [collaborator-network] of curagent])] [
        let move-random random-float 1.0
      

        ; every time step with small-movement of the move-probability
        ; the agent moves
        ifelse move-random < (small-movement * move-probability *
          (1 - (color / color-move))) [
          move-to one-of turtles with [(breed = starts or breed = arguments) and
            in-discovery-neighbor? myargu and color != gray and color != red and
            color != turquoise and not ( any? turtles with [breed = agents and
            xcor = [xcor] of myself and ycor = [ycor] of myself and member? self
  	    [collaborator-network] of curagent])]
          set moved true
        ][
      
        ; every 5th time step the agent mover with the full move-probability,
        ; that depends a bit on the color
        if ticks != 0 and ticks mod 5 = 0 and move-random <
          move-probability * (1 - (color / color-move)) [
          move-to one-of turtles with [(breed = starts or breed = arguments) and
            in-discovery-neighbor? myargu and color != gray and color != red and
	    color != turquoise and not ( any? turtles with [breed = agents
	    and xcor = [xcor] of myself and ycor = [ycor] of myself and
	    member? self [collaborator-network] of curagent])]
          set moved true
        ]
        ]
            ][

        ; if there is no next argument and the current argument is
        ; fully researched, the agent moves a step back
        ifelse [color] of myargu = red and any? turtles with [color != gray and
          color != turquoise and out-discovery-neighbor? myargu and not any?
	  turtles with [breed = agents and xcor = [xcor] of myself and
	  ycor = [ycor] of myself and member? self [collaborator-network]
	  of curagent]][
        move-to one-of turtles with [color != gray and out-discovery-neighbor?
          myargu and not any? turtles with [breed = agents and xcor = [xcor] of
          myself and ycor = [ycor] of myself and member? self
          [collaborator-network] of curagent]]
        set moved true
          ][
      
        ; if moving back is not possible, it jumps to another argument in
        ; the same tree/theory that is discovered but not fully researched
        if [color] of myargu = red[
          let askstart [mytheory] of myargu
          if any? turtles with [(breed = starts or breed = arguments) and
	    color != gray and color != turquoise and color != red and
	    mytheory = askstart and not any? turtles with [breed = agents and
  	    xcor = [xcor] of myself and ycor = [ycor] of myself and member?
	    self [collaborator-network] of curagent]][
          move-to one-of turtles with [(breed = starts or breed = arguments) and
	   color != turquoise and color != gray and color != red and
  	   mytheory = askstart and not any? turtles with [breed = agents and
	   xcor = [xcor] of myself and ycor = [ycor] of myself and member? self
           [collaborator-network] of curagent]]
          set moved true
            ]
        ]
          ]
            ]
      ]
    ]	
  ]
end





; agents working on a not fully researched attacked argument will try to find a
; defense for that attack, by staying on the current argument
; if a child-argument is discovered that can provide a defense, the 
; agent moves there
; once an argument is fully researched all its relations are discovered,
; then an agent can move on and can try to find a defense in another branch,
; further away
to find-defense
  ask agents with [not moved][    
    let curagent self
    if [communicating] of curagent = 0 or ticks mod 5 = 0 [
      let myx xcor
      let myy ycor
      ; variables for the argument the agent is working on and
      ; for the agent itself
      let myargu one-of turtles with [(breed = starts or breed = arguments) and
        xcor = myx and ycor = myy]
    
      ; lists of arguments that are not admissible
      let not-admissible []
      if admissible-subj-argu != 0 and not empty? admissible-subj-argu [
        let info-not-admissible filter [not member? ? admissible-subj-argu]
          subjective-arguments
        foreach info-not-admissible [
          set not-admissible lput item 0 ? not-admissible
        ]
      ]
    
      ; if the current argument is not fully researched and not admissible
      ; and it is a 5th time step or the agent is not communicating
      ; the agent tries to move prospectively to a child-argument of the current 
      ; argument that provides a defense for the current argument
      if member? myargu not-admissible[
        ask myargu [
          ask my-in-attacks [
            ask end1 [
              ; create a set of arguments that provide a defense for the current
	      ; argument, these:
              ; a) attack the attacker of the current argument;
	      ; b) are a child-argument of the current argument;
              ; c) are discovered; and
	      ; d) no agent from the same network is working on it
              let nextargu in-attack-neighbors with [in-discovery-neighbor?
	        myargu and color != gray and color != turquoise and not (any?
		agents with [xcor = [xcor] of myself and ycor = [ycor] of myself
		and member? self [collaborator-network] of curagent])]
              ; if such an argument exists the agent moves there
              ; and cannot move anymore this time step
              if any? nextargu [
                ask curagent [
                  move-to one-of nextargu
                  set moved true
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
end





; every five time steps the landscape is updated:
; new arguments become visible and attacks are discovered
to update-landscape
  ask turtles with [breed = arguments or breed = starts][
    let myx xcor
    let myy ycor
    ; discoveries only occur when an agent is working on that argument, 
    ; it is the 5th time step or the agent does not communicate
    ; working on an argument means that the agent did 
    ; not communicate in that round
    if any? turtles with [breed = agents and xcor = myx and ycor = myy and 
      communicating = 0] or (any? turtles with [breed = agents and 
      xcor = myx and ycor = myy] and ticks mod 5 = 0)[
      set researcher-ticks researcher-ticks + 1
      
      ; the color of an argument is changed if agents have been working
      ; on that argument for research-speed time steps
      if researcher-ticks mod research-speed = 0 and color != red[
        set color color - 10
        if color = red [set full-research true]
      ]
        
      ; depending on the color a new child-argument is discovered, until all
      ; child-arguments are discovered
      if color = yellow and count out-discovery-neighbors with
	[color = gray or color = turquoise] >= 4 [
        ask one-of out-discovery-neighbors with
	  [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
      if color = brown and count out-discovery-neighbors with
	[color = gray or color = turquoise] >= 3 [
        ask one-of out-discovery-neighbors with
	  [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
      if color = orange and count out-discovery-neighbors with
	[color = gray or color = turquoise] >= 2 [
       ask one-of out-discovery-neighbors with
         [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
      if color = red and count out-discovery-neighbors with
	[color = gray or color = turquoise] >= 1 [
        ask one-of out-discovery-neighbors with
  	 [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]

      ; for arguments that have still undiscovered relations/neighbors and are
      ; not fully researched
      if ticks mod 5 = 0 and color != red [
        let attack-random random-float 1.00
        
        ; with visibility-probability a new attacked/attacking argument is
        ; discovered
        if attack-random < visibility-probability [
          if any? my-links with [breed = attacks and color = gray][
            ask one-of my-links with [breed = attacks and color = gray][
              set color red
              ask other-end [if color = gray [set color turquoise]]
            ]
          ]
        ]
      ]
    ]
    
    ; once an argument is fully researched all its relations to other arguments
    ; are discovered as well
    full-discovery
    
    ; if both ends of a discovery relation are discovered
    ; by research, the relation is discovered as well
    if color != gray [
      ask my-out-discoveries with [color = gray][
        if [color] of other-end != gray and [color] of other-end != turquoise [
          set color cyan
        ]
      ]
    ]
  ]
  
  ; at the end of the time steps 1, 2, 3 and 4 communicating agents
  ; decrease their communicating value by 1
  if ticks mod 5 != 0 [
    ask agents with [communicating > 0][
      set communicating communicating - 1
    ]
  ]
end





; procedure that makes sure that fully researched arguments have a fully 
; discovered neighborhood
to full-discovery 
  ask turtles with [breed = arguments or breed = starts and full-research][
    let myx xcor
    let myy ycor
    if any? turtles with [breed = agents and xcor = myx and ycor = myy and 
      communicating = 0] or (ticks mod 5 = 0 and any? turtles with 
      [breed = agents and xcor = myx and ycor = myy])[
      
      ; once an argument is fully researched all its relations,
      ; attack and discovery, are discovered
      if any? out-discovery-neighbors with [color = gray or color = turquoise][
        ask out-discovery-neighbors with [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
     
      ; note that in the case of an attack relation the other argument
      ; is not really discovered: it needs to be discovered by a discovery
      ; relation in the other theory to become lime
      if any? my-in-attacks with [color = gray][
        ask my-in-attacks with [color = gray][
          set color red
          ask other-end [if color = gray [set color turquoise]]
        ]
      ]
      if any? my-out-attacks with [color = gray][
        ask my-out-attacks with [color = gray][
          set color red
          ask other-end [if color = gray [set color turquoise]]
        ]
      ]
    ]
    set full-research false
  ]
end




