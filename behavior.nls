; the procedures that determine
; the basic behavior of the researchers:
; 1. how they update their memory
; 2. how they share information
; 3. how they walk around on the landscape
; 4. how the landscape is updated


; procedure which reports the argument at the current position
; called by researchers in order to determine the argument they are
; currently working/standing on
to-report gps
  let myx xcor
  let myy ycor
  let myargu one-of startsargum with [xcor = myx and ycor = myy]
  report myargu
end





; procedure which merges lists of arguments with colors (alist and blist)
; and removes all duplicates from the merged list which is then reported
; alist is supposed to be the arguments already in the reserchers memory and
; blist corresponds to the new input 
; the procedure is called with a flag (type: boolean) which determines
; whether it has to look in 2nd input list (blist) for duplicates or not
; this is done (flag = false) to increase performance when the procedure is
; called with a blist that can't contain duplicates in itself
; and where the blist entries are guaranteed to be the most recent version
; availiable in the landscape (e.g update-memories)
; alist in general musn't contain any duplicates
; arguments that are part of the lists with different colors also count as
; duplicates. In these cases only the entry with the lowest color value
; is kept i.e. the arguments which are furthest researched
to-report merge-arg-wo-duplicates [alist blist flag]
  if flag [
    set blist remove-duplicates blist
  ]
  foreach blist [ [?1] ->
    let argu first ?1
    let my-color item 1 ?1
    if flag [
      let duplicate-check filter [ [??1] -> first ??1 = argu ] blist
      foreach duplicate-check [ [??1] ->
        if item 1 ??1 > my-color [
          set blist remove ??1 blist
        ]
      ]
    ]
    ; argu-old will contain the current argument (argu) from blist if this
    ; argument also is present in alist. argu-old is a nested list:
    ; lists [[(argu) color-argu-in-alist]]
    let argu-old filter [ [??1] -> first ??1 = argu ] alist
    if not empty? argu-old [
      ; item 0 will reduce the degree of nestedness of the argu-old by one i.e.
      ; argu-old will now now be [(argu) color-argu-in-alist] 
      set argu-old item 0 argu-old
      if my-color < item 1 argu-old [
      let argument-position position argu-old alist
        if argument-position != false [
          set alist replace-item argument-position alist ?1
        ]
      ]
      if my-color >= item 1 argu-old [
        set blist remove ?1 blist
      ]
    ]
  ]
  ; finally the lists which had their respective duplicates removed are merged
  ; and identical entries are removed. The result is then reported
  set alist remove-duplicates sentence alist blist
  report alist
end




; a new duplicate remover for lists with arguments + colors. It takes a list
; as input and will report the same list back with each argument only
; contained once with the the arguments most researched color (i.e. the
; lowest color value). It is specificially designed for the share-with-others
; procedure as the merge-arg-wo-duplicates procedure is unfortunately still a
; bit slow in this regard. 
to-report arg-list-dupl-remover [alist]
  set alist remove-duplicates alist
  let widearglist convert-arglist-long-to-wide alist
  set alist convert-arglist-wide-to-long widearglist
  report alist
end



; procedure which takes a argulist with colors of the format
; [[(argu-1) color-1]...[(argu-i) color-i]] (the long format) and transforms
; it to [[(argu-1)...(argu-i)] [(argu-j)...] ... [(argu-k)...] [(argu-1) ...
; (argu-n)]] (the wide format).
; Here the first nested list [(argu-1) ... (argu-i)] corresponds to all
; arguments with the color red (redargs) the next is orange (orangeargs),
; all the way till turquoise and then the last list (argulist):
; [(argu-i)... (argu-n)] will be a list of all arguments.
to-report convert-arglist-long-to-wide [longarglist]
  let redargs []
  let orangeargs []
  let brownargs []
  let yellowargs []
  let greenargs []
  let limeargs []
  let turquoiseargs []
  let argulist []
  foreach longarglist [ [colorarg] ->
    let curargu item 0 colorarg
    let curcolor item 1 colorarg
    set argulist lput curargu argulist
    if curcolor = 15 [
      set redargs lput curargu redargs
    ]
    if curcolor = 25 [
      set orangeargs lput curargu orangeargs
    ]
    if curcolor = 35 [
      set brownargs lput curargu brownargs
    ]
    if curcolor = 45 [
      set yellowargs lput curargu yellowargs
    ]
    if curcolor = 55 [
      set greenargs lput curargu greenargs
    ]
    if curcolor = 65 [
      set limeargs lput curargu limeargs
    ]
    if curcolor = 75 [
      set turquoiseargs lput curargu turquoiseargs
    ]
  ]
  set argulist remove-duplicates argulist
  let widearglist (list redargs orangeargs brownargs yellowargs greenargs limeargs turquoiseargs argulist)
  report widearglist
end


; this procedure is the reverse procedure to convert-arglist-long-to-wide.
; It takes a argument list in the wide format as produced by the long-to-wide
; procedure and transforms it back into a long-list i.e. the format where
; each argument has it's color right with it's entry: 
; [[(argu-1) color-1] ... [(argu-n) color-n]]
; The output will contain each argument only once with the the most
; researched color (i.e. the lowest color value)
to-report convert-arglist-wide-to-long [widearglist]
  let redargs item 0 widearglist
  let orangeargs item 1 widearglist
  let brownargs item 2 widearglist
  let yellowargs item 3 widearglist
  let greenargs item 4 widearglist
  let limeargs item 5 widearglist
  let turquoiseargs item 6 widearglist
  let argulist item 7 widearglist
  let longarglist []
  foreach argulist
  [ [argu] ->
    ifelse member? argu redargs [
      set longarglist lput list argu 15 longarglist
    ][
      ifelse member? argu orangeargs [
        set longarglist lput list argu 25 longarglist
      ][
        ifelse member? argu orangeargs [
          set longarglist lput list argu 35 longarglist
        ][
          ifelse member? argu orangeargs [
            set longarglist lput list argu 45 longarglist
          ][
            ifelse member? argu orangeargs [
              set longarglist lput list argu 55 longarglist
            ][
              ifelse member? argu orangeargs [
                set longarglist lput list argu 65 longarglist
              ][
                set longarglist lput list argu 75 longarglist
              ]
            ]
          ]
        ]
      ]
    ]
  ] 
  report longarglist
end






; every round, the researchers update their memory:
; arguments that have changed color, new arguments/links
; every fifth round the researchers share their updated memory within their
; collaborator-network
to update-memories
  ask researchers [
    ; the argument the researcher is standing on is written to cur-argum
    let cur-argum gps
    let cur-researcher self
    ; information of current argument in the format of the memory
    let add-cur (sentence cur-argum [color] of cur-argum)
    ; list of relations (resp. arguments) that are added
    let to-add []
    let to-add-argu []
    set to-add-argu lput add-cur to-add-argu
    ; list of neighborhood arguments of the current argument
    set neighborargs []
    set neighborargs lput cur-argum neighborargs

    ; for the current argument
    ; add the neighboring discovered arguments and relations
    ; (attacks and discovery) to a to-add list
    ask cur-argum [
       if any? my-in-discoveries with [color != gray][
        ask my-in-discoveries with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added discovery relation
          let add-rel []
          set add-rel lput "d" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the child argument of the discovery relation
      if any? my-out-discoveries with [color != gray][
        ask my-out-discoveries with [color != gray][
    let add-other-end other-end
    ask cur-researcher [
      set neighborargs lput add-other-end neighborargs
    ]
    ; construction of the to be added discovery relation
    let add-rel []
    set add-rel lput "d" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput add-other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the parent argument of the attack relation
      if any? my-in-attacks with [color != gray][
        ask my-in-attacks with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the child argument of the attack relation
      if any? my-out-attacks with [color != gray][
        ask my-out-attacks with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
    ]
    set subjective-relations sentence subjective-relations to-add
    set subjective-arguments sentence subjective-arguments to-add-argu
  ]
end





; procedure in which researchers share their memory with other researchers
; from their collaborator-network (=group)
to share-with-others
  foreach colla-networks [ [?1] ->
    let group-sharing-done false
    let grp-share-researcher []
    let cur-group ?1
    foreach cur-group [ [??1] ->
      let cur-researcher ??1
      ifelse group-sharing-done [
        ask cur-researcher [
          set rep-researcher false
          set subjective-arguments [subjective-arguments] of
          grp-share-researcher
          set subjective-relations [subjective-relations] of
          grp-share-researcher
        ]
      ][
        set group-sharing-done true
        set grp-share-researcher cur-researcher
        ask cur-researcher [
          ; reset the variables
          set rep-researcher false
          set to-add-mem-argu []
          set to-add-mem-rel []

          ; variables to keep track of the current researchers own memory
          ; and the combined memory of all the sharing researchers
          ; let own-memory-argu subjective-arguments
          ; let own-memory-rel subjective-relations
          let comb-memory-argu []
          let comb-memory-rel []
          ; collaborator network of the current researcher
          let cur-network collaborator-network

          ; the information in the memories of the single researchers in
          ; the network are combined
          foreach cur-group [ [???1] ->
            let input-researcher ???1
            set comb-memory-argu remove-duplicates sentence
              [subjective-arguments] of input-researcher comb-memory-argu
            set comb-memory-rel remove-duplicates sentence 
              [subjective-relations] of input-researcher comb-memory-rel
          ]
          ; the group-share-researcher adds the combined memory to its own
          set subjective-arguments (arg-list-dupl-remover comb-memory-argu)
          set subjective-relations comb-memory-rel
        ]
      ]
    ]
  ]
end




; procedure in which researchers collect the information from their
; memory that they want to share with researchers that do not
; belong to their own collaborator-network
to create-share-memory

  ; for each collaborator-network one researcher is set to be
  ; the representative researcher
  foreach colla-networks [ [?1] ->
    ifelse length ?1 > 1 [
      ask one-of researchers with [member? self ?1][
        set rep-researcher true
      ]
    ][
      if ticks mod 25 = 4 [
        ask one-of researchers with [member? self ?1][
          set rep-researcher true
      ]
    ]
    ]
  ]

  ; only the representative researchers create a memory
  ; that they want to share with researchers from other networks
  ask researchers with [rep-researcher][
    let cur-argum gps  
    let cur-researcher self
    let cur-th [mytheory] of cur-argum
    ; create a list of arguments and a list of relations that the researcher
    ; can share with researchers from other collaborative networks
    ; what researchers share depends on the "social-action" and "sharing"
    ; from the interface
    set th-args []
    set th-relations []

    ; researchers share only information obtained in the neighborhood
    ; they are currently working on
    ; collect the arguments from the researcher's memory
    ; that belong also to the neighborargs
    foreach subjective-arguments [ [?1] ->
      if member? item 0 ?1 [neighborargs] of cur-researcher [
        set th-args lput ?1 th-args
      ]
    ]
    ; collect the relations from/to the current argument
    ; from the researcher's memory
    foreach subjective-relations [ [?1] ->
      if item 1 ?1 = cur-argum or item 2 ?1 = cur-argum [
        set th-relations lput ?1 th-relations
      ]
    ]

    ; if the researcher behaves biased she does not share the attack relations
    ; that attack its current theory, these relations are removed
    if social-actions = "biased"[
      foreach th-relations [ [?1] ->
        if item 0 ?1 = "a" and [mytheory] of item 2 ?1 = cur-th [
          set th-relations remove ?1 th-relations
        ]
      ]
    ]
  ]
end





; procedure in which the representative researchers of the networks
; share information according to the social structure
to share-with-other-networks
  let rep-researchers researchers with [rep-researcher]
  ask rep-researchers [
    ; variables for the combined information (arguments and relations),
    ; the network of the current researcher and the theory she is working on
    let askresearcher self
    let comb-memory-argu []
    let comb-memory-rel []
    let cur-network sort collaborator-network

    ; create a list of the neighboring networks and then a
    ; list of the representative researchers (share-researchers) of these
    ; networks which will be the researchers the current researcher 
    ; shares with
    let share-researchers []
    let share-neighbors []
    foreach share-structure [ [?1] ->
      if first ?1 = cur-network [
        set share-neighbors ?1
      ]
    ]
    ask rep-researchers [
      let cur-researcher self
      foreach share-neighbors [ [cur-share-group] ->
        if cur-researcher != askresearcher 
          and member? cur-researcher cur-share-group [
          set share-researchers lput cur-researcher share-researchers
        ]
      ]
    ]

    ; create a list of arguments and a list of relations that is
    ; shared among the share-researchers
    foreach share-researchers [ [cur-share-researcher] ->
      ; the combined memory is updated to contain the information
      ; of all the share researchers        
      set comb-memory-argu sentence comb-memory-argu 
      [th-args] of cur-share-researcher
      set comb-memory-rel sentence comb-memory-rel 
      [th-relations] of cur-share-researcher
    ]
    ; finally the askresearcher inputs the information given to her  
    ;- by the rep. researchers from her share-neighbors groups - into her
    ; respective (researcher owned) variables and removes the duplicates
    set to-add-mem-argu remove-duplicates comb-memory-argu
    set to-add-mem-rel remove-duplicates comb-memory-rel
  ]

end





; procedure that adds the new information to the memory of the
; representative researchers and computes the time they have lost by
; communicating
to compute-time-costs
  ask researchers with [rep-researcher][
    ; variables that contain the arguments and relations the
    ; researcher has to update in its memory
    let new-memory-args []
    let new-memory-rel []
    let to-add-argu []
    set new-memory-args filter [ [?1] -> not member? ?1 subjective-arguments ]
      to-add-mem-argu
    set new-memory-rel filter [ [?1] -> not member? ?1 subjective-relations ]
      to-add-mem-rel
    let comb-new sentence new-memory-args new-memory-rel
    ; every tick an researcher can obtain a maximum of max-learn new entries
    ; (max-learn is hidden-variable which is set to 10 by default)
    ; the day that they received information is also lost
    ifelse length comb-new >= (3 * max-learn) [
      set communicating 4
    ][
      set communicating ((ceiling (length comb-new / max-learn)) + 1)
    ]

    ; every communication round an researcher can update a maximum of
    ; 3 * max-learn new arguments/relations (corresponding to three ticks of
    ; communication) these new arguments and relations are added to the
    ; memory of the researcher
    ; when a new relation is added and the arguments are not part of the
    ; memory of the researcher, these arguments are added as well
    ifelse length comb-new > (3 * max-learn) [
      set comb-new shuffle comb-new
      let repeats length comb-new - (3 * max-learn)
      while [length comb-new > repeats] [
        let cur-entr first comb-new
        let new-mem-argargs filter [ [?1] -> member? ?1 new-memory-args ]
        comb-new
        set new-mem-argargs map [ [?1] -> first ?1 ] new-mem-argargs
        ifelse member? cur-entr new-memory-args [
          set to-add-argu lput cur-entr to-add-argu
          set comb-new remove cur-entr comb-new
        ][
          set subjective-relations lput cur-entr subjective-relations
          set comb-new remove cur-entr comb-new
          if member? item 1 cur-entr new-mem-argargs[
            let item-1-cur-entr item 1 cur-entr
            foreach comb-new [ [?1] ->
              if item-1-cur-entr = item 0 ?1 [
                set to-add-argu lput ?1 to-add-argu
                set comb-new remove ?1 comb-new
              ]
            ]
          ]
          if member? item 2 cur-entr new-mem-argargs [
            let item-2-cur-entr item 2 cur-entr
            foreach comb-new [ [?1] ->
              if item-2-cur-entr = item 0 ?1 [
                set to-add-argu lput ?1 to-add-argu
                set comb-new remove ?1 comb-new
              ]
            ]
          ]
        ]
      ]
      set subjective-arguments (merge-arg-wo-duplicates subjective-arguments
      to-add-argu true)
    ][
      set subjective-arguments (merge-arg-wo-duplicates subjective-arguments
      new-memory-args true)
      set subjective-relations sentence subjective-relations new-memory-rel
    ]
  ]
end





; reports whether a member of the collaborative network (=group) of the
; curresearcher is at the position of the caller
; called by arguments during the movement procedures
; represents the fact that agents will coordinate with their their
; collaborative network (=group) to not to move to an argument where a group
; member is already working, in order to keep redundancy of their research low
to-report group-member-here [curresearcher] 
  ifelse any? researchers with [
      xcor = [xcor] of myself and ycor = [ycor] of myself 
      and member? self [collaborator-network] of curresearcher][
    report true
  ][
    report false
  ]

end




; procedure that describes how the researchers move around over the landscape
; they only "see" the colored (i.e. non gray) part of the landscape and hence
; can only move there, the probability of moving increases (a little) when the
; argument is further researched
; agents will coordinate with their their collaborative network (=group) to 
; not to move to an argument where a group member is already working
; in order to keep redundancy of their research low
; in one time step researchers can either receive/digest information or
; move, but not both
to move-around
  ; variable to make sure that the procedure find-defense
  ; is only run once
  let run-find-defense false
  ; at the beginning of the procedure no researcher has moved yet
  ask researchers [
    set moved false
  ]
  ask researchers [
    let curresearcher self
    if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
      let myargu gps     
      ; the researcher owned variable which contains all the non defensible
      ; arguments as a list is written to not-admissible
      let not-admissible non-admiss-subj-argu
      
      ; an researcher working on a non defensible argument will try to find a
      ; defense for this attack, by working further on the attacked argument,
      ; unless she discoveres a child-argument that that has a defense for
      ; the attack (it is not necessarily the case that this defense is
      ; already discovered) or until she has fully researched the argument
      ; the find-defense runs immediately for all researchers working on 
      ; a not fully researched non defensible argument,
      ; hence it is only once executed
      if member? myargu not-admissible and not moved [

        if not run-find-defense [
          find-defense
          set run-find-defense true
        ]
      ]

      if not moved and (not member? myargu not-admissible or
        (member? myargu not-admissible and [color] of myargu = red))[

        ; when an argument exists that:
        ; a) is a child-argument of the current argument;
        ; b) is not gray, red or turquoise; and
        ; c) no researcher from the same collaborator-network is working on it
        ; the researcher moves there, with certain probability
        ifelse any? startsargum with [in-discovery-neighbor? myargu
          and [not member? color [gray red turquoise]] of self
          and not group-member-here curresearcher][
          let move-random random-float 1.0


          ; every time step with small-movement of the move-probability
          ; the researcher moves
          ifelse move-random < (small-movement * move-probability *
            (1 - (color / color-move))) [
            move-to one-of startsargum with [
              in-discovery-neighbor? myargu
              and [not member? color [gray red turquoise]] of self
              and not group-member-here curresearcher]
            set moved true
          ][

            ; every 5th time step the researcher mover with the full
            ; move-probability, that depends a bit on the color
            if ticks != 0 and ticks mod 5 = 0 and move-random <
              move-probability * (1 - (color / color-move)) [
              move-to one-of startsargum with [
                in-discovery-neighbor? myargu
                and [not member? color [gray red turquoise]] of self
                and not group-member-here curresearcher]
              set moved true
            ]
          ]
        ][

          ; if there is no next argument and the current argument is
          ; fully researched, the researcher moves a step back
          ifelse [color] of myargu = red 
            and any? startsargum with 
            [[not member? color [gray turquoise]] of self
            and out-discovery-neighbor? myargu and not group-member-here
            curresearcher][
            move-to one-of startsargum with [ 
            [not member? color [gray turquoise]] of self
            and out-discovery-neighbor? myargu
            and not group-member-here curresearcher]
            set moved true
          ][

            ; if moving back is not possible, she jumps to another argument in
            ; the same tree/theory that is discovered but not fully researched
            if [color] of myargu = red [
              let askstart [mytheory] of myargu
              if any? startsargum with [
                [not member? color [gray red turquoise]] of self
                and mytheory = askstart 
                and not group-member-here curresearcher][
                move-to one-of startsargum with [
                  [not member? color [gray red turquoise]] of self
                  and mytheory = askstart
                  and not group-member-here curresearcher]
                set moved true
              ]
            ]
          ]
        ]
      ]
    ]
  ]
end





; researchers working on a not fully researched non defensible argument will
; try to find a defense for that attack, by staying on the current argument
; if a child-argument is discovered that can potentially provide a defense
; (it is not necessarily the case that this defense is already discovered),
; the researcher moves there
; once an argument is fully researched all its relations are discovered,
; so the researcher can move on and can try to find a defense in another
; branch further away
to find-defense
  ask researchers with [not moved][
    let curresearcher self
    if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
      let myargu gps
      ; lists of arguments that are not admissible
      let not-admissible non-admiss-subj-argu
      
      ; if the current argument is not fully researched and not admissible
      ; and it is a 5th time step or the researcher is not communicating
      ; the researcher tries to move prospectively to a child-argument of the
      ; current argument that provides a defense for the current argument
      if member? myargu not-admissible [
        ask myargu [
          ask my-in-attacks [
            ; check to prevent the researcher from searching for further
            ; defender-childs (nextargu) when she already has moved to one
            if not [moved] of curresearcher [
              ask end1 [
              ; create a set of arguments that provide a defense for the 
              ; current argument, these:
              ; a) attack the attacker of the current argument;
              ; b) are a child-argument of the current argument;
              ; c) are discovered; and
              ; d) no researcher from the same group is working on it
                let nextargu in-attack-neighbors with [in-discovery-neighbor?
                  myargu
                  and [not member? color [gray red turquoise]] of self
                  and not group-member-here curresearcher]
                ; if such an argument exists the researcher moves there
                ; and cannot move anymore this time step
                if any? nextargu [
                  ask curresearcher [
                    move-to one-of nextargu
                    set moved true
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]     
  ]
end




; reports whether an appropriate researcher (i.e. one that is not digesting
; information from communication) is present at the position myx myy
; called by arguments when the landscape is updated
to-report non-comm-scientists-here [myx myy]
  ifelse any? researchers with [xcor = myx and ycor = myy 
    and communicating = 0]
  or (ticks mod 5 = 0 and any? researchers with [xcor = myx and ycor = myy])[
    report true
  ][
    report false
  ]
end




; every five time steps the landscape is updated:
; new arguments become visible and attacks are discovered
to update-landscape
  ask startsargum [
    let myx xcor
    let myy ycor
    ; discoveries only occur when an researcher is working on that argument,
    ; it is the 5th time step or the researcher does not communicate
    ; working on an argument means that the researcher did
    ; not communicate in that round
    if non-comm-scientists-here myx myy [
      set researcher-ticks researcher-ticks + 1

      ; the color of an argument is changed if researchers have been working
      ; on that argument for research-speed time steps
      if researcher-ticks mod research-speed = 0 and color != red [
        set color color - 10
        if color = red [set full-research true]
      ]

      ; depending on the color a new child-argument is discovered, until all
      ; child-arguments are discovered
      if color = yellow and count out-discovery-neighbors with
        [color = gray or color = turquoise] >= 4 [
        ask one-of out-discovery-neighbors with
          [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
      if color = brown and count out-discovery-neighbors with
        [color = gray or color = turquoise] >= 3 [
        ask one-of out-discovery-neighbors with
          [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
      if color = orange and count out-discovery-neighbors with
        [color = gray or color = turquoise] >= 2 [
        ask one-of out-discovery-neighbors with
         [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
      if color = red and count out-discovery-neighbors with
        [color = gray or color = turquoise] >= 1 [
        ask one-of out-discovery-neighbors with
          [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]

      ; for arguments that have still undiscovered relations/neighbors and are
      ; not fully researched
      if ticks mod 5 = 0 and color != red [
        let attack-random random-float 1.00

        ; with visibility-probability a new attacked/attacking argument is
        ; discovered
        if attack-random < visibility-probability [
          if any? my-links with [breed = attacks and color = gray][
            ask one-of my-links with [breed = attacks and color = gray][
              set color red
              ask other-end [if color = gray [set color turquoise]]
            ]
          ]
        ]
      ]
    ]
    ; if both ends of a discovery relation are discovered
    ; by research, the relation is discovered as well
    if color != gray [
      ask my-out-discoveries with [color = gray][
        if [not member? color [gray turquoise]] of other-end [
          set color cyan
        ]
      ]
    ]
  ]
end





; once an argument is fully researched all its relations to other arguments
; are discovered as well therefore this procedure makes sure that fully
; researched arguments have a fully discovered neighborhood
to full-discovery
  ask startsargum with [full-research][
    let myx xcor
    let myy ycor
    if non-comm-scientists-here myx myy [

      ; once an argument is fully researched all its relations,
      ; attack and discovery, are discovered
      if any? out-discovery-neighbors with [color = gray or color = turquoise][
        ask out-discovery-neighbors with [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]

      ; note that in the case of a discovery via attack relation the other
      ; argument is not really discovered: it needs to be discovered by a
      ; discovery relation in the other theory to become lime
      if any? my-in-attacks with [color = gray][
        ask my-in-attacks with [color = gray][
          set color red
          ask other-end [if color = gray [set color turquoise]]
        ]
      ]
      if any? my-out-attacks with [color = gray][
        ask my-out-attacks with [color = gray][
          set color red
          ask other-end [if color = gray [set color turquoise]]
        ]
      ]
    ]
    set full-research false
  ]
end





; at the end of the time steps 1, 2, 3 and 4 communicating researchers
; decrease their communicating value by 1 which corresponds to them having used
; the day to digest the information they gained while communicating
to communication-regress
    ask researchers with [communicating > 0][
      set communicating communicating - 1
    ]
end

