; the procedures that determine
; the basic behavior of the researchers:
; 1. how they update their memory
; 2. how they share information
; 3. how they walk around on the landscape
; 4. how the landscape is updated





; every round, the researchers update their memory:
; arguments that have changed color, new arguments/links
; every fifth round the researchers share their updated memory within their
; collaborator-network
to update-memories
  ask researchers [
    let myx xcor
    let myy ycor
    let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      and xcor = myx and ycor = myy]
    let cur-researcher self
    ; information of current argument in the format of the memory
    let add-cur (sentence cur-argum [color] of cur-argum)
    set subjective-arguments lput add-cur subjective-arguments
    ; list of relations (resp. arguments) that are added
    let to-add []
    let to-add-argu []
    ; list of neighborhood arguments of the current argument
    set neighborargs []
    set neighborargs lput cur-argum neighborargs

    ; for the current argument
    ; add the neighboring discovered arguments and relations
    ; (attacks and discovery) to a to-add list
    ask cur-argum [
       if any? my-in-discoveries with [color != gray][
        ask my-in-discoveries with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added discovery relation
          let add-rel []
          set add-rel lput "d" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the child argument of the discovery relation
      if any? my-out-discoveries with [color != gray][
        ask my-out-discoveries with [color != gray][
	  let add-other-end other-end
	  ask cur-researcher [
	    set neighborargs lput add-other-end neighborargs
	  ]
	  ; construction of the to be added discovery relation
	  let add-rel []
	  set add-rel lput "d" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput add-other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the parent argument of the attack relation
      if any? my-in-attacks with [color != gray][
        ask my-in-attacks with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the child argument of the attack relation
      if any? my-out-attacks with [color != gray][
        ask my-out-attacks with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
    ]

    ; remove duplicates from the list
    set subjective-relations remove-duplicates sentence
      subjective-relations to-add
    set subjective-arguments remove-duplicates sentence
      subjective-arguments to-add-argu
  ]

  ; every 5 plus 4 time-steps the collected information
  ; is shared with other researchers
  if ticks mod 5 = 4 [
    share-with-others
  ]

end





; procedure in which researchers share (part of) their memory with other researchers
; first they share their whole memory with researchers from their
; collaborator-network
; second they share information with researchers from other networks
to share-with-others
  ask researchers [
    ; reset the variables
    set rep-researcher false
    set to-add-mem-argu []
    set to-add-mem-rel []

    ; variables to keep track of the current researchers own memory
    ; and the combined memory of all the sharing researchers
    let own-memory-argu subjective-arguments
    let own-memory-rel subjective-relations
    let comb-memory-argu []
    let comb-memory-rel []
    ; collaborator network of the current researcher
    let cur-network collaborator-network

    ; the information in the memories of the single researchers in the network
    ; are combined
    ask turtles with [member? self cur-network] [
      set comb-memory-argu sentence subjective-arguments comb-memory-argu
      set comb-memory-rel sentence subjective-relations comb-memory-rel
    ]

    ; each researcher adds the combined memory to its own
    ; then removing duplicates
    set subjective-arguments remove-duplicates sentence
      own-memory-argu comb-memory-argu
    set subjective-relations remove-duplicates sentence
      own-memory-rel comb-memory-rel

    foreach subjective-arguments [ [?1] ->
      ; the argument of the current subjective-arguments entry
      let argu first ?1
      ; the color of the current subjective-arguments entry
      let my-color first but-first ?1
      ; a list of subjective-arguments entries that concern
      ; the same argument
      let color-argu filter [ [??1] -> first ??1 = argu ] subjective-arguments
      set color-argu sort-by [ [??1 ??2] -> first but-first ??1 < first but-first ??2 ] color-argu
      ; keep only the argument-entry that is researched the most
      ; entries from the same argument but with higher color-value are deleted
      while [length color-argu != 1] [
        set subjective-arguments remove last color-argu subjective-arguments
        set color-argu but-last color-argu
      ]
    ]
  ]

  ; then researchers can share some of their information with researchers
  ; from neighboring networks in the social structures
  create-share-memory
  share-with-other-networks

end





; procedure in which researchers collect the information from their
; memory that they want to share with researchers that do not
; belong to their own collaborator-network
to create-share-memory

  ; for each collaborator-network one researcher is set to be
  ; the representative researcher
  foreach colla-networks [ [?1] ->
    ifelse length ?1 > 1 [
      ask one-of researchers with [member? self ?1][
        set rep-researcher true
      ]
    ][
    if ticks mod 25 = 4 [
      ask one-of researchers with [member? self ?1][
        set rep-researcher true
      ]
    ]
    ]
  ]

  ; only the representative researchers create a memory
  ; that they want to share with researchers from other networks
  ask researchers with [rep-researcher][
    let myx xcor
    let myy ycor
    ; variables for the argument the researcher is currently working on,
    ; the researcher itself and the theory it is working on
    let cur-argum one-of turtles with [(breed = starts or breed = arguments)
      and xcor = myx and ycor = myy]
    let cur-researcher self
    let cur-th [mytheory] of cur-argum
    ; create a list of arguments and a list of relations that the researcher can
    ; share with researchers from other collaborative networks
    ; what researchers share depends on the "social-action" and "sharing"
    ; from the interface
    set th-args []
    set th-relations []

    ; researchers share only information obtained in the neighborhood
    ; they are currently working on
    ; collect the arguments from the researcher's memory
    ; that belong also to the neighborargs
    foreach subjective-arguments [ [?1] ->
      if member? item 0 ?1 [neighborargs] of cur-researcher [
        set th-args lput ?1 th-args
      ]
    ]
    ; collect the relations from/to the current argument
    ; from the researcher's memory
    foreach subjective-relations [ [?1] ->
      if item 1 ?1 = cur-argum or item 2 ?1 = cur-argum [
        set th-relations lput ?1 th-relations
      ]
    ]

    ; if the researcher behaves biased it does not share the attack relations that
    ; attack its current theory, these relations are removed
    if social-actions = "biased"[
      foreach th-relations [ [?1] ->
        if item 0 ?1 = "a" and [mytheory] of item 2 ?1 = cur-th [
          set th-relations remove ?1 th-relations
        ]
      ]
    ]
  ]
end





; procedure in which the representative researchers of the networks
; share information according to the social structure
to share-with-other-networks
  ask researchers with [rep-researcher][
    ; variables for the combined information (arguments and relations),
    ; the network of the current researcher and the theory it is working on
    let comb-memory-argu th-args
    let comb-memory-rel th-relations
    let cur-network sort collaborator-network
    let my-cur-theory [mytheory] of item 0 item 0 th-args

    ; create a list of the neighboring networks and then a
    ; list of the representative researchers of these networks
    ; which will be the researchers the current researcher shares with
    let share-researchers []
    let share-neighbors []
    foreach share-structure [ [?1] ->
      if first ?1 = cur-network [
        set share-neighbors ?1
      ]
    ]
    ask researchers with [rep-researcher][
      let cur-researcher self
      foreach share-neighbors [ [?1] ->
        if member? cur-researcher ?1 [
          set share-researchers lput cur-researcher share-researchers
        ]
      ]
    ]

    ; create a list of arguments and a list of relations that is
    ; shared among the share-researchers
    foreach share-researchers [ [?1] ->
      ; the combined memory is updated to contain that of the sharing researcher
      set comb-memory-argu sentence comb-memory-argu [th-args] of ?1
      set comb-memory-rel sentence comb-memory-rel [th-relations] of ?1
    ]
    ; create lists of arguments/relations that have to be added
    foreach share-researchers [
      set to-add-mem-argu remove-duplicates sentence subjective-arguments
        comb-memory-argu
      set to-add-mem-rel remove-duplicates sentence subjective-relations
        comb-memory-rel
    ]
  ]

  ; to compute the time that researchers have to
  ; spend on communication
  compute-time-costs
end





; procedure that adds the new information to the memory of the
; representative researchers and computes the time they have lost by
; communicating
to compute-time-costs
  ask researchers with [rep-researcher][

    ; variables that contain the arguments and relations the
    ; researcher has to update in its memory
    let new-memory-args []
    let new-memory-rel []
    set new-memory-args filter [ [?1] -> not member? ?1 subjective-arguments ]
      to-add-mem-argu
    set new-memory-rel filter [ [?1] -> not member? ?1 subjective-relations ]
      to-add-mem-rel
    let comb-new sentence new-memory-args new-memory-rel
    ; every tick an researcher can obtain a maximum of 10 new entries
    ; the day that they received information is also lost
    ifelse length comb-new >= (3 * max-learn) [
      set communicating 4
    ][
    set communicating ((ceiling (length comb-new / max-learn)) + 1)
    ]

    ; every communication round an researcher can update a maximum of
    ; 3 * max-learn new arguments/relations (corresponding to three ticks of
    ; communication) these new arguments and relations are added to the
    ; memory of the researcher
    ; when a new relation is added and the arguments are not part of the
    ; memory of the researcher, these arguments are added as well
    ifelse length comb-new > (3 * max-learn) [
      set comb-new shuffle comb-new
      let repeats length comb-new - (3 * max-learn)
      while [length comb-new > repeats] [
        let cur-entr first comb-new
        let new-mem-argargs filter [ [?1] -> member? ?1 new-memory-args ] comb-new
        set new-mem-argargs map [ [?1] -> first ?1 ] new-mem-argargs
        ifelse member? cur-entr new-memory-args [
          set subjective-arguments lput cur-entr subjective-arguments
          set comb-new remove cur-entr comb-new
        ][
        set subjective-relations lput cur-entr subjective-relations
        set comb-new remove cur-entr comb-new
        if member? item 1 cur-entr new-mem-argargs[
          let item-1-cur-entr item 1 cur-entr
          foreach comb-new [ [?1] ->
            if item-1-cur-entr = item 0 ?1 [
              set subjective-arguments lput ?1 subjective-arguments
              set comb-new remove ?1 comb-new
            ]
          ]
        ]
        if member? item 2 cur-entr new-mem-argargs[
          let item-2-cur-entr item 2 cur-entr
          foreach comb-new [ [?1] ->
            if item-2-cur-entr = item 0 ?1 [
              set subjective-arguments lput ?1 subjective-arguments
              set comb-new remove ?1 comb-new
            ]
          ]
        ]
        ]
      ]
    ][
    set subjective-arguments sentence subjective-arguments new-memory-args
    set subjective-relations sentence subjective-relations new-memory-rel
    ]
  ]
end





; procedure that removes all duplicates from the memory of an researcher
; duplicates also include arguments that are part of the memory with
; different colors in these cases only the entry with the lowest color value
; is kept these arguments are furthest researched
to duplicate-remover
  ask researchers [
    ; list of arguments of which the duplicates will be removed
    let new-args subjective-arguments
    foreach new-args [ [?1] ->
      ; the argument of the current entry and its color
      let argu first ?1
      let my-color first but-first ?1
      ; list of entries with the same argument, but maybe different color
      let color-argu filter [ [??1] -> first ??1 = argu ] new-args
      ; remove entries of arguments that are also present as
      ; better researched entries
      set color-argu sort-by [ [??1 ??2] -> first but-first ??1 < first but-first ??2 ] color-argu
      while [length color-argu != 1] [
        set new-args remove last color-argu new-args
        set color-argu but-last color-argu
      ]
    ]
    ; update the researcher's memory
    set subjective-arguments new-args
  ]
end





; procedure that describes how the researchers move around over the landscape
; they only "see" the colored part of the landscape and hence can only move
; there, the probability of moving increases (a little) when the argument is
; further researched in one time step researchers can either receive information or
; move, but not both
to move-around
  ; variable to make sure that the procedure find-defense
  ; is only run once
  let run-find-defense false
  ; at the beginning of the procedure no researcher has moved yet
  ask researchers [
    set moved false
  ]
  ask researchers [
    let curresearcher self
    if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
      let myx xcor
      let myy ycor
      ; variable for the argument the researcher is currently working on and
     ; the researcher itself
        let myargu one-of turtles with [(breed = starts or breed = arguments) and
        xcor = myx and ycor = myy]

      ; a list of not-admissible arguments is created
      let not-admissible []
      if admissible-subj-argu != 0 and not empty? admissible-subj-argu [
        let info-not-admissible filter [ [?1] -> not member? ?1 admissible-subj-argu ]
          subjective-arguments
        foreach info-not-admissible [ [?1] ->
          set not-admissible lput item 0 ?1 not-admissible
        ]
      ]

      ; an researcher working on an attacked argument will try to find a defense for
      ; this attack, by working further on the attacked argument, unless it
      ; discoveres a child-argument that that has a defense for the attack
      ; (it is not necessarily the case that this defense is already discovered)
      ; the find-defense runs immediately for all researchers working on a not
      ; fully researched not-admissible argument, hence it is only once executed
      if member? myargu not-admissible and not moved[

        if not run-find-defense [
          find-defense
          set run-find-defense true
        ]
      ]

      if not moved and not member? myargu not-admissible or
        (member? myargu not-admissible and [color] of myargu = red)[

        ; when an argument exists that:
        ; a) is a child-argument of the current argument;
        ; b) is not gray, red or turquoise; and
        ; c) no researcher from the same collaborator-network is working on it
        ; the researcher moves there, with certain probability
        ifelse any? turtles with [(breed = starts or breed = arguments) and
          in-discovery-neighbor? myargu and color != gray and color != red and
    	  color != turquoise and not (any? turtles with [breed = researchers and
	  xcor = [xcor] of myself and ycor = [ycor] of myself and member? self
	  [collaborator-network] of curresearcher])] [
        let move-random random-float 1.0


        ; every time step with small-movement of the move-probability
        ; the researcher moves
        ifelse move-random < (small-movement * move-probability *
          (1 - (color / color-move))) [
          move-to one-of turtles with [(breed = starts or breed = arguments) and
            in-discovery-neighbor? myargu and color != gray and color != red and
            color != turquoise and not ( any? turtles with [breed = researchers and
            xcor = [xcor] of myself and ycor = [ycor] of myself and member? self
  	    [collaborator-network] of curresearcher])]
          set moved true
        ][

        ; every 5th time step the researcher mover with the full move-probability,
        ; that depends a bit on the color
        if ticks != 0 and ticks mod 5 = 0 and move-random <
          move-probability * (1 - (color / color-move)) [
          move-to one-of turtles with [(breed = starts or breed = arguments) and
            in-discovery-neighbor? myargu and color != gray and color != red and
	    color != turquoise and not ( any? turtles with [breed = researchers
	    and xcor = [xcor] of myself and ycor = [ycor] of myself and
	    member? self [collaborator-network] of curresearcher])]
          set moved true
        ]
        ]
            ][

        ; if there is no next argument and the current argument is
        ; fully researched, the researcher moves a step back
        ifelse [color] of myargu = red and any? turtles with [color != gray and
          color != turquoise and out-discovery-neighbor? myargu and not any?
	  turtles with [breed = researchers and xcor = [xcor] of myself and
	  ycor = [ycor] of myself and member? self [collaborator-network]
	  of curresearcher]][
        move-to one-of turtles with [color != gray and out-discovery-neighbor?
          myargu and not any? turtles with [breed = researchers and xcor = [xcor] of
          myself and ycor = [ycor] of myself and member? self
          [collaborator-network] of curresearcher]]
        set moved true
          ][

        ; if moving back is not possible, it jumps to another argument in
        ; the same tree/theory that is discovered but not fully researched
        if [color] of myargu = red[
          let askstart [mytheory] of myargu
          if any? turtles with [(breed = starts or breed = arguments) and
	    color != gray and color != turquoise and color != red and
	    mytheory = askstart and not any? turtles with [breed = researchers and
  	    xcor = [xcor] of myself and ycor = [ycor] of myself and member?
	    self [collaborator-network] of curresearcher]][
          move-to one-of turtles with [(breed = starts or breed = arguments) and
	   color != turquoise and color != gray and color != red and
  	   mytheory = askstart and not any? turtles with [breed = researchers and
	   xcor = [xcor] of myself and ycor = [ycor] of myself and member? self
           [collaborator-network] of curresearcher]]
          set moved true
            ]
        ]
          ]
            ]
      ]
    ]
  ]
end





; researchers working on a not fully researched attacked argument will try to find a
; defense for that attack, by staying on the current argument
; if a child-argument is discovered that can provide a defense, the
; researcher moves there
; once an argument is fully researched all its relations are discovered,
; then an researcher can move on and can try to find a defense in another branch,
; further away
to find-defense
  ask researchers with [not moved][
    let curresearcher self
    if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
      let myx xcor
      let myy ycor
      ; variables for the argument the researcher is working on and
      ; for the researcher itself
      let myargu one-of turtles with [(breed = starts or breed = arguments) and
        xcor = myx and ycor = myy]

      ; lists of arguments that are not admissible
      let not-admissible []
      if admissible-subj-argu != 0 and not empty? admissible-subj-argu [
        let info-not-admissible filter [ [?1] -> not member? ?1 admissible-subj-argu ]
          subjective-arguments
        foreach info-not-admissible [ [?1] ->
          set not-admissible lput item 0 ?1 not-admissible
        ]
      ]

      ; if the current argument is not fully researched and not admissible
      ; and it is a 5th time step or the researcher is not communicating
      ; the researcher tries to move prospectively to a child-argument of the current
      ; argument that provides a defense for the current argument
      if member? myargu not-admissible[
        ask myargu [
          ask my-in-attacks [
            ask end1 [
              ; create a set of arguments that provide a defense for the current
	      ; argument, these:
              ; a) attack the attacker of the current argument;
	      ; b) are a child-argument of the current argument;
              ; c) are discovered; and
	      ; d) no researcher from the same network is working on it
              let nextargu in-attack-neighbors with [in-discovery-neighbor?
	        myargu and color != gray and color != turquoise and not (any?
		researchers with [xcor = [xcor] of myself and ycor = [ycor] of myself
		and member? self [collaborator-network] of curresearcher])]
              ; if such an argument exists the researcher moves there
              ; and cannot move anymore this time step
              if any? nextargu [
                ask curresearcher [
                  move-to one-of nextargu
                  set moved true
                ]
              ]
            ]
          ]
        ]
      ]
    ]
  ]
end





; every five time steps the landscape is updated:
; new arguments become visible and attacks are discovered
to update-landscape
  ask turtles with [breed = arguments or breed = starts][
    let myx xcor
    let myy ycor
    ; discoveries only occur when an researcher is working on that argument,
    ; it is the 5th time step or the researcher does not communicate
    ; working on an argument means that the researcher did
    ; not communicate in that round
    if any? turtles with [breed = researchers and xcor = myx and ycor = myy and
      communicating = 0] or (any? turtles with [breed = researchers and
      xcor = myx and ycor = myy] and ticks mod 5 = 0)[
      set researcher-ticks researcher-ticks + 1

      ; the color of an argument is changed if researchers have been working
      ; on that argument for research-speed time steps
      if researcher-ticks mod research-speed = 0 and color != red[
        set color color - 10
        if color = red [set full-research true]
      ]

      ; depending on the color a new child-argument is discovered, until all
      ; child-arguments are discovered
      if color = yellow and count out-discovery-neighbors with
	[color = gray or color = turquoise] >= 4 [
        ask one-of out-discovery-neighbors with
	  [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
      if color = brown and count out-discovery-neighbors with
	[color = gray or color = turquoise] >= 3 [
        ask one-of out-discovery-neighbors with
	  [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
      if color = orange and count out-discovery-neighbors with
	[color = gray or color = turquoise] >= 2 [
       ask one-of out-discovery-neighbors with
         [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
      if color = red and count out-discovery-neighbors with
	[color = gray or color = turquoise] >= 1 [
        ask one-of out-discovery-neighbors with
  	 [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]

      ; for arguments that have still undiscovered relations/neighbors and are
      ; not fully researched
      if ticks mod 5 = 0 and color != red [
        let attack-random random-float 1.00

        ; with visibility-probability a new attacked/attacking argument is
        ; discovered
        if attack-random < visibility-probability [
          if any? my-links with [breed = attacks and color = gray][
            ask one-of my-links with [breed = attacks and color = gray][
              set color red
              ask other-end [if color = gray [set color turquoise]]
            ]
          ]
        ]
      ]
    ]

    ; once an argument is fully researched all its relations to other arguments
    ; are discovered as well
    full-discovery

    ; if both ends of a discovery relation are discovered
    ; by research, the relation is discovered as well
    if color != gray [
      ask my-out-discoveries with [color = gray][
        if [color] of other-end != gray and [color] of other-end != turquoise [
          set color cyan
        ]
      ]
    ]
  ]

  ; at the end of the time steps 1, 2, 3 and 4 communicating researchers
  ; decrease their communicating value by 1
  if ticks mod 5 != 0 [
    ask researchers with [communicating > 0][
      set communicating communicating - 1
    ]
  ]
end





; procedure that makes sure that fully researched arguments have a fully
; discovered neighborhood
to full-discovery
  ask turtles with [breed = arguments or breed = starts and full-research][
    let myx xcor
    let myy ycor
    if any? turtles with [breed = researchers and xcor = myx and ycor = myy and
      communicating = 0] or (ticks mod 5 = 0 and any? turtles with
      [breed = researchers and xcor = myx and ycor = myy])[

      ; once an argument is fully researched all its relations,
      ; attack and discovery, are discovered
      if any? out-discovery-neighbors with [color = gray or color = turquoise][
        ask out-discovery-neighbors with [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]

      ; note that in the case of an attack relation the other argument
      ; is not really discovered: it needs to be discovered by a discovery
      ; relation in the other theory to become lime
      if any? my-in-attacks with [color = gray][
        ask my-in-attacks with [color = gray][
          set color red
          ask other-end [if color = gray [set color turquoise]]
        ]
      ]
      if any? my-out-attacks with [color = gray][
        ask my-out-attacks with [color = gray][
          set color red
          ask other-end [if color = gray [set color turquoise]]
        ]
      ]
    ]
    set full-research false
  ]
end





