; the procedures that determine
; the basic behavior of the researchers:
; 1. how they update their memory
; 2. how they share information
; 3. how they walk around on the landscape
; 4. how the landscape is updated


; procedure which reports the argument at the current position
; called by researchers in order to determine the argument they are
; currently working/standing on
to-report gps
	let myx xcor
	let myy ycor
	let myargu one-of startsargum with [xcor = myx and ycor = myy]
	report myargu
end





; procedure which merges lists of arguments with colors (alist and blist)
; and removes all duplicates from the merged list which is then reported
; alist is supposed to be the arguments already in the reserchers memory and
; blist corresponds to the new input 
; the procedure is called with a flag (type: boolean) which determines
; whether it has to look in 2nd input list (blist) for duplicates or not
; this is done (flag = false) to increase performance when the procedure is
; called with a blist that can't contain duplicates in itself
; and where the blist entries are guaranteed to be the most recent version
; availiable in the landscape (e.g update-memories)
; alist in general musn't contain any duplicates
; arguments that are part of the lists with different colors also count as
; duplicates. In these cases only the entry with the lowest color value
; is kept i.e. the arguments which are furthest researched
to-report merge-arg-wo-duplicates [alist blist flag]
	if flag [
		set blist remove-duplicates blist
	]
	foreach blist [ [?1] ->
		let argu first ?1
		let my-color item 1 ?1
		if flag [
			let duplicate-check filter [ [??1] -> first ??1 = argu ] blist
			foreach duplicate-check [ [??1] ->
				if item 1 ??1 > my-color [
					set blist remove ??1 blist
				]
			]
		]
		; argu-old will contain the current argument (argu) from blist if this
		; argument also is present in alist. argu-old is a nested list:
		; lists [[(argu) color-argu-in-alist]]
		let argu-old filter [ [??1] -> first ??1 = argu ] alist
		if not empty? argu-old [
			; item 0 will reduce the degree of nestedness of the argu-old by one i.e.
			; argu-old will now now be [(argu) color-argu-in-alist]	
			set argu-old item 0 argu-old
			if my-color < item 1 argu-old [
			let argument-position position argu-old alist
				if argument-position != false [
					set alist replace-item argument-position alist ?1
				]
			]
			if my-color >= item 1 argu-old [
				set blist remove ?1 blist
			]
		]
	]
	; finally the lists which had their respective duplicates removed are merged
	; and identical entries are removed. The result is then reported
  set alist remove-duplicates sentence alist blist
	report alist
end




; a new duplicate remover for lists with arguments + colors it takes a list
; as input and will report the same list back with each argument only
; contained once with the the arguments most researched color (i.e. the
; lowest color value). It is specificially designed for the share-with-others
; procedure as the merge-arg-wo-duplicates procedure is unfortunately still a
; bit slow in this regard. 
to-report arg-list-dupl-remover [alist]
	set alist remove-duplicates alist
	let widearglist convert-arglist-long-to-wide alist
	set alist convert-arglist-wide-to-long widearglist
	report alist
end



; procedure which transforms a argulist with colors of the format
; [[(argu-1) color-1]...[(argu-i) color-i]] (the long format) and transforms
; it to [[(argu-1)...(argu-i)] [(argu-j)...] ... [(argu-k)...] [(argu-1) ...
; (argu-n)]] (the wide format).
; Here the first nested list [(argu-1) ... (argu-i)] corresponds to all
; arguments with the color red (redargs) the next is orange (orangeargs),
; all the way till turquoise and then the last list (argulist):
; [(argu-i)... (argu-n)] will be a list of all arguments.
to-report convert-arglist-long-to-wide [longarglist]
	let redargs []
	let orangeargs []
	let brownargs []
	let yellowargs []
	let greenargs []
	let limeargs []
	let turquoiseargs []
	let argulist []
	foreach longarglist	[ [colorarg] ->
		let curargu item 0 colorarg
		let curcolor item 1 colorarg
		set argulist lput curargu argulist
		if curcolor = 15 [
			set redargs lput curargu redargs
		]
		if curcolor = 25 [
			set orangeargs lput curargu orangeargs
		]
		if curcolor = 35 [
			set brownargs lput curargu brownargs
		]
		if curcolor = 45 [
			set yellowargs lput curargu yellowargs
		]
		if curcolor = 55 [
			set greenargs lput curargu greenargs
		]
		if curcolor = 65 [
			set limeargs lput curargu limeargs
		]
		if curcolor = 75 [
			set turquoiseargs lput curargu turquoiseargs
		]
	]
	set argulist remove-duplicates argulist
	let widearglist (list redargs orangeargs brownargs yellowargs greenargs limeargs turquoiseargs argulist)
	report widearglist
end


; this procedure is the reverse procedure to convert-arglist-long-to-wide.
; It takes a argument list in the wide format as produced by the long-to-wide
; procedure and transforms it back into a long-list i.e. the format where
; each argument has it's color right with it's entry: 
; [[(argu-1) color-1] ... [(argu-n) color-n]]
; The output will contain each argument only once with the the most
; researched color (i.e. the lowest color value)
to-report convert-arglist-wide-to-long [widearglist]
	let redargs item 0 widearglist
	let orangeargs item 1 widearglist
	let brownargs item 2 widearglist
	let yellowargs item 3 widearglist
	let greenargs item 4 widearglist
	let limeargs item 5 widearglist
	let turquoiseargs item 6 widearglist
	let argulist item 7 widearglist
	let longarglist []
	foreach argulist
	[ [argu] ->
		ifelse member? argu redargs [
			set longarglist lput list argu 15 longarglist
		][
			ifelse member? argu orangeargs [
				set longarglist lput list argu 25 longarglist
			][
				ifelse member? argu orangeargs [
					set longarglist lput list argu 35 longarglist
				][
					ifelse member? argu orangeargs [
						set longarglist lput list argu 45 longarglist
					][
						ifelse member? argu orangeargs [
							set longarglist lput list argu 55 longarglist
						][
							ifelse member? argu orangeargs [
								set longarglist lput list argu 65 longarglist
							][
								set longarglist lput list argu 75 longarglist
							]
						]
					]
				]
			]
		]
	]	
	report longarglist
end






; every round, the researchers update their memory:
; arguments that have changed color, new arguments/links
; every fifth round the researchers share their updated memory within their
; collaborator-network
to update-memories
  ask researchers [
		; the argument the researcher is standing on is written to cur-argum
		let cur-argum gps
    let cur-researcher self
    ; information of current argument in the format of the memory
    let add-cur (sentence cur-argum [color] of cur-argum)
    ; list of relations (resp. arguments) that are added
    let to-add []
		let to-add-argu []
    set to-add-argu lput add-cur to-add-argu
    ; list of neighborhood arguments of the current argument
    set neighborargs []
    set neighborargs lput cur-argum neighborargs

    ; for the current argument
    ; add the neighboring discovered arguments and relations
    ; (attacks and discovery) to a to-add list
    ask cur-argum [
       if any? my-in-discoveries with [color != gray][
        ask my-in-discoveries with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added discovery relation
          let add-rel []
          set add-rel lput "d" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the child argument of the discovery relation
      if any? my-out-discoveries with [color != gray][
        ask my-out-discoveries with [color != gray][
	  let add-other-end other-end
	  ask cur-researcher [
	    set neighborargs lput add-other-end neighborargs
	  ]
	  ; construction of the to be added discovery relation
	  let add-rel []
	  set add-rel lput "d" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput add-other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the parent argument of the attack relation
      if any? my-in-attacks with [color != gray][
        ask my-in-attacks with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput add-other-end add-rel
          set add-rel lput cur-argum add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]

      ; add the child argument of the attack relation
      if any? my-out-attacks with [color != gray][
        ask my-out-attacks with [color != gray][
          let add-other-end other-end
          ask cur-researcher [
            set neighborargs lput add-other-end neighborargs
          ]
          ; construction of the to be added attack relation
          let add-rel []
          set add-rel lput "a" add-rel
          set add-rel lput cur-argum add-rel
          set add-rel lput other-end add-rel
          set to-add lput add-rel to-add
          ; the to be added argument
          let add-other (sentence add-other-end [color] of add-other-end)
          set to-add-argu lput add-other to-add-argu
        ]
      ]
    ]
    set subjective-relations sentence subjective-relations to-add
		set subjective-arguments sentence subjective-arguments to-add-argu
  ]
end





; procedure in which researchers share their memory with other researchers
; from their collaborator-network (=group)
to share-with-others
	foreach colla-networks [ [?1] ->
		let group-sharing-done false
		let grp-share-researcher []
		let cur-group ?1
		foreach cur-group [ [??1] ->
			let cur-researcher ??1
			ifelse group-sharing-done [
				ask cur-researcher [
					set rep-researcher false
					set subjective-arguments [subjective-arguments] of
					grp-share-researcher
					set subjective-relations [subjective-relations] of
					grp-share-researcher
				]
			][
				set group-sharing-done true
				set grp-share-researcher cur-researcher
				ask cur-researcher [
					; reset the variables
					set rep-researcher false
					set to-add-mem-argu []
					set to-add-mem-rel []

					; variables to keep track of the current researchers own memory
					; and the combined memory of all the sharing researchers
					; let own-memory-argu subjective-arguments
					; let own-memory-rel subjective-relations
					let comb-memory-argu []
					let comb-memory-rel []
					; collaborator network of the current researcher
					let cur-network collaborator-network

					; the information in the memories of the single researchers in
					; the network are combined
					foreach cur-group [ [???1] ->
						let input-researcher ???1
						set comb-memory-argu remove-duplicates sentence
							[subjective-arguments] of input-researcher comb-memory-argu
						set comb-memory-rel remove-duplicates sentence 
							[subjective-relations] of	input-researcher comb-memory-rel
					]
					; the group-share-researcher adds the combined memory to its own
					set subjective-arguments (arg-list-dupl-remover comb-memory-argu)
					set subjective-relations comb-memory-rel
				]
			]
		]
	]
end




; procedure in which researchers collect the information from their
; memory that they want to share with researchers that do not
; belong to their own collaborator-network
to create-share-memory

  ; for each collaborator-network one researcher is set to be
  ; the representative researcher
  foreach colla-networks [ [?1] ->
    ifelse length ?1 > 1 [
      ask one-of researchers with [member? self ?1][
        set rep-researcher true
      ]
    ][
			if ticks mod 25 = 4 [
				ask one-of researchers with [member? self ?1][
					set rep-researcher true
      ]
    ]
    ]
  ]

  ; only the representative researchers create a memory
  ; that they want to share with researchers from other networks
  ask researchers with [rep-researcher][
		let cur-argum gps  
    let cur-researcher self
    let cur-th [mytheory] of cur-argum
    ; create a list of arguments and a list of relations that the researcher
		; can share with researchers from other collaborative networks
    ; what researchers share depends on the "social-action" and "sharing"
    ; from the interface
    set th-args []
    set th-relations []

    ; researchers share only information obtained in the neighborhood
    ; they are currently working on
    ; collect the arguments from the researcher's memory
    ; that belong also to the neighborargs
    foreach subjective-arguments [ [?1] ->
      if member? item 0 ?1 [neighborargs] of cur-researcher [
        set th-args lput ?1 th-args
      ]
    ]
    ; collect the relations from/to the current argument
    ; from the researcher's memory
    foreach subjective-relations [ [?1] ->
      if item 1 ?1 = cur-argum or item 2 ?1 = cur-argum [
        set th-relations lput ?1 th-relations
      ]
    ]

    ; if the researcher behaves biased she does not share the attack relations
		; that attack its current theory, these relations are removed
    if social-actions = "biased"[
      foreach th-relations [ [?1] ->
        if item 0 ?1 = "a" and [mytheory] of item 2 ?1 = cur-th [
          set th-relations remove ?1 th-relations
        ]
      ]
    ]
  ]
end





; procedure in which the representative researchers of the networks
; share information according to the social structure
; if a rep-researcher already exchanged information researchers in her
; sharing network i.e. if she attended the conference she will set her
; agent-owned variable "conference-attended" to true in order to not add 
; the same information multiple times
to share-with-other-networks
  ask researchers with [rep-researcher][
		if not conference-attended [
			; variables for the combined information (arguments and relations),
			; the network of the current researcher and the theory she is working on
			let comb-memory-argu th-args
			let comb-memory-rel th-relations
			let cur-network sort collaborator-network
			let my-cur-theory [mytheory] of item 0 item 0 th-args

			; create a list of the neighboring networks and then a
			; list of the representative researchers (share-researchers) of these
			; networks which will be the researchers the current researcher 
			; shares with
			let share-researchers []
			let share-neighbors []
			foreach share-structure [ [?1] ->
				if first ?1 = cur-network [
					set share-neighbors ?1
				]
			]
			ask researchers with [rep-researcher][
				let cur-researcher self
				foreach share-neighbors [ [?1] ->
					if member? cur-researcher ?1 [
						set share-researchers lput cur-researcher share-researchers
					]
				]
			]

			; create a list of arguments and a list of relations that is
			; shared among the share-researchers
			foreach share-researchers [ [?1] ->
				; the combined memory is updated to contain the information
				; of all the share researchers				
				set comb-memory-argu remove-duplicates sentence comb-memory-argu 
				[th-args] of ?1
				set comb-memory-rel remove-duplicates sentence comb-memory-rel 
				[th-relations] of ?1
			]			
			; the combined memory is written into the memory of all the current
			; share researchers which means they obtained all the information by 
			; attending the conference
			foreach share-researchers [ [?1] ->
				ask ?1 [
					set to-add-mem-argu comb-memory-argu
					set to-add-mem-rel comb-memory-rel
					set conference-attended true
				]
			]
		]
	]

end





; procedure that adds the new information to the memory of the
; representative researchers and computes the time they have lost by
; communicating
to compute-time-costs
	ask researchers with [rep-researcher][
		; variables that contain the arguments and relations the
		; researcher has to update in its memory
		let new-memory-args []
		let new-memory-rel []
		let to-add-argu []
		set new-memory-args filter [ [?1] -> not member? ?1 subjective-arguments ]
			to-add-mem-argu
		set new-memory-rel filter [ [?1] -> not member? ?1 subjective-relations ]
			to-add-mem-rel
		let comb-new sentence new-memory-args new-memory-rel
		; every tick an researcher can obtain a maximum of max-learn new entries
		; (max-learn is hidden-variable which is set to 10 by default)
		; the day that they received information is also lost
		ifelse length comb-new >= (3 * max-learn) [
			set communicating 4
		][
			set communicating ((ceiling (length comb-new / max-learn)) + 1)
		]

		; every communication round an researcher can update a maximum of
		; 3 * max-learn new arguments/relations (corresponding to three ticks of
		; communication) these new arguments and relations are added to the
		; memory of the researcher
		; when a new relation is added and the arguments are not part of the
		; memory of the researcher, these arguments are added as well
		ifelse length comb-new > (3 * max-learn) [
			set comb-new shuffle comb-new
			let repeats length comb-new - (3 * max-learn)
			while [length comb-new > repeats] [
				let cur-entr first comb-new
				let new-mem-argargs filter [ [?1] -> member? ?1 new-memory-args ]
				comb-new
				set new-mem-argargs map [ [?1] -> first ?1 ] new-mem-argargs
				ifelse member? cur-entr new-memory-args [
					set to-add-argu lput cur-entr to-add-argu
					set comb-new remove cur-entr comb-new
				][
					set subjective-relations lput cur-entr subjective-relations
					set comb-new remove cur-entr comb-new
					if member? item 1 cur-entr new-mem-argargs[
						let item-1-cur-entr item 1 cur-entr
						foreach comb-new [ [?1] ->
							if item-1-cur-entr = item 0 ?1 [
								set to-add-argu lput ?1 to-add-argu
								set comb-new remove ?1 comb-new
							]
						]
					]
					if member? item 2 cur-entr new-mem-argargs [
						let item-2-cur-entr item 2 cur-entr
						foreach comb-new [ [?1] ->
							if item-2-cur-entr = item 0 ?1 [
								set to-add-argu lput ?1 to-add-argu
								set comb-new remove ?1 comb-new
							]
						]
					]
				]
			]
			set subjective-arguments (merge-arg-wo-duplicates subjective-arguments
			to-add-argu true)
		][
			set subjective-arguments (merge-arg-wo-duplicates subjective-arguments
			new-memory-args true)
			set subjective-relations sentence subjective-relations new-memory-rel
		]
		; the researcher owned "conference-attended" variable is reset for the
		; next round
		set conference-attended false
	]
end





; reports whether a member of the collaborative network (=group) of the
; curresearcher is at the position of the caller
; called by arguments during the movement procedures
; represents the fact that agents will coordinate with their their
; collaborative network (=group) to not to move to an argument where a group
; member is already working, in order to keep redundancy of their research low
to-report group-member-here [curresearcher] 
	ifelse any? researchers with [
			xcor = [xcor] of myself and ycor = [ycor] of myself 
			and member? self [collaborator-network] of curresearcher][
		report true
	][
		report false
	]

end




; procedure that describes how the researchers move around over the landscape
; they only "see" the colored (i.e. non gray) part of the landscape and hence
; can only move there, the probability of moving increases (a little) when the
; argument is further researched
; agents will coordinate with their their collaborative network (=group) to 
; not to move to an argument where a group member is already working
; in order to keep redundancy of their research low
; in one time step researchers can either receive/digest information or
; move, but not both
to move-around
  ; variable to make sure that the procedure find-defense
  ; is only run once
  let run-find-defense false
  ; at the beginning of the procedure no researcher has moved yet
  ask researchers [
    set moved false
  ]
  ask researchers [
    let curresearcher self
    if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
			let myargu gps     
      ; the researcher owned variable which contains all the non defensible
			; arguments as a list is written to not-admissible
      let not-admissible non-admiss-subj-argu
			
      ; an researcher working on a non defensible argument will try to find a
			; defense for this attack, by working further on the attacked argument,
			; unless she discoveres a child-argument that that has a defense for
			; the attack (it is not necessarily the case that this defense is
			; already discovered) or until she has fully researched the argument
      ; the find-defense runs immediately for all researchers working on 
			; a not fully researched non defensible argument,
			; hence it is only once executed
      if member? myargu not-admissible and not moved [

        if not run-find-defense [
          find-defense
          set run-find-defense true
        ]
      ]

      if not moved and not member? myargu not-admissible or
        (member? myargu not-admissible and [color] of myargu = red)[

        ; when an argument exists that:
        ; a) is a child-argument of the current argument;
        ; b) is not gray, red or turquoise; and
        ; c) no researcher from the same collaborator-network is working on it
        ; the researcher moves there, with certain probability
        ifelse any? startsargum with [in-discovery-neighbor? myargu
					and [not member? color [gray red turquoise]] of self
					and not group-member-here curresearcher][
					let move-random random-float 1.0


					; every time step with small-movement of the move-probability
					; the researcher moves
					ifelse move-random < (small-movement * move-probability *
						(1 - (color / color-move))) [
						move-to one-of startsargum with [
							in-discovery-neighbor? myargu
							and [not member? color [gray red turquoise]] of self
							and not group-member-here curresearcher]
						set moved true
					][

						; every 5th time step the researcher mover with the full
						; move-probability, that depends a bit on the color
						if ticks != 0 and ticks mod 5 = 0 and move-random <
							move-probability * (1 - (color / color-move)) [
							move-to one-of startsargum with [
								in-discovery-neighbor? myargu
								and [not member? color [gray red turquoise]] of self
								and not group-member-here curresearcher]
							set moved true
						]
					]
				][

					; if there is no next argument and the current argument is
					; fully researched, the researcher moves a step back
					ifelse [color] of myargu = red 
						and any? startsargum with 
						[[not member? color [gray turquoise]] of self
						and out-discovery-neighbor? myargu and not group-member-here
						curresearcher][
						move-to one-of startsargum with [ 
						[not member? color [gray turquoise]] of self
						and out-discovery-neighbor? myargu
						and not group-member-here curresearcher]
						set moved true
					][

						; if moving back is not possible, she jumps to another argument in
						; the same tree/theory that is discovered but not fully researched
						if [color] of myargu = red [
							let askstart [mytheory] of myargu
							if any? startsargum with [
								[not member? color [gray red turquoise]] of self
								and mytheory = askstart 
								and not group-member-here curresearcher][
								move-to one-of startsargum with [
									[not member? color [gray red turquoise]] of self
									and mytheory = askstart
									and not group-member-here curresearcher]
								set moved true
							]
						]
					]
				]
      ]
    ]
  ]
end





; researchers working on a not fully researched non defensible argument will
; try to find a defense for that attack, by staying on the current argument
; if a child-argument is discovered that can potentially provide a defense
; (it is not necessarily the case that this defense is already discovered),
; the researcher moves there
; once an argument is fully researched all its relations are discovered,
; so the researcher can move on and can try to find a defense in another
; branch further away
to find-defense
  ask researchers with [not moved][
    let curresearcher self
		if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
			let myargu gps
			; lists of arguments that are not admissible
			let not-admissible non-admiss-subj-argu
			
			; if the current argument is not fully researched and not admissible
			; and it is a 5th time step or the researcher is not communicating
			; the researcher tries to move prospectively to a child-argument of the
			; current argument that provides a defense for the current argument
			if member? myargu not-admissible [
				ask myargu [
					ask my-in-attacks [
						ask end1 [
						; create a set of arguments that provide a defense for the current
						; argument, these:
						; a) attack the attacker of the current argument;
						; b) are a child-argument of the current argument;
						; c) are discovered; and
						; d) no researcher from the same group is working on it
							let nextargu in-attack-neighbors with [in-discovery-neighbor?
								myargu
								and	[not member? color [gray turquoise]] of self
								and not group-member-here curresearcher]
							; if such an argument exists the researcher moves there
							; and cannot move anymore this time step
							if any? nextargu [
								ask curresearcher [
									move-to one-of nextargu
									set moved true
								]
							]
						]
					]
				]
			]
		]			
  ]
end




; reports whether an appropriate researcher (i.e. one that is not digesting
; information from communication) is present at the position myx myy
; called by arguments when the landscape is updated
to-report non-comm-scientists-here [myx myy]
	ifelse any? researchers with [xcor = myx and ycor = myy 
		and communicating = 0]
	or (ticks mod 5 = 0 and any? researchers with [xcor = myx and ycor = myy])[
		report true
	][
		report false
	]
end




; every five time steps the landscape is updated:
; new arguments become visible and attacks are discovered
to update-landscape
  ask startsargum [
    let myx xcor
    let myy ycor
    ; discoveries only occur when an researcher is working on that argument,
    ; it is the 5th time step or the researcher does not communicate
    ; working on an argument means that the researcher did
    ; not communicate in that round
    if non-comm-scientists-here myx myy	[
      set researcher-ticks researcher-ticks + 1

      ; the color of an argument is changed if researchers have been working
      ; on that argument for research-speed time steps
      if researcher-ticks mod research-speed = 0 and color != red [
        set color color - 10
        if color = red [set full-research true]
      ]

      ; depending on the color a new child-argument is discovered, until all
      ; child-arguments are discovered
      if color = yellow and count out-discovery-neighbors with
				[color = gray or color = turquoise] >= 4 [
        ask one-of out-discovery-neighbors with
					[color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
      if color = brown and count out-discovery-neighbors with
				[color = gray or color = turquoise] >= 3 [
        ask one-of out-discovery-neighbors with
					[color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
      if color = orange and count out-discovery-neighbors with
				[color = gray or color = turquoise] >= 2 [
				ask one-of out-discovery-neighbors with
         [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
      if color = red and count out-discovery-neighbors with
				[color = gray or color = turquoise] >= 1 [
        ask one-of out-discovery-neighbors with
					[color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]

      ; for arguments that have still undiscovered relations/neighbors and are
      ; not fully researched
      if ticks mod 5 = 0 and color != red [
        let attack-random random-float 1.00

        ; with visibility-probability a new attacked/attacking argument is
        ; discovered
        if attack-random < visibility-probability [
          if any? my-links with [breed = attacks and color = gray][
            ask one-of my-links with [breed = attacks and color = gray][
              set color red
              ask other-end [if color = gray [set color turquoise]]
            ]
          ]
        ]
      ]
    ]
    ; if both ends of a discovery relation are discovered
    ; by research, the relation is discovered as well
    if color != gray [
      ask my-out-discoveries with [color = gray][
        if [not member? color [gray turquoise]] of other-end [
          set color cyan
        ]
      ]
    ]
  ]
end





; once an argument is fully researched all its relations to other arguments
; are discovered as well therefore this procedure makes sure that fully
; researched arguments have a fully discovered neighborhood
to full-discovery
  ask startsargum with [full-research][
    let myx xcor
    let myy ycor
    if non-comm-scientists-here myx myy [

      ; once an argument is fully researched all its relations,
      ; attack and discovery, are discovered
      if any? out-discovery-neighbors with [color = gray or color = turquoise][
        ask out-discovery-neighbors with [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]

      ; note that in the case of a discovery via attack relation the other
			; argument is not really discovered: it needs to be discovered by a
			; discovery relation in the other theory to become lime
      if any? my-in-attacks with [color = gray][
        ask my-in-attacks with [color = gray][
          set color red
          ask other-end [if color = gray [set color turquoise]]
        ]
      ]
      if any? my-out-attacks with [color = gray][
        ask my-out-attacks with [color = gray][
          set color red
          ask other-end [if color = gray [set color turquoise]]
        ]
      ]
    ]
    set full-research false
  ]
end





; at the end of the time steps 1, 2, 3 and 4 communicating researchers
; decrease their communicating value by 1 which corresponds to them having used
; the day to digest the information they gained while communicating
to communication-regress
    ask researchers with [communicating > 0][
      set communicating communicating - 1
    ]
end

