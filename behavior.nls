; the procedures that determine
; the basic behavior of the researchers:
; 1. how they update their memory
; 2. how they share information
; 3. how they walk around on the landscape
; 4. how the landscape is updated


; procedure which reports the argument at the current position
; called by researchers in order to determine the argument they are
; currently working/standing on
to-report gps
  let myx xcor
  let myy ycor
  let myargu one-of startsargum with [xcor = myx and ycor = myy]
  report myargu
end




; every round, the researchers update their memory:
; arguments that have changed color, new arguments/links
; The memory management is comprised of two parts:
; (a) The researchers save arguments and relations in the form of turtle-sets
; / link-sets in their memory (cf. infotab Variables -> `to-add-mem-argu`
; `to-add-mem-rel`) which will be synchronized every week with the group in
; the `share-with-group` procedure
; (b) the status in which the argument / relation is known to a certain
; collaborative network (=group) is saved in the argument / link itself. 
; (cf. infotab Variables -> `group-color-mem`, `in-group-i-memory`). For
; links this will be facilitated during the `share-with-group` procedure,
; while for arguments the color is updated right when the researchers update
; their memory
to update-memories
  ; the argument the researcher is standing on is written to cur-argum
  let cur-argum mygps
  let cur-researcher self
  let cur-group-id group-id  
  ; the argument the researcher is standing on is added to her memory (a)
  let to-add-mem-argu-cache cur-argum
  let to-add-mem-rel-cache no-links
  ask cur-argum [
    ; the most recent version (=color) of the argument the researcher is 
    ; standing on is now known by the group (b) 
    set group-color-mem replace-item cur-group-id group-color-mem color   
    ask my-links with [color != gray ] [
      ; discovered attacks are added to the researchers memory (a)
      if breed = attacks [
        set to-add-mem-rel-cache (link-set to-add-mem-rel-cache self)
      ]
      ; the same update as above for the cur-argum is done for all arguments 
      ; connected to cur-argum by non gray links
      ask other-end [ 
        ;(a)
        set to-add-mem-argu-cache (turtle-set to-add-mem-argu-cache self)
        ;(b)
        set group-color-mem replace-item cur-group-id group-color-mem color
      ]
    ]
  ]
  set to-add-mem-argu (turtle-set to-add-mem-argu to-add-mem-argu-cache)
  set to-add-mem-rel (link-set to-add-mem-rel to-add-mem-rel-cache)
  set flag-updated-memory true  
end





; intra-group sharing: researchers share their memory with other researchers
; from their collaborator-network (=group).
; The memory update is twofold (cf. update-memories)
; (a) the agentset which contains the arguments / relations themselves and
; (b) the information saved within the arguments /relations on how the item is 
; remembered by the group
; For arguments (b) has already been done during `update-memories` so only (a)
; needs to be performed, while for relations (=attacks) both (a) + (b) will be
; performed
to share-with-group
  foreach colla-networks [ [cur-group] ->
    ; after the information has been combined by the grp-share-researcher the
    ; other group members copy that information into their own memory
    let group-sharing-done false
    let grp-share-researcher []
    foreach cur-group [ [cur-researcher] ->
      ifelse group-sharing-done [
        ask cur-researcher [
          set rep-researcher false
          set subjective-arguments [subjective-arguments] of
          grp-share-researcher
          set subjective-relations [subjective-relations] of
          grp-share-researcher
          set to-add-mem-argu no-turtles
          set to-add-mem-rel no-links
        ]
      ][
        ; one researcher combines all the information
        set group-sharing-done true
        set grp-share-researcher cur-researcher        
        ask cur-researcher [     
          let cur-group-id group-id        
          ; reset the variables
          set rep-researcher false          
          ; variables to keep track the combined memory of all the sharing
          ; researchers
          let comb-memory-argu no-turtles
          let comb-memory-rel no-links 
          ; the last rep-researcher of the group integrates the arguments
          ; learned via this communication into her memory
          transfer-argu-cache-to-memory     
          ; the information in the memories of the single researchers in
          ; the network are combined (a)
          foreach cur-group [ [input-researcher] ->
            set comb-memory-argu (turtle-set comb-memory-argu 
              [to-add-mem-argu] of input-researcher)
            set comb-memory-rel (link-set comb-memory-rel
              [to-add-mem-rel] of input-researcher)
          ]
          ; (b) is performed for the combined new relations of the group
          ask comb-memory-rel [
            set in-group-i-memory replace-item 
              cur-group-id in-group-i-memory true
          ]
          ; the group-share-researcher adds the combined memory to her own
          ; (a)
          set subjective-arguments (turtle-set subjective-arguments 
            comb-memory-argu)
          set subjective-relations (link-set subjective-relations
            comb-memory-rel)
          set to-add-mem-argu no-turtles
          set to-add-mem-rel no-links
        ]
      ]
    ]
  ]
end

; the arguments learned from the last inter-group sharing
; (share-with-other-networks) have been digested and are now merged with the
; arguments she learned via her own research (update-memories). The memory
; update is twofold (cf. update-memories)
; (a) the agentset which contains the arguments themselves and
; (b) the information saved within the arguments on how the item is 
; remembered by the group
to transfer-argu-cache-to-memory
  let cur-group-id group-id
  let cached-aguments no-turtles
  ; the last rep-researcher of the group has arguments she learned in the
  ; last inter-group communication in her argu-cache
  ask (turtle-set item cur-group-id colla-networks) with [any? argu-cache] [
    ; arguments for which the most recent version (=color) is in the
    ; argu-cache are selected...
    set cached-aguments argu-cache with [
      item cur-group-id group-color-mem-cache < 
      item cur-group-id group-color-mem]
    ; ...and combined with the other arguments she learned by her own research
    ; i.e. via update-memories (a)
    set to-add-mem-argu (turtle-set to-add-mem-argu argu-cache)
    set argu-cache no-turtles
  ]
  ; the argu-cache which is most recent updates the in-argument-memory (b)
  ask cached-aguments  [      
    set group-color-mem replace-item cur-group-id group-color-mem 
      (item cur-group-id group-color-mem-cache)   
  ]   
end




; procedure in which researchers collect the information from their
; memory that they want to share with researchers that do not
; belong to their own collaborator-network
to create-share-memory

  ; for each collaborator-network one researcher is set to be
  ; the representative researcher
  foreach colla-networks [ [?1] ->
    ifelse length ?1 > 1 [
      ask one-of researchers with [member? self ?1][
        set rep-researcher true
      ]
    ][
      if ticks mod 25 = 4 [
        ask one-of researchers with [member? self ?1][
          set rep-researcher true
      ]
    ]
    ]
  ]

  ; only the representative researchers create a memory
  ; that they want to share with researchers from other networks
  ask researchers with [rep-researcher][
    let cur-argum gps  
    let cur-researcher self
    let cur-th [mytheory] of cur-argum
    ; create a list of arguments and a list of relations that the researcher
    ; can share with researchers from other collaborative networks
    ; what researchers share depends on the "social-action" and "sharing"
    ; from the interface
    set th-args []
    set th-relations []

    ; researchers share only information obtained in the neighborhood
    ; they are currently working on
    ; collect the arguments from the researcher's memory
    ; that belong also to the neighborargs
    foreach subjective-arguments [ [?1] ->
      if member? item 0 ?1 [neighborargs] of cur-researcher [
        set th-args lput ?1 th-args
      ]
    ]
    ; collect the relations from/to the current argument
    ; from the researcher's memory
    foreach subjective-relations [ [?1] ->
      if item 1 ?1 = cur-argum or item 2 ?1 = cur-argum [
        set th-relations lput ?1 th-relations
      ]
    ]

    ; if the researcher behaves biased she does not share the attack relations
    ; that attack its current theory, these relations are removed
    if social-actions = "biased"[
      foreach th-relations [ [?1] ->
        if item 0 ?1 = "a" and [mytheory] of item 2 ?1 = cur-th [
          set th-relations remove ?1 th-relations
        ]
      ]
    ]
  ]
end





; procedure in which the representative researchers of the networks
; share information according to the social structure
to share-with-other-networks
  let rep-researchers researchers with [rep-researcher]
  ask rep-researchers [
    ; variables for the combined information (arguments and relations),
    ; the network of the current researcher and the theory she is working on
    let askresearcher self
    let comb-memory-argu []
    let comb-memory-rel []
    let cur-network sort collaborator-network

    ; create a list of the neighboring networks and then a
    ; list of the representative researchers (share-researchers) of these
    ; networks which will be the researchers the current researcher 
    ; shares with
    let share-researchers []
    let share-neighbors []
    foreach share-structure [ [?1] ->
      if first ?1 = cur-network [
        set share-neighbors ?1
      ]
    ]
    ask rep-researchers [
      let cur-researcher self
      foreach share-neighbors [ [cur-share-group] ->
        if cur-researcher != askresearcher 
          and member? cur-researcher cur-share-group [
          set share-researchers lput cur-researcher share-researchers
        ]
      ]
    ]

    ; create a list of arguments and a list of relations that is
    ; shared among the share-researchers
    foreach share-researchers [ [cur-share-researcher] ->
      ; the combined memory is updated to contain the information
      ; of all the share researchers        
      set comb-memory-argu sentence comb-memory-argu 
      [th-args] of cur-share-researcher
      set comb-memory-rel sentence comb-memory-rel 
      [th-relations] of cur-share-researcher
    ]
    ; finally the askresearcher inputs the information given to her  
    ;- by the rep. researchers from her share-neighbors groups - into her
    ; respective (researcher owned) variables and removes the duplicates
    set to-add-mem-argu remove-duplicates comb-memory-argu
    set to-add-mem-rel remove-duplicates comb-memory-rel
  ]

end





; procedure that adds the new information to the memory of the
; representative researchers and computes the time they have lost by
; communicating
to compute-time-costs
  ask researchers with [rep-researcher][
    ; variables that contain the arguments and relations the
    ; researcher has to update in its memory
    let new-memory-args []
    let new-memory-rel []
    let to-add-argu []
    set new-memory-args filter [ [?1] -> not member? ?1 subjective-arguments ]
      to-add-mem-argu
    set new-memory-rel filter [ [?1] -> not member? ?1 subjective-relations ]
      to-add-mem-rel
    let comb-new sentence new-memory-args new-memory-rel
    ; every tick an researcher can obtain a maximum of max-learn new entries
    ; (max-learn is hidden-variable which is set to 10 by default)
    ; the day that they received information is also lost
    ifelse length comb-new >= (3 * max-learn) [
      set communicating 4
    ][
      set communicating ((ceiling (length comb-new / max-learn)) + 1)
    ]

    ; every communication round an researcher can update a maximum of
    ; 3 * max-learn new arguments/relations (corresponding to three ticks of
    ; communication) these new arguments and relations are added to the
    ; memory of the researcher
    ; when a new relation is added and the arguments are not part of the
    ; memory of the researcher, these arguments are added as well
    ifelse length comb-new > (3 * max-learn) [
      set comb-new shuffle comb-new
      let repeats length comb-new - (3 * max-learn)
      while [length comb-new > repeats] [
        let cur-entr first comb-new
        let new-mem-argargs filter [ [?1] -> member? ?1 new-memory-args ]
        comb-new
        set new-mem-argargs map [ [?1] -> first ?1 ] new-mem-argargs
        ifelse member? cur-entr new-memory-args [
          set to-add-argu lput cur-entr to-add-argu
          set comb-new remove cur-entr comb-new
        ][
          set subjective-relations lput cur-entr subjective-relations
          set comb-new remove cur-entr comb-new
          if member? item 1 cur-entr new-mem-argargs[
            let item-1-cur-entr item 1 cur-entr
            foreach comb-new [ [?1] ->
              if item-1-cur-entr = item 0 ?1 [
                set to-add-argu lput ?1 to-add-argu
                set comb-new remove ?1 comb-new
              ]
            ]
          ]
          if member? item 2 cur-entr new-mem-argargs [
            let item-2-cur-entr item 2 cur-entr
            foreach comb-new [ [?1] ->
              if item-2-cur-entr = item 0 ?1 [
                set to-add-argu lput ?1 to-add-argu
                set comb-new remove ?1 comb-new
              ]
            ]
          ]
        ]
      ]
      set subjective-arguments (merge-arg-wo-duplicates subjective-arguments
      to-add-argu true)
    ][
      set subjective-arguments (merge-arg-wo-duplicates subjective-arguments
      new-memory-args true)
      set subjective-relations sentence subjective-relations new-memory-rel
    ]
  ]
end





; reports whether a member of the collaborative network (=group) of the
; curresearcher is at the position of the caller
; called by arguments during the movement procedures
; represents the fact that agents will coordinate with their their
; collaborative network (=group) to not to move to an argument where a group
; member is already working, in order to keep redundancy of their research low
to-report group-member-here [curresearcher] 
  ifelse any? researchers with [
      xcor = [xcor] of myself and ycor = [ycor] of myself 
      and member? self [collaborator-network] of curresearcher][
    report true
  ][
    report false
  ]

end


; procedure which is called by researchers when they move (to nextargu). It
; makes sure that the researcher has an updated memory of her surrounding
; before moving and updates the argument she's working on 
; (mygps - cf. infotab) to the argument she's moving to
to move-to-nextargu [nextargu]
  if not flag-updated-memory [ 
    update-memories
  ]
  set mygps nextargu
  move-to mygps
  set moved true 
end




; procedure that describes how the researchers move around over the landscape
; they only "see" the colored (i.e. non gray) part of the landscape and hence
; can only move there, the probability of moving increases (a little) when the
; argument is further researched
; agents will coordinate with their their collaborative network (=group) to 
; not to move to an argument where a group member is already working
; in order to keep redundancy of their research low
; in one time step researchers can either receive/digest information or
; move, but not both
to move-around
  ; variable to make sure that the procedure find-defense
  ; is only run once
  let run-find-defense false
  ; at the beginning of the procedure no researcher has moved yet
  ask researchers [
    set moved false
  ]
  ask researchers [
    let curresearcher self
    if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
      let myargu gps     
      ; the researcher owned variable which contains all the non defensible
      ; arguments as a list is written to not-admissible
      let not-admissible non-admiss-subj-argu
      
      ; an researcher working on a non defensible argument will try to find a
      ; defense for this attack, by working further on the attacked argument,
      ; unless she discoveres a child-argument that that has a defense for
      ; the attack (it is not necessarily the case that this defense is
      ; already discovered) or until she has fully researched the argument
      ; the find-defense runs immediately for all researchers working on 
      ; a not fully researched non defensible argument,
      ; hence it is only once executed
      if member? myargu not-admissible and not moved [

        if not run-find-defense [
          find-defense
          set run-find-defense true
        ]
      ]

      if not moved and (not member? myargu not-admissible or
        (member? myargu not-admissible and [color] of myargu = red))[

        ; when an argument exists that:
        ; a) is a child-argument of the current argument;
        ; b) is not gray, red or turquoise; and
        ; c) no researcher from the same collaborator-network is working on it
        ; the researcher moves there, with certain probability
        ifelse any? startsargum with [in-discovery-neighbor? myargu
          and [not member? color [gray red turquoise]] of self
          and not group-member-here curresearcher][
          let move-random random-float 1.0


          ; every time step with small-movement of the move-probability
          ; the researcher moves
          ifelse move-random < (small-movement * move-probability *
            (1 - (color / color-move))) [
            move-to one-of startsargum with [
              in-discovery-neighbor? myargu
              and [not member? color [gray red turquoise]] of self
              and not group-member-here curresearcher]
            set moved true
          ][

            ; every 5th time step the researcher mover with the full
            ; move-probability, that depends a bit on the color
            if ticks != 0 and ticks mod 5 = 0 and move-random <
              move-probability * (1 - (color / color-move)) [
              move-to one-of startsargum with [
                in-discovery-neighbor? myargu
                and [not member? color [gray red turquoise]] of self
                and not group-member-here curresearcher]
              set moved true
            ]
          ]
        ][

          ; if there is no next argument and the current argument is
          ; fully researched, the researcher moves a step back
          ifelse [color] of myargu = red 
            and any? startsargum with 
            [[not member? color [gray turquoise]] of self
            and out-discovery-neighbor? myargu and not group-member-here
            curresearcher][
            move-to one-of startsargum with [ 
            [not member? color [gray turquoise]] of self
            and out-discovery-neighbor? myargu
            and not group-member-here curresearcher]
            set moved true
          ][

            ; if moving back is not possible, she jumps to another argument in
            ; the same tree/theory that is discovered but not fully researched
            if [color] of myargu = red [
              let askstart [mytheory] of myargu
              if any? startsargum with [
                [not member? color [gray red turquoise]] of self
                and mytheory = askstart 
                and not group-member-here curresearcher][
                move-to one-of startsargum with [
                  [not member? color [gray red turquoise]] of self
                  and mytheory = askstart
                  and not group-member-here curresearcher]
                set moved true
              ]
            ]
          ]
        ]
      ]
    ]
  ]
end





; researchers working on a not fully researched non defensible argument will
; try to find a defense for that attack, by staying on the current argument
; if a child-argument is discovered that can potentially provide a defense
; (it is not necessarily the case that this defense is already discovered),
; the researcher moves there
; once an argument is fully researched all its relations are discovered,
; so the researcher can move on and can try to find a defense in another
; branch further away
to find-defense
  ask researchers with [not moved][
    let curresearcher self
    if [communicating] of curresearcher = 0 or ticks mod 5 = 0 [
      let myargu gps
      ; lists of arguments that are not admissible
      let not-admissible non-admiss-subj-argu
      
      ; if the current argument is not fully researched and not admissible
      ; and it is a 5th time step or the researcher is not communicating
      ; the researcher tries to move prospectively to a child-argument of the
      ; current argument that provides a defense for the current argument
      if member? myargu not-admissible [
        ask myargu [
          ask my-in-attacks [
            ; check to prevent the researcher from searching for further
            ; defender-childs (nextargu) when she already has moved to one
            if not [moved] of curresearcher [
              ask end1 [
              ; create a set of arguments that provide a defense for the 
              ; current argument, these:
              ; a) attack the attacker of the current argument;
              ; b) are a child-argument of the current argument;
              ; c) are discovered; and
              ; d) no researcher from the same group is working on it
                let nextargu in-attack-neighbors with [in-discovery-neighbor?
                  myargu
                  and [not member? color [gray red turquoise]] of self
                  and not group-member-here curresearcher]
                ; if such an argument exists the researcher moves there
                ; and cannot move anymore this time step
                if any? nextargu [
                  ask curresearcher [
                    move-to one-of nextargu
                    set moved true
                  ]
                ]
              ]
            ]
          ]
        ]
      ]
    ]     
  ]
end




; reports whether an appropriate researcher (i.e. one that is not digesting
; information from communication) is present at the position myx myy
; called by arguments when the landscape is updated
to-report non-comm-scientists-here [myx myy]
  ifelse any? researchers with [xcor = myx and ycor = myy 
    and communicating = 0]
  or (ticks mod 5 = 0 and any? researchers with [xcor = myx and ycor = myy])[
    report true
  ][
    report false
  ]
end




; every five time steps the landscape is updated:
; new arguments become visible and attacks are discovered
to update-landscape
  ask startsargum [
    let myx xcor
    let myy ycor
    ; discoveries only occur when an researcher is working on that argument,
    ; it is the 5th time step or the researcher does not communicate
    ; working on an argument means that the researcher did
    ; not communicate in that round
    if non-comm-scientists-here myx myy [
      set researcher-ticks researcher-ticks + 1

      ; the color of an argument is changed if researchers have been working
      ; on that argument for research-speed time steps
      if researcher-ticks mod research-speed = 0 and color != red [
        set color color - 10
        if color = red [set full-research true]
      ]

      ; depending on the color a new child-argument is discovered, until all
      ; child-arguments are discovered
      if color = yellow and count out-discovery-neighbors with
        [color = gray or color = turquoise] >= 4 [
        ask one-of out-discovery-neighbors with
          [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
      if color = brown and count out-discovery-neighbors with
        [color = gray or color = turquoise] >= 3 [
        ask one-of out-discovery-neighbors with
          [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
      if color = orange and count out-discovery-neighbors with
        [color = gray or color = turquoise] >= 2 [
        ask one-of out-discovery-neighbors with
         [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]
      if color = red and count out-discovery-neighbors with
        [color = gray or color = turquoise] >= 1 [
        ask one-of out-discovery-neighbors with
          [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]

      ; for arguments that have still undiscovered relations/neighbors and are
      ; not fully researched
      if ticks mod 5 = 0 and color != red [
        let attack-random random-float 1.00

        ; with visibility-probability a new attacked/attacking argument is
        ; discovered
        if attack-random < visibility-probability [
          if any? my-links with [breed = attacks and color = gray][
            ask one-of my-links with [breed = attacks and color = gray][
              set color red
              ask other-end [if color = gray [set color turquoise]]
            ]
          ]
        ]
      ]
    ]
    ; if both ends of a discovery relation are discovered
    ; by research, the relation is discovered as well
    if color != gray [
      ask my-out-discoveries with [color = gray][
        if [not member? color [gray turquoise]] of other-end [
          set color cyan
        ]
      ]
    ]
  ]
end





; once an argument is fully researched all its relations to other arguments
; are discovered as well therefore this procedure makes sure that fully
; researched arguments have a fully discovered neighborhood
to full-discovery
  ask startsargum with [full-research][
    let myx xcor
    let myy ycor
    if non-comm-scientists-here myx myy [

      ; once an argument is fully researched all its relations,
      ; attack and discovery, are discovered
      if any? out-discovery-neighbors with [color = gray or color = turquoise][
        ask out-discovery-neighbors with [color = gray or color = turquoise][
          set color lime
          ask my-in-discoveries [
            set color cyan
          ]
        ]
      ]

      ; note that in the case of a discovery via attack relation the other
      ; argument is not really discovered: it needs to be discovered by a
      ; discovery relation in the other theory to become lime
      if any? my-in-attacks with [color = gray][
        ask my-in-attacks with [color = gray][
          set color red
          ask other-end [if color = gray [set color turquoise]]
        ]
      ]
      if any? my-out-attacks with [color = gray][
        ask my-out-attacks with [color = gray][
          set color red
          ask other-end [if color = gray [set color turquoise]]
        ]
      ]
    ]
    set full-research false
  ]
end





; at the end of the time steps 1, 2, 3 and 4 communicating researchers
; decrease their communicating value by 1 which corresponds to them having used
; the day to digest the information they gained while communicating
to communication-regress
    ask researchers with [communicating > 0][
      set communicating communicating - 1
    ]
end

