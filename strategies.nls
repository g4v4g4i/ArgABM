; the procedures that are involved in
; calculating the best theory for an researcher
; to work on:
; 1. computing the arguments in the memory
;    that are not admissible
; 2. computing the best theory based on the
;    number of non-admissible arguments
; 3. procedure that lets researchers change
;    their current theory





; based on their memory researchers compute lists of attacked arguments
; with these lists the current best theory is computed
to compute-strategies-researchers

  ; researchers start with figuring out which argument in their
  ; memory are admissible and which are attacked
  compute-subjective-attacked

  ask researchers with [not rep-researcher][
    set cur-best-th []
    ; variables for the list that contains the number admissible arguments
    ; per theory and a sublist which contains only the numbers that are
    ; within the strategy-threshold
    let list-admissible-arguments []
    let threshold-admissible-arguments []

    ; create a list with the number of admissible arguments
    ; of each of the theories
    foreach current-theory-info [ [?1] ->
      set list-admissible-arguments lput item 1 ?1 list-admissible-arguments
    ]
    set list-admissible-arguments sort list-admissible-arguments

    ; a list of theories with values within the strategy threshold is constructed
    set threshold-admissible-arguments filter [ [?1] -> ?1 >=
      ((max list-admissible-arguments) * strategy-threshold) ]
        list-admissible-arguments
    set threshold-admissible-arguments sort threshold-admissible-arguments

    ; computation of the current best theory
    ; theories with a number of admissible arguments that are
    ; within the threshold can be considered as current best theory
    foreach current-theory-info [ [?1] ->
      if member? item 1 ?1 threshold-admissible-arguments [
        set cur-best-th lput item 0 ?1 cur-best-th
      ]
    ]
  ]
end





; procedure that computes for each researcher which of the arguments in its memory
; are admissible (and hence which are attacked)
to compute-subjective-attacked
  ask researchers with [not rep-researcher][
    ; variables for lists that contain:
    ; the current-theory-info with 0 admissible arguments; an updated number
    ; of admissible arguments during the recursive computation; the arguments
    ; that are not admissible; the arguments that the researchers knows about; and
    ; the arguments that are attacked by the current theory
    let new-info []
    let new-cur-info []
    let not-admissible []
    let args-cur-arguments []
    let attacked-by-me []

    ; create a list of only the attacks
    let attack-relations []
    foreach subjective-relations [ [?1] ->
      if first ?1 = "a" [
        set attack-relations lput ?1 attack-relations
      ]
    ]
    ; create lists of attacked and attacking arguments
    let cur-attacked []
    let cur-attacker []
    foreach attack-relations [ [?1] ->
      set cur-attacked lput last ?1 cur-attacked
      set cur-attacker lput first but-first ?1 cur-attacker
    ]

    ; create a list of the arguments the researchers knows about and
    ; set the number of admissible arguments for each theory to 0
    foreach subjective-arguments [ [?1] ->
      set args-cur-arguments lput first ?1 args-cur-arguments
    ]
    foreach current-theory-info [ [?1] ->
      set new-info lput replace-item 1 ?1 0 new-info
    ]
    set current-theory-info new-info

    ; the computation of the admissible arguments is done recursively
    ; a list of arguments that are currently considered attacked
    let open-rec []
    ; variable that lets the loop run at least one time
    let i 0
    foreach current-theory-info [ [?1] ->
      ; the theory that is considered in this loop
      ; and the root of that theory (the start)
      let cur-theory ?1
      let askstart item 0 cur-theory
      while [ i < 1 or not empty? open-rec][
        set not-admissible sentence not-admissible open-rec
        set open-rec []
        set attacked-by-me []

        ; create a list of arguments that are attacked by the current theory
        ; based on the memory of the current researcher
        if not empty? attack-relations [
          ask turtles with [member? self args-cur-arguments and
	        mytheory = askstart][
            if member? self cur-attacker and not member? self not-admissible [
              ; the argument considered and a list of arguments
              ; attacked by that argument
              let cur-turtle self
              let my-attacked []
              foreach attack-relations [ [??1] ->
                if first but-first ??1 = cur-turtle [
                  set my-attacked lput last ??1 my-attacked
                ]
              ]
              set attacked-by-me sentence my-attacked attacked-by-me
            ]
          ]

          ; arguments that are attacked by arguments from another theory that are
          ; not attacked by non-attacked arguments from the current theory
          ; are added to the open-rec list, the list of attacked-arguments
          ask turtles with [member? self args-cur-arguments and
	          mytheory = askstart and not member? self not-admissible and
	          member? self cur-attacked][
          let cur-turtle self
          foreach attack-relations [ [??1] ->
            if last ??1 = cur-turtle [
              if not member? last but-last ??1 attacked-by-me [
                set open-rec lput cur-turtle open-rec
              ]
            ]
          ]
            ]
        ]
        set i i + 1
      ]
      set i 0

      ; for the update of the information in current-theory-info
      set new-cur-info lput replace-item 1 cur-theory (count turtles with
        [member? self args-cur-arguments and mytheory = askstart] -
	      count turtles with [member? self not-admissible and mytheory = askstart])
	        new-cur-info
    ]

    ; arguments that are part of the not-admissible list
    ; are not part of the admissible subjective arguments and hence removed
    set admissible-subj-argu subjective-arguments
    foreach subjective-arguments [ [?1] ->
      let cur-argu ?1
      if member? first cur-argu not-admissible [
        set admissible-subj-argu remove cur-argu admissible-subj-argu
      ]
    ]
    ; update the current-theory-info
    set current-theory-info new-cur-info
  ]
end





; procedure that lets the researchers act on the just computed best theory
; based on their own memory
to act-on-strategy-researchers
  ask researchers with [not rep-researcher][
    ; only when there is a current best theory
    ; it makes sense for the researchers to want to work on that theory
    if not empty? cur-best-th and not member? nobody cur-best-th [
      let myx xcor
      let myy ycor

      ; if the researcher is not currently working on the best theory
      ; it considers jumping
      foreach subjective-arguments [ [?1] ->
        if [xcor] of item 0 ?1 = myx and [ycor] of item 0 ?1 = myy and
        not member? [mytheory] of item 0 ?1 cur-best-th [
          set theory-jump theory-jump + 1
        ]
      ]

      ; if the researcher has considered jumping jump-threshold times
      ; it jumps to one of the theories it considers best, based
      ; on its memory and the computations
      if theory-jump >= jump-threshold [
        let ch-best one-of cur-best-th
        let subj-argus []
        foreach subjective-arguments [ [?1] ->
          set subj-argus lput item 0 ?1 subj-argus
        ]

        ; if one of the arguments from the best theory is in its memory
        ; the researcher will jump there
        ifelse any? turtles with [(breed = starts or breed = arguments) and
	        member? self subj-argus and mytheory = ch-best and color != turquoise][
            move-to one-of turtles with [(breed = starts or breed = arguments) and
              member? self subj-argus and mytheory = ch-best and color != turquoise]
          ][ ; otherwise the researcher jumps to the root of the theory
          move-to ch-best
          ]

        set times-jumped times-jumped + 1
        set theory-jump 0
      ]
    ]
  ]
end

