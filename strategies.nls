; the procedures that are involved in
; calculating the best theory for an researcher
; to work on:
; 1. computing the arguments in the memory
;    that are not admissible
; 2. computing the best theory based on the
;    number of non-admissible arguments
; 3. procedure that lets researchers change
;    their current theory





; the core of the admissibility calculation procedure. It takes a link-set
; (attackset) for a certain theory (i.e. all attacks which are either
; outgoing or incoming to this theoy) as input and reports the arguments
; which are successfully attacked i.e. non-admissible as a turtle-set
; processed? is a boolean dummy variable which marks attacks which have
; sucessfully attacked during the secondary-attackers phase. The details
; are described in the infotab under admissibility-calc-core.
to-report admissibility-calc-core [attackset]
  ; cf infotab 1)
  let prime-attackers attackset with [uncontested]
  let sucattacked (turtle-set [end2] of prime-attackers)
  ; cf infotab 2)
  let secondary-attackers attackset with [
    not uncontested and not member? end1 sucattacked] 
  let another-loop? true
  while [another-loop? and any? secondary-attackers] [
    let sucattacked-cache no-turtles
    set another-loop? false
    ask secondary-attackers [
      set processed? false
      if not [any? my-in-attacks with [
        member? self secondary-attackers]] of end1  [
        set another-loop? true
        set sucattacked-cache (turtle-set sucattacked-cache end2)
        set processed? true
      ]     
    ]   
    ; cf infotab 3)
    set sucattacked (turtle-set sucattacked sucattacked-cache)
    if another-loop? [
      set secondary-attackers secondary-attackers with [
        not processed? and not member? end1 sucattacked-cache]
    ]
  ]
  report sucattacked
end





; procedure that computes for each collaborator network (= groups)
; which of the arguments in their memory are admissible/defensible
; because researcher in a collaborator network share all information with each
; other only one agent needs to do the defensibility calculations 
; (the calc-researcher) and the others (except for the rep-researcher) can just
; copy the results from her.  The details are described in the infotab under
; compute-subjective-attacked.
to compute-subjective-attacked
  foreach colla-networks [ [cur-group] ->
    let calc-done false
    let calc-researcher 0
    foreach cur-group [ [cur-researcher] ->
      if not [rep-researcher] of cur-researcher [
       ; cf infotab 1.
        ifelse calc-done [
          ask cur-researcher [
            set current-theory-info [current-theory-info] of calc-researcher
            set non-admiss-subj-argu [non-admiss-subj-argu] of calc-researcher
            set cur-best-th [cur-best-th] of calc-researcher
          ]
        ][
         ; cf infotab 2.
          set calc-done true
          set calc-researcher cur-researcher
          let sorted-starts sort starts
          ask cur-researcher [
            ; will contain the number of non-admiss-argu for each theory
            ; format: list e.g. [10 5 30] (first theory has 10 non-admiss-argu)
            let #non-admiss-argu-th []
            ; will contain a turtle-set of all the non-admissible-arguments
            set non-admiss-subj-argu no-turtles
           ; cf infotab 3.
            ifelse length sorted-starts = 2 [
              set non-admiss-subj-argu admissibility-calc-core
                subjective-relations
              let #non-admiss-argu-th2 count non-admiss-subj-argu with [
                mytheory = item 1 sorted-starts]
              let #non-admiss-argu-th1 (count non-admiss-subj-argu
                - #non-admiss-argu-th2)
              set #non-admiss-argu-th (list #non-admiss-argu-th1
                #non-admiss-argu-th2)
             ; cf infotab 4.
            ][
              foreach sorted-starts [[curtheory] ->   
                let to-add-non-admiss-argu admissibility-calc-core
                subjective-relations with [mytheory-end1 = curtheory
                  or mytheory-end2 = curtheory]
                set #non-admiss-argu-th lput count to-add-non-admiss-argu
                  with [mytheory = curtheory] #non-admiss-argu-th
                set non-admiss-subj-argu (turtle-set non-admiss-subj-argu
                to-add-non-admiss-argu)
              ]
            ]
            set-current-theory-info #non-admiss-argu-th
            compute-strategies
          ]
        ]
      ]
    ]
  ]
end





to-report replace-subitem [index1 index2 lists value]
  let old-sublist item index1 lists
  report replace-item index1 lists (replace-item index2 old-sublist value)
end





; the current-theory-info will be updated with the freshly calculated
; admissibility values; format: list e.g. 
;[[(start 0) 45] [(start 85) 40] [(start 170) 22]] = the first theory has 45
; admissible arguments etc.
to set-current-theory-info [#non-admiss-argu-th]
  let i 0
  foreach current-theory-info [[curitem] ->
    let curtheory item 0 curitem
    let number-adm-argu (count subjective-arguments with [mytheory = curtheory]
      - item i #non-admiss-argu-th)
    set current-theory-info replace-subitem i 1 current-theory-info
    number-adm-argu
    set i i + 1
  ]
end





; based on their memory researchers compute lists of attacked arguments
; with these lists the current best theory is computed
to compute-strategies
  set cur-best-th []
  ; variables for the list that contains the number admissible arguments
  ; per theory and a sublist which contains only the numbers that are
  ; within the strategy-threshold
  let list-admissible-arguments []
  let threshold-admissible-arguments []

  ; create a list with the number of admissible arguments
  ; of each of the theories
  foreach current-theory-info [ [?1] ->
    set list-admissible-arguments lput item 1 ?1 list-admissible-arguments
  ]
  set list-admissible-arguments sort list-admissible-arguments

  ; a list of theories with values within the strategy threshold is
  ; constructed
  set threshold-admissible-arguments filter [ [?1] -> ?1 >=
    ((max list-admissible-arguments) * strategy-threshold) ]
      list-admissible-arguments
  set threshold-admissible-arguments sort threshold-admissible-arguments

  ; computation of the current best theories
  ; theories with a number of defensible arguments that are
  ; within the threshold of the theory with the most defensible arguments
  ; are considered as current best theories
  foreach current-theory-info [ [?1] ->
    if member? item 1 ?1 threshold-admissible-arguments [
      set cur-best-th lput item 0 ?1 cur-best-th
    ]
  ]  
end





; procedure that lets the researchers act on the just computed best theory
; based on their own memory
to act-on-strategies
  ask researchers with [not rep-researcher] [
    ; only when there is a current best theory
    ; it makes sense for the researchers to want to work on that theory
    if not empty? cur-best-th and not member? nobody cur-best-th [
      let myargu mygps
      ; if the researcher is not currently working on the best theory
      ; she considers jumping      
      if not member? [mytheory] of myargu cur-best-th [
        set theory-jump theory-jump + 1
      ]
      ; if the researcher has considered jumping jump-threshold times
      ; she jumps to one of the theories she considers best, based
      ; on her memory and the computations
      if theory-jump >= jump-threshold [
        let ch-best one-of cur-best-th        
        ; if one of the arguments from the best theory is in her memory
        ; the researcher will jump there
        let nextargu one-of subjective-arguments with [
          mytheory = ch-best 
          and color != turquoise]
        ifelse nextargu != nobody [
          move-to-nextargu nextargu
        ][ ; otherwise the researcher jumps to the root of the theory
          move-to-nextargu ch-best
        ]

        set times-jumped times-jumped + 1
        set theory-jump 0
      ]
    ]
  ]
end


