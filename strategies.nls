; the procedures that are involved in
; calculating the best theory for an researcher
; to work on:
; 1. computing the arguments in the memory
;    that are not admissible
; 2. computing the best theory based on the
;    number of non-admissible arguments
; 3. procedure that lets researchers change
;    their current theory





; The core of the admissibility calculation procedure. It takes a link-set
; (attackset) for a certain theory (i.e. all attacks which are either
; outgoing or incoming to this theory) as input and reports the arguments
; which are successfully attacked i.e. non-admissible as a turtle-set
; processed? is a boolean dummy variable which marks attacks which have
; successfully attacked during the secondary-attackers phase
to-report admissibility-calc-core [attackset]
  ; take the attacks which are themselves uncontested in  the objective 
  ; landscape. The destination of this attacks will be non-admissible and 
  ; attacks coming from there are void.
  let prime-attackers attackset with [uncontested]
  let sucattacked (turtle-set [end2] of prime-attackers)
  ; the attacks which are not uncontested but also were not rendered void by
  ; the prime attackers form the secondary-attackers link-set. If they don't
  ; have any incoming attack from the secondary-attackers themselves their
  ; attack is successful and therefore they set their `processed?` variable to 
  ; `true`
  let secondary-attackers attackset with [
    not uncontested and not member? end1 sucattacked] 
  let another-loop? true
  while [another-loop? and any? secondary-attackers] [
    let sucattacked-cache no-turtles
    set another-loop? false
    ask secondary-attackers [
      set processed? false
      if not [any? my-in-attacks with [
        member? self secondary-attackers]] of end1  [
        set another-loop? true
        set sucattacked-cache (turtle-set sucattacked-cache end2)
        set processed? true
      ]     
    ]   
    ; Of those secondary-attackers which were successful, the destination
    ; (= end2) gets added to the non-admissible turtle-set and attacks
    ; starting from there are rendered void and are therefore removed from
    ; the set. Then the successful secondary attacks themselves are removed.
    ; This repeats until there are no secondary-attackers left or none of the
    ; left ones is able to attack successfully anymore.
    set sucattacked (turtle-set sucattacked sucattacked-cache)
    if another-loop? [
      set secondary-attackers secondary-attackers with [
        not processed? and not member? end1 sucattacked-cache]
    ]
  ]
  report sucattacked
end





; procedure that computes for each collaborator network (= groups)
; which of the arguments in their memory are admissible
; because researcher in a collaborator network share all information with each
; other only one agent needs to do the admissibility calculations 
; (the calc-researcher) and the others can just
; copy the results from her.
to compute-subjective-attacked
  foreach colla-networks [ [cur-group] ->
    let calc-done false
    let calc-researcher 0
    foreach cur-group [ [cur-researcher] ->
      ; if a researcher of the group already calculated admissibility other 
      ; group members can copy the results into their memory
      ifelse calc-done [
        ask cur-researcher [
          set current-theory-info [current-theory-info] of calc-researcher
          set non-admiss-subj-argu [non-admiss-subj-argu] of calc-researcher
          set cur-best-th [cur-best-th] of calc-researcher
        ]
      ][
        ; if no group member has done the admissibility calculations, the 
        ; current researcher does the calculations i.e. she becomes the 
        ; groups calc-researcher
        set calc-done true
        set calc-researcher cur-researcher
        let sorted-starts sort starts
        ask cur-researcher [
          ; will contain the number of non-admiss-argu for each theory
          ; format: list e.g. [10 5 30] (first theory has 10 non-admiss-argu)
          let #non-admiss-argu-th []
          ; will contain a turtle-set of all the non-admissible-arguments
          set non-admiss-subj-argu no-turtles
          ; if there are only two theories the admissibility calculation can 
          ; be  done on the whole attackset at once
          ifelse length sorted-starts = 2 [
            set non-admiss-subj-argu admissibility-calc-core
            subjective-relations
            let #non-admiss-argu-th2 count non-admiss-subj-argu with [
              mytheory = item 1 sorted-starts]
            let #non-admiss-argu-th1 (count non-admiss-subj-argu
              - #non-admiss-argu-th2)
            set #non-admiss-argu-th (list #non-admiss-argu-th1
              #non-admiss-argu-th2)
            ; if there are more than two theories the calculation has to be 
            ; done once for each attack set of a theory separately. A attack 
            ; set of a theory corresponds to all the attacks in the set which 
            ; are either incoming or outgoing to/from this theory
          ][
            foreach sorted-starts [[curtheory] ->   
              let to-add-non-admiss-argu admissibility-calc-core
              subjective-relations with [mytheory-end1 = curtheory
                or mytheory-end2 = curtheory]
              set #non-admiss-argu-th lput count to-add-non-admiss-argu
              with [mytheory = curtheory] #non-admiss-argu-th
              set non-admiss-subj-argu (turtle-set non-admiss-subj-argu
                to-add-non-admiss-argu)
            ]
          ]
          set-current-theory-info #non-admiss-argu-th
          compute-strategies
        ]
      ]
    ]
  ]
end





to-report replace-subitem [index1 index2 lists value]
  let old-sublist item index1 lists
  report replace-item index1 lists (replace-item index2 old-sublist value)
end





; the current-theory-info will be updated with the freshly calculated
; admissibility values; format: list e.g. 
;[[(start 0) 45] [(start 85) 40] [(start 170) 22]] = the first theory has 45
; admissible arguments etc.
to set-current-theory-info [#non-admiss-argu-th]
  let i 0
  foreach current-theory-info [[curitem] ->
    let curtheory item 0 curitem
    let number-adm-argu (count subjective-arguments with [mytheory = curtheory]
      - item i #non-admiss-argu-th)
    set current-theory-info replace-subitem i 1 current-theory-info
    number-adm-argu
    set i i + 1
  ]
end





; based on their memory researchers compute lists of attacked arguments
; with these lists the current best theory is computed
to compute-strategies
  set cur-best-th []
  ; variables for the list that contains the number admissible arguments
  ; per theory and a sublist which contains only the numbers that are
  ; within the strategy-threshold
  let list-admissible-arguments []
  let threshold-admissible-arguments []

  ; create a list with the number of admissible arguments
  ; of each of the theories
  foreach current-theory-info [ [?1] ->
    set list-admissible-arguments lput item 1 ?1 list-admissible-arguments
  ]
  set list-admissible-arguments sort list-admissible-arguments

  ; a list of theories with values within the strategy threshold is
  ; constructed
  set threshold-admissible-arguments filter [ [?1] -> ?1 >=
    ((max list-admissible-arguments) * strategy-threshold) ]
      list-admissible-arguments
  set threshold-admissible-arguments sort threshold-admissible-arguments

  ; computation of the current best theories
  ; theories with a number of admissible arguments that are
  ; within the threshold of the theory with the most admissible arguments
  ; are considered as current best theories
  foreach current-theory-info [ [?1] ->
    if member? item 1 ?1 threshold-admissible-arguments [
      set cur-best-th lput item 0 ?1 cur-best-th
    ]
  ]  
end





; procedure that lets the researchers act on the just computed best theory
; based on their own memory
to act-on-strategies
  ask researchers [
    ; only when there is a current best theory
    ; it makes sense for the researchers to want to work on that theory
    if not empty? cur-best-th and not member? nobody cur-best-th [
      let myargu mygps
      ; if the researcher is not currently working on the best theory
      ; she considers jumping      
      if not member? [mytheory] of myargu cur-best-th [
        set theory-jump theory-jump + 1
      ]
      ; if the researcher has considered jumping jump-threshold times
      ; she jumps to one of the theories she considers best, based
      ; on her memory and the computations
      if theory-jump >= jump-threshold [
        let ch-best one-of cur-best-th        
        ; if one of the arguments from the best theory is in her memory
        ; the researcher will jump there
        let nextargu one-of subjective-arguments with [
          mytheory = ch-best 
          and color != turquoise]
        ifelse nextargu != nobody [
          move-to-nextargu nextargu
        ][ ; otherwise the researcher jumps to the root of the theory
          move-to-nextargu ch-best
        ]

        set times-jumped times-jumped + 1
        set theory-jump 0
      ]
    ]
  ]
end


