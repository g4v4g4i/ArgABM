; the procedures that are involved in
; calculating the best theory for an researcher
; to work on:
; 1. computing the arguments in the memory
;    that are not admissible
; 2. computing the best theory based on the
;    number of non-admissible arguments
; 3. procedure that lets researchers change
;    their current theory





; based on their memory researchers compute lists of attacked arguments
; with these lists the current best theory is computed
to compute-strategies
  ask researchers with [not rep-researcher][
    set cur-best-th []
    ; variables for the list that contains the number admissible arguments
    ; per theory and a sublist which contains only the numbers that are
    ; within the strategy-threshold
    let list-admissible-arguments []
    let threshold-admissible-arguments []

    ; create a list with the number of admissible arguments
    ; of each of the theories
    foreach current-theory-info [ [?1] ->
      set list-admissible-arguments lput item 1 ?1 list-admissible-arguments
    ]
    set list-admissible-arguments sort list-admissible-arguments

    ; a list of theories with values within the strategy threshold is
    ; constructed
    set threshold-admissible-arguments filter [ [?1] -> ?1 >=
      ((max list-admissible-arguments) * strategy-threshold) ]
        list-admissible-arguments
    set threshold-admissible-arguments sort threshold-admissible-arguments

    ; computation of the current best theories
    ; theories with a number of defensible arguments that are
    ; within the threshold of the theory with the most defensible arguments
    ; are considered as current best theories
    foreach current-theory-info [ [?1] ->
      if member? item 1 ?1 threshold-admissible-arguments [
        set cur-best-th lput item 0 ?1 cur-best-th
      ]
    ]
  ]
end





; procedure that computes for each collaborator network (= groups)
; which of the arguments in their memory are admissible/defensible
; because researcher in a collaborator network share all information with each
; other only one agent needs to do the defensibility calculations 
; (the calc-researcher) and the others (except for the rep-researcher) can just
; copy the results from her
to compute-subjective-attacked
  foreach colla-networks [ [?1] ->
    let calc-done false
    let calc-researcher []
    let cur-group ?1
    foreach cur-group [ [??1] ->
      let cur-researcher ??1
      if not [rep-researcher] of cur-researcher [
        ; if a researcher of the group already calculated defensibility other
        ; group members can copy the results into their memory
        ifelse calc-done [
          ask cur-researcher [
            set admissible-subj-argu [admissible-subj-argu] of calc-researcher
            set current-theory-info [current-theory-info] of calc-researcher
            set non-admiss-subj-argu [non-admiss-subj-argu] of calc-researcher
          ]
        ][
          ; if no group member has done the defensibility calculations, the
          ; current researcher does the calculations i.e. she becomes the
          ; groups calc-researcher
          set calc-done true
          set calc-researcher cur-researcher
          ask cur-researcher [
            ; variables for lists that contain:
            ; the current-theory-info with 0 admissible arguments
            ; an updated number of admissible arguments during the recursive
            ; computation 
            ; the arguments that are not admissible
            ; the arguments that the researchers knows about
            ; and the arguments that are attacked by the current theory
            let new-info []
            let new-cur-info []
            let not-admissible []
            let args-cur-arguments []
            let args-cur-arguments-as 0
            let attacked-by-me []

            ; create a list of only the attacks
            let attack-relations []
            foreach subjective-relations [ [???1] ->
              if first ???1 = "a" [
                set attack-relations lput ???1 attack-relations
              ]
             ]
            ; create lists of attacked and attacking arguments
            let cur-attacked []
            let cur-attacker []
            foreach attack-relations [ [???1] ->
              set cur-attacked lput last ???1 cur-attacked
              set cur-attacker lput first but-first ???1 cur-attacker
             ]

            ; create a list of the arguments the researchers knows about and
            ; set the number of admissible arguments for each theory to 0
            foreach subjective-arguments [ [???1] ->
              set args-cur-arguments lput first ???1 args-cur-arguments
            ]
            ; create an agentset which contains all subjective-arguments
            set args-cur-arguments-as startsargum with [member? self
            args-cur-arguments]
            foreach current-theory-info [ [???1] ->
              set new-info lput replace-item 1 ???1 0 new-info
            ]
            set current-theory-info new-info

            ; the computation of the admissible arguments is done recursively
            ; a list of arguments that are currently consideredto be attacked
            let open-rec []
            ; variable that lets the loop run at least one time
            let i 0
            foreach current-theory-info [ [???1] ->
              ; the theory that is considered in this loop
              ; and the root of that theory (the start)
              let cur-theory ???1
              let askstart item 0 cur-theory
              while [ i < 1 or not empty? open-rec][
                set not-admissible sentence not-admissible open-rec
                set open-rec []
                set attacked-by-me []

                ; create a list of arguments that are attacked by the current
                ; theory based on the memory of the current researcher
                if not empty? attack-relations [
                  ask args-cur-arguments-as with [mytheory = askstart][
                    if member? self cur-attacker and not member? self
                    not-admissible [
                      ; the argument considered and a list of arguments
                      ; attacked by that argument
                      let cur-turtle self
                      let my-attacked []
                      foreach attack-relations [ [????1] ->
                        if item 1 ????1 = cur-turtle [
                          set my-attacked lput last ????1 my-attacked
                        ]
                      ]
                      set attacked-by-me sentence my-attacked attacked-by-me
                    ]
                  ]

                  ; arguments that are attacked by arguments from another
                  ; theory that are not attacked by non-attacked arguments
                  ; from the current theory are added to the open-rec list:
                  ; the list of attacked-arguments
                  ask args-cur-arguments-as with [mytheory = askstart and
                    not member? self not-admissible and
                    member? self cur-attacked][
                    let cur-turtle self
                    foreach attack-relations [ [????1] ->
                      if last ????1 = cur-turtle [
                        if not member? item 1 ????1 attacked-by-me [
                          set open-rec lput cur-turtle open-rec
                        ]
                      ]
                    ]
                  ]
                ]
                set i i + 1
              ]
              set i 0

              ; update of the information in current-theory-info
              set new-cur-info lput replace-item 1 cur-theory (count
                args-cur-arguments-as with [mytheory = askstart] -
                count args-cur-arguments-as with 
                [member? self not-admissible and mytheory = askstart])
                  new-cur-info
            ]

            ; arguments that are part of the not-admissible list
            ; are not part of the admissible subjective arguments and hence
            ; removed
            ; this non-admissible arguments are written into the
            ; researcher owned variable non-admiss-subj-argu which will only
            ; contain these arguments as a list without their respective colors
            set admissible-subj-argu subjective-arguments
            set non-admiss-subj-argu []
            foreach subjective-arguments [ [???1] ->
              let cur-argu ???1
              if member? first cur-argu not-admissible [
                set admissible-subj-argu remove cur-argu admissible-subj-argu
                set non-admiss-subj-argu lput item 0 cur-argu
                non-admiss-subj-argu
              ]
            ]
            ; update the current-theory-info
            set current-theory-info new-cur-info
          ]
        ]
      ]
    ]
  ]
end




; procedure that lets the researchers act on the just computed best theory
; based on their own memory
to act-on-strategies
  ask researchers with [not rep-researcher][
    ; only when there is a current best theory
    ; it makes sense for the researchers to want to work on that theory
    if not empty? cur-best-th and not member? nobody cur-best-th [
      let myargu gps
      ; let myx xcor
      ; let myy ycor

      ; if the researcher is not currently working on the best theory
      ; it considers jumping
      foreach subjective-arguments [ [?1] ->
        let cur-subj-argu item 0 ?1
        if cur-subj-argu = myargu and not member? [mytheory] of cur-subj-argu
        cur-best-th [
          set theory-jump theory-jump + 1
        ]        
      ]

      ; if the researcher has considered jumping jump-threshold times
      ; it jumps to one of the theories it considers best, based
      ; on its memory and the computations
      if theory-jump >= jump-threshold [
        let ch-best one-of cur-best-th
        let subj-argus []
        foreach subjective-arguments [ [?1] ->
          set subj-argus lput item 0 ?1 subj-argus
        ]

        ; if one of the arguments from the best theory is in its memory
        ; the researcher will jump there
        ifelse any? startsargum with [
          member? self subj-argus and mytheory = ch-best 
          and color != turquoise][
            move-to one-of startsargum with [
              member? self subj-argus and mytheory = ch-best 
              and color != turquoise]
          ][ ; otherwise the researcher jumps to the root of the theory
          move-to ch-best
          ]

        set times-jumped times-jumped + 1
        set theory-jump 0
      ]
    ]
  ]
end

