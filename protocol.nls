; holds the reporters and procedures needed for the behaviorspace runs





; if `necessary-convergence` is selected in the interface and at least one 
; theory is fully red this procedure determines which situation the run is in: 
; case 1: some scientists are on non-red theories or case 2: all scientists are 
; on red theories
to exit-case-distinction
  ifelse sum [myscientists] of g-red-theories = scientists [
    set g-exit-case 2
  ][
    set g-exit-case 1
  ]
end





; the exit-condition determines when a given run is considered to be finished. 
; In case `necessary-convergence` is selected in the interface a run is 
; finished as soon as all researchers converge on the best theory. Otherwise a 
; run is finished as soon as there exists one theory which is fully discovered 
; (i.e. has only red arguments). In any case a run will be aborted when it 
; hits the global time limit. A run will also be immediately terminated if 
; `necessary-convergence` is selected and there is more than one theory with 
; maximal admissibility. These runs must then be filtered from the dataset.
to-report exit-condition
  if ticks >= g-max-ticks [
    final-commands
    report true
  ]
  ifelse necessary-convergence [
    if (g-exit-case > 0 and [myscientists] of (start 0) = scientists) or 
      (count starts with-max [objective-admissibility] > 1) [
      report true
    ]
  ][
    if any? g-red-theories [
      final-commands
      report true
    ]
  ]
  report false
end





; as soon as a run is finished (cf. exit-condition) researchers can one final 
; time jump to a best theory (ignoring the `jump-threshold`) if 
; theyâ€™re not already on a theory they consider best. To determine what their 
; final best theories are, they do a final update of their memory, share with 
; their group and do an admissibility calculation.
to final-commands
  ask researchers [update-memories]
  share-with-group
  compute-subjective-attacked
  ask researchers with [not member? [mytheory] of mygps cur-best-th][
     move-to-nextargu one-of cur-best-th
     set times-jumped times-jumped + 1
  ]
  compute-popularity true
  if knowledge-tracking [
    with-local-randomness [save-tracked-knowledge]
  ]
end





to-report monist-success
  let popularity []
  let find-good-m 0
  ask starts [
    set popularity lput myscientists popularity
  ]
  ask start 0 [
    if max popularity = myscientists and max popularity = scientists [
      set find-good-m 1
    ]
  ]
  report find-good-m
end





to-report pluralist-success
  let popularity []
  let find-good-p 0
  ask starts [
    set popularity lput myscientists popularity
  ]
  ask start 0 [   
    if max popularity = myscientists [
      set find-good-p 1
    ]
  ]
  report find-good-p
end





to-report average-jumps
  let jumps 0
  let avgjumps 0
  ask researchers [
    set jumps times-jumped + jumps
  ]
  set avgjumps (jumps / scientists)
  report avgjumps
end





to-report perc-landscape-discoverd
  let tot-arguments count startsargum
  let disc-arguments count startsargum with [
    color != gray and color != turquoise]
  let perc-disc-argu ((disc-arguments / tot-arguments) * 100)
  report perc-disc-argu
end





to-report perc-best-th-discoverd
  let tot-best-arguments count startsargum with [mytheory = start 0]
  let disc-best-arguments count startsargum with [
    mytheory = start 0 and color != gray and color != turquoise]
  let perc-disc-best-argu ((disc-best-arguments / tot-best-arguments) * 100)
  report perc-disc-best-argu
end





to-report translate-from-string [string]
  let value-to-report 0
  if string = "th1" [
    report item 0 sort starts
  ]
  if string = "th2" [
    report item 1 sort starts
  ]
  if string = "th3" [
    if number-of-theories < 3 [
      report false
    ]
    report item 2 sort starts
  ]
end





; reports the objective admissibility of th#
to-report objective-admiss-of [th#]  
  set th# translate-from-string th#
  if th# = false [
    report 0
  ]
  report [objective-admissibility] of th#  
end





; reports time researchers spent on th#: 
; "monist" - cf. `research-time-monist`
; or time researchers considered theory th# to be a best theory:
; "pluralist" - cf. `research-time-pluralist`
to-report research-time [pluralist-monist th#]
  ifelse pluralist-monist = "monist" [
    set pluralist-monist [ -> research-time-monist]
  ][
    set pluralist-monist [ -> research-time-pluralist]
  ]
  set th# translate-from-string th#
  if th# = false [
    report 0
  ]
  report [runresult pluralist-monist] of th#
end





; reports the number of researchers on th# at the end of the run ("monist")
; or the number of scientists who consider th# to be a best theory ("pluralist")
; i.e. it reports the `myscientists`- ("monist") or the 
; `myscientists-pluralist`-value ("pluralist") (cf. Variables)
to-report run-end-scientists [pluralist-monist th#]
  ifelse pluralist-monist = "monist" [
    set pluralist-monist [ -> myscientists]
  ][
    set pluralist-monist [ -> myscientists-pluralist]
  ]
  set th# translate-from-string th#
  if th# = false [
    report 0
  ]
  report [runresult pluralist-monist] of th#
end





; This metric tracks how well researchers perform during a run as opposed to 
; 'at the  end' - and therefore also after - a run like the 
; `pluralist-/monist-success` metric does. It also takes the objective 
; admissibility of the landscape into account and is normalized to a [0,100] 
; interval where 100 corresponds to the best  performance. 
; For details cf. documentation
to-report in-run-performance [pluralist-monist]
  ifelse pluralist-monist = "monist" [
    set pluralist-monist [ -> research-time-monist]
  ][
    set pluralist-monist [ -> research-time-pluralist]
  ]
  let performance 0
  ask starts [
    set performance (performance 
      + runresult pluralist-monist * objective-admissibility)
  ]  
  set performance ((performance * 100) / (scientists * 
  (ticks + 1) * [objective-admissibility] of first sort starts))
  report performance
end





; reports how many scientists were on each theory at the start of the run
to-report run-start-scientists [th#]
  set th# translate-from-string th#
  if th# = false [
    report 0
  ]
  report [initial-scientists] of th#
end





; reports the percentage of arguments which are known to an average researcher.
; Either for the whole landscape (argument = "all") or for the best theory only
; (argument = "best")
to-report perc-subj-disc-argu [best-all]
  let tot-arguments 0
  ifelse best-all = "all" [
    set tot-arguments startsargum
  ][
    set tot-arguments startsargum with [mytheory = (start 0)]
  ]
  let #groups collaborative-groups
  let max-score count tot-arguments * #groups
  if max-score = 0 [
    report 100
  ]
  let realized-score 0
  ask tot-arguments [
   set realized-score realized-score + length filter [subj-color -> 
    subj-color < cyan] group-color-mem
  ]
  report realized-score / max-score * 100
end





; reports the percentage of attacks which are known to an average researcher.
; Either for the whole landscape (argument = "all") or from the best theory only
; (argument = "best")
to-report perc-subj-disc-attacks [best-all]
  let tot-attacks 0
  ifelse best-all = "all" [
    set tot-attacks attacks
  ][
    set tot-attacks attacks with [mytheory-end1 = (start 0)]
  ]
  let #groups collaborative-groups
  let max-score count tot-attacks * #groups
  if max-score = 0 [
    report 100
  ]
  let realized-score 0
  ask tot-attacks [
   set realized-score realized-score + length filter [subj-known -> 
    subj-known = true] in-group-i-memory
  ]
  report realized-score / max-score * 100
end





; reports the input value (communication costs) in the form: communication costs 
; in days per researcher
to-report normalize-days-per-scientist [input]
  let normalization-factor (1 / (scientists * max-learn))
  report input * normalization-factor
end






; reports the cumulative communication costs per researcher in days
to-report cum-com-costs
  report normalize-days-per-scientist g-cum-com-costs
end





; reports the maximal communication costs per researcher in days
; (argument = "value") or the round in which the maximal communication occurred
; (argument = "round")
to-report max-com-costs [round-value]
  ifelse round-value = "value"[
    report normalize-days-per-scientist item 0 g-max-com-costs
  ][
    report item 1 g-max-com-costs
  ]
end





; reports the unpaid communication costs per researcher in days
to-report unpaid-com-costs
  report normalize-days-per-scientist g-unpaid-com-costs
end





; This procedure draws a heatmap where the brightness of a patch is proportional
; to the proportion of researcher which know the arguments (and optionally 
; attacks) concerning this patch.
; This procedure is intended to be used for visualization purposes and is not 
; recommended in its current form for performance critical applications
; argument: including-attacks?, type: boolean
; whether or not knowledge about the attack relations connected to
; arguments on this patch is taken into account for drawing the heatmap
to heatmap [including-attacks?]
  let #groups collaborative-groups
  let sorted-starts sort starts
  ask patches with [any? turtles-here][
    let my-startsargum-attacks 0
    let #my-startsargum-attacks 0
    let my-startsargum (turtle-set arguments-here starts-here)
    if including-attacks? [
      set my-startsargum-attacks (link-set [my-attacks] of my-startsargum)
      set #my-startsargum-attacks count my-startsargum-attacks
    ]
    let #my-startsargum count my-startsargum
    ; In case of ties, the first theory among the tied ones is picked,
    ; in order to avoid border patches switching colors randomly
    let my-theory first sort modes [mytheory] of my-startsargum
    let max-score #groups * (#my-startsargum + #my-startsargum-attacks)
    let realized-score 0
    ask my-startsargum [
     set realized-score realized-score + length filter [subj-color -> 
      subj-color < cyan] group-color-mem
    ]
    if including-attacks? [
      ask my-startsargum-attacks [
        set realized-score realized-score + length filter [subj-known -> 
          subj-known = true] in-group-i-memory
      ]
    ]
    let my-color 0
    ifelse my-theory = item 0 sorted-starts [
      set my-color red
    ][
      ifelse my-theory = item 1 sorted-starts [
        set my-color turquoise
      ][
        set my-color green
      ]
    ]
    set pcolor scale-color my-color realized-score 0 max-score
  ]
end





; knowledge and belief tracking during the run . Called during 
; `set-current-theory-info`. Arguments: 
; #theory: which theory is currently processed (integer)
; #non-admiss-argu: number of non admissible arguments for the current theory 
; (integer)
; curtheory: the (start x) for the current theory (turtle)
to track-knowledge [#theory #non-admiss-argu curtheory]
  let cur-group-id group-id
  let known-args subjective-arguments with [mytheory = curtheory]
  let #known-args count known-args
  ; division by 10 to keep numbers compact as colors are multiple of 10
  let knowledge sum [(cyan - item cur-group-id group-color-mem) / 10] of 
    known-args
  let #defargs #known-args - #non-admiss-argu
  ; the +1 for #theory is for readability: so the first theory is named "1"
  let new-knowledge-entry (list (ticks + 1) cur-group-id (#theory + 1) #defargs 
    #known-args knowledge)
  set g-knowledge lput new-knowledge-entry g-knowledge
end





; saves the information tracked by `track-knowledge` during the run to a csv 
; file at the end of the run
to save-tracked-knowledge
  let sorted-admissibility map [start-x -> [objective-admissibility] of start-x]
    sort starts
  let random-start one-of starts
  let #args-per-th count startsargum with [mytheory = (random-start)]
  let filename behaviorspace-experiment-name
  set filename (word filename "-in-run-knowledge.csv")
  file-open filename
  foreach g-knowledge [curentry ->
    let cur-th-admiss item (item 2 curentry - 1) sorted-admissibility
    ; concatenating the lists this way was fastest in some quick profiling
    ; file-output takes ~5 times as long as concatenating itself 
    set curentry (sentence behaviorspace-run-number #args-per-th cur-th-admiss 
      curentry)
    file-print csv:to-row curentry 
  ]
  file-close
end
