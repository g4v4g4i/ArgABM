; holds the reporters and procedures needed for the behaviorspace runs





; the exit-condition determines when a given run is considered to be 
; finished. A run is over as soon as there exists one theory which is fully 
; discovered (i.e. has only red arguments). When this happens researchers can 
; one final time jump to a best theory (irrespective of their `theory-jump` 
; value) if they’re not already on a theory they consider best. This is 
; facilitated by the `final-commands` procedure which is called as soon as  
; `exit-condition` reports `true` and therefore ends the run.
to-report exit-condition
  let stop? []
  ask starts [
    let curstart self
    ifelse (any? startsargum with [mytheory = curstart and color != red]) [
      set stop? lput false stop?
    ][
      set stop? lput true stop?
    ]
  ]
  ifelse member? true stop? [
    final-commands
    report true
  ][
    report false
  ]
end





; as soon as a run is finished (cf. exit-condition) researchers can one final 
; time jump to a best theory (irrespective of their `theory-jump` value) if 
; they’re not already on a theory they consider best. To determine what their 
; final best theories are, they do a final update of their memory, share with 
; their group and do an admissibility calculation.
to final-commands
  ask researchers [update-memories]
  share-with-group
  compute-subjective-attacked
  ask researchers with [not member? [mytheory] of mygps cur-best-th][
     move-to-nextargu one-of cur-best-th
     set times-jumped times-jumped + 1
  ]
  compute-popularity true
end





to-report monist-success
  let popularity []
  let find-good-m 0
  ask starts [
    set popularity lput myscientists popularity
  ]
  ask start 0 [
    if max popularity = myscientists and max popularity = scientists [
      set find-good-m 1
    ]
  ]
  report find-good-m
end





to-report pluralist-success
  let popularity []
  let find-good-p 0
  ask starts [
    set popularity lput myscientists popularity
  ]
  ask start 0 [   
    if max popularity = myscientists [
      set find-good-p 1
    ]
  ]
  report find-good-p
end





to-report average-jumps
  let jumps 0
  let avgjumps 0
  ask researchers [
    set jumps times-jumped + jumps
  ]
  set avgjumps (jumps / scientists)
  report avgjumps
end





to-report perc-landscape-discoverd
  let tot-arguments count startsargum
  let disc-arguments count startsargum with [
    color != gray and color != turquoise]
  let perc-disc-argu ((disc-arguments / tot-arguments) * 100)
  report perc-disc-argu
end





to-report perc-best-th-discoverd
  let tot-best-arguments count startsargum with [mytheory = start 0]
  let disc-best-arguments count startsargum with [
    mytheory = start 0 and color != gray and color != turquoise]
  let perc-disc-best-argu ((disc-best-arguments / tot-best-arguments) * 100)
  report perc-disc-best-argu
end





to-report translate-from-string [string]
  let value-to-report 0
  if string = "th1" [
    report item 0 sort starts
  ]
  if string = "th2" [
    report item 1 sort starts
  ]
  if string = "th3" [
    if number-of-theories < 3 [
      report false
    ]
    report item 2 sort starts
  ]
end





; reports the objective admissibility of th#
to-report objective-admiss-of [th#]  
  set th# translate-from-string th#
  if th# = false [
    report 0
  ]
  report [objective-admissibility] of th#  
end





; reports time researchers spent on th#: 
; "monist" - cf. `research-time-monist`
; or time researchers considered theory th# to be a best theory:
; "pluralist" - cf. `research-time-pluralist`
to-report research-time [pluralist-monist th#]
  ifelse pluralist-monist = "monist" [
    set pluralist-monist [ -> research-time-monist]
  ][
    set pluralist-monist [ -> research-time-pluralist]
  ]
  set th# translate-from-string th#
  if th# = false [
    report 0
  ]
  report [runresult pluralist-monist] of th#
end





; reports the number of researchers on th# at the end of the run ("monist")
; or the number of scientists who consider th# to be a best theory ("pluralist")
; i.e. it reports the `myscientists`- ("monist") or the 
; `myscientists-pluralist`-value ("pluralist") (cf. Variables)
to-report run-end-scientists [pluralist-monist th#]
  ifelse pluralist-monist = "monist" [
    set pluralist-monist [ -> myscientists]
  ][
    set pluralist-monist [ -> myscientists-pluralist]
  ]
  set th# translate-from-string th#
  if th# = false [
    report 0
  ]
  report [runresult pluralist-monist] of th#
end





; This metric tracks how well researchers perform during a run as opposed to 
; 'at the  end' - and therefore also after - a run like the 
; `pluralist-/monist-success` metric does. It also takes the objective 
; admissibility of the landscape into account and is normalized to a [0,100] 
; interval where 100 corresponds to the best  performance. 
; For details cf. documentation
to-report in-run-performance [pluralist-monist]
  ifelse pluralist-monist = "monist" [
    set pluralist-monist [ -> research-time-monist]
  ][
    set pluralist-monist [ -> research-time-pluralist]
  ]
  let performance 0
  ask starts [
    set performance (performance 
      + runresult pluralist-monist * objective-admissibility)
  ]  
  set performance ((performance * 100) / (scientists * 
  (ticks + 1) * [objective-admissibility] of first sort starts))
  report performance
end





; reports how many scientists were on each theory at the start of the run
to-report run-start-scientists [th#]
  set th# translate-from-string th#
  if th# = false [
    report 0
  ]
  report [initial-scientists] of th#
end





; reports the percentage of arguments which are known to an average researcher.
; Either for the whole landscape (argument = "all") or for the best theory only
; (argument = "best")
to-report perc-subj-disc-argu [best-all]
  let tot-arguments 0
  ifelse best-all = "all" [
    set tot-arguments startsargum
  ][
    set tot-arguments startsargum with [mytheory = (start 0)]
  ]
  let #groups scientists / 5
  let max-score count tot-arguments * #groups
  let realized-score 0
  ask tot-arguments [
   set realized-score realized-score + length filter [subj-color -> 
    subj-color < cyan] group-color-mem
  ]
  report realized-score / max-score * 100
end





; reports the percentage of attacks which are known to an average researcher.
; Either for the whole landscape (argument = "all") or from the best theory only
; (argument = "best")
to-report perc-subj-disc-attacks [best-all]
  let tot-attacks 0
  ifelse best-all = "all" [
    set tot-attacks attacks
  ][
    set tot-attacks attacks with [mytheory-end1 = (start 0)]
  ]
  let #groups scientists / 5
  let max-score count tot-attacks * #groups
  let realized-score 0
  ask tot-attacks [
   set realized-score realized-score + length filter [subj-known -> 
    subj-known = true] in-group-i-memory
  ]
  report realized-score / max-score * 100
end





; reports the input value (communication costs) in the form: comunication costs 
; in days per researcher
to-report normalize-days-per-scientist [input]
  let normalization-factor (1 / (scientists * max-learn))
  report input * normalization-factor
end






; reports the cumulative comunication costs per researcher in days
to-report cum-com-costs
  report normalize-days-per-scientist g-cum-com-costs
end





; reports the maximal comunication costs per researcher in days
; (argument = "value") or the round in which the maximal comunication ocurred
; (argument = "round")
to-report max-com-costs [round-value]
  ifelse round-value = "value"[
    report normalize-days-per-scientist item 0 g-max-com-costs
  ][
    report item 1 g-max-com-costs
  ]
end





; reports the unpaid comunication costs per researcher in days
to-report unpaid-com-costs
  report normalize-days-per-scientist g-unpaid-com-costs
end





; This procedure draws a heatmap where the brightness of a patch is proportional
; to the proportion of researcher which know the arguments (and optionally 
; attacks) concerning this patch.
; This procedure is intended to be used for visualization purposes and is not 
; recommended in its current form for performance critical applications
; argument: including-attacks?, type: boolean
; whether or not knowledge about the attack relations connected to
; arguments on this patch is taken into account for drawing the heatmap
to heatmap [including-attacks?]
  let #groups length colla-networks  
  let sorted-starts sort starts
  ask patches with [any? turtles-here][
    let my-startsargum-attacks 0
    let #my-startsargum-attacks 0
    let my-startsargum (turtle-set arguments-here starts-here)
    if including-attacks? [
      set my-startsargum-attacks (link-set [my-attacks] of my-startsargum)
      set #my-startsargum-attacks count my-startsargum-attacks
    ]
    let #my-startsargum count my-startsargum
    ; In case of ties, the first theory among the tied ones is picked,
    ; in order to avoid border patches switching colors randomly
    let my-theory first sort modes [mytheory] of my-startsargum
    let max-score #groups * (#my-startsargum + #my-startsargum-attacks)
    let realized-score 0
    ask my-startsargum [
     set realized-score realized-score + length filter [subj-color -> 
      subj-color < cyan] group-color-mem
    ]
    if including-attacks? [
      ask my-startsargum-attacks [
        set realized-score realized-score + length filter [subj-known -> 
          subj-known = true] in-group-i-memory
      ]
    ]
    let my-color 0
    ifelse my-theory = item 0 sorted-starts [
      set my-color red
    ][
      ifelse my-theory = item 1 sorted-starts [
        set my-color turquoise
      ][
        set my-color green
      ]
    ]
    set pcolor scale-color my-color realized-score 0 max-score
  ]
end